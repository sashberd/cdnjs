!(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("hoist-non-inferno-statics"),require("inferno"),require("inferno-component"),require("mobx")):"function"==typeof define&&define.amd?define(["exports","hoist-non-inferno-statics","inferno","inferno-component","mobx"],t):t((e.Inferno=e.Inferno||{},e.Inferno.Mobx=e.Inferno.Mobx||{}),e.hoistStatics,e.Inferno,e.Inferno.Component,e.mobx)})(this,(function(e,t,n,r,o){"use strict";function i(e){d=e}function s(e,t,n){var r=e[t],o=m[t];e[t]=r?!0===n?function(){o.apply(this,arguments),r.apply(this,arguments)}:function(){r.apply(this,arguments),o.apply(this,arguments)}:o}function a(e,t){if(null==e||null==t||"object"!=typeof e||"object"!=typeof t)return e!==t;var n=Object.keys(e);if(n.length!==Object.keys(t).length)return!0;for(var r=n.length-1;r>=0;r--){var o=n[r];if(t[o]!==e[o])return!0}return!1}function c(e,t){if("string"==typeof e)throw new Error("Store names should be provided as array");if(Array.isArray(e))return h||(h=!0,console.warn('Mobx observer: Using observer to inject stores is deprecated since 4.0. Use `@inject("store1", "store2") @observer ComponentClass` or `inject("store1", "store2")(observer(componentClass))` instead of `@observer(["store1", "store2"]) ComponentClass`')),t?l.apply(null,e)(c(t)):function(t){return c(e,t)};var n=e;if(!n)throw new Error("Please pass a valid component");return!0===n.isMobxInjector&&console.warn("Mobx observer: You are trying to use 'observer' on a component that already has 'inject'. Please apply 'observer' before applying 'inject'"),"function"!=typeof n||n.prototype&&n.prototype.render||n.isReactClass||r.isPrototypeOf(n)?(p(n.prototype||n),n.isMobXReactObserver=!0,n):c((o=(function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(e,t,r){return n(e,r)},t})(r),o.displayName=n.displayName||n.name,o.defaultProps=n.defaultProps,o));var o}function p(e){s(e,"componentWillMount",!0),["componentDidMount","componentWillUnmount","componentDidUpdate"].forEach((function(t){s(e,t)})),e.shouldComponentUpdate||(e.shouldComponentUpdate=m.shouldComponentUpdate)}function u(e,o,i){var s="inject-"+(o.displayName||o.name||o.constructor&&o.constructor.name||"Unknown");i&&(s+="-with-"+i);var a=(function(t){function r(){var e=this;t.apply(this,arguments),this.wrappedInstance=null,this.storeRef=function(t){e.wrappedInstance=t}}return t&&(r.__proto__=t),r.prototype=Object.create(t&&t.prototype),r.prototype.constructor=r,r.prototype.render=function(t,r,i){var s={};for(var a in t)t.hasOwnProperty(a)&&(s[a]=t[a]);var c=e(i.mobxStores||{},s,i)||{};for(var p in c)s[p]=c[p];return n.createVNode(8,o,null,null,s,t.key,this.storeRef)},r})(r);return a.wrappedComponent=o,a.displayName=s,a.isMobxInjector=!0,t(a,o),a}function f(e){return function(t,n){return e.forEach((function(e){if(!(e in n)){if(!(e in t))throw new Error('MobX observer: Store "'+e+'" is not available! Make sure it is provided by some Provider');n[e]=t[e]}})),n}}function l(e){var t,n=arguments;if("function"==typeof e)return t=e,function(e){var n=u(t,e);return n.isMobxInjector=!1,n=c(n),n.isMobxInjector=!0,n};for(var r=[],o=0;o<arguments.length;o++)r[o]=n[o];return t=f(r),function(e){return u(t,e,r.join("-"))}}t=t&&"default"in t?t.default:t,r=r&&"default"in r?r.default:r;var d=!1,h=!1,m={componentWillMount:function(){function e(e){var t=this[e],n=new o.Atom("reactive "+e);Object.defineProperty(this,e,{configurable:!0,enumerable:!0,get:function(){return n.reportObserved(),t},set:function(e){!c&&a(t,e)?(t=e,s=!0,n.reportChanged(),s=!1):t=e}})}var t=this;if(!0!==d){var n=this.displayName||this.name||this.constructor&&(this.constructor.displayName||this.constructor.name)||"<component>",i=this._reactInternalInstance&&this._reactInternalInstance._rootNodeID,s=!1,c=!1;e.call(this,"props"),e.call(this,"state");var p,u=this.render.bind(this),f=!1,l=function(e,t,n){f=!1;var r;return p.track((function(){r=o.extras.allowStateChanges(!1,(function(){return u(e,t,n)}))})),r};this.render=function(){return p=new o.Reaction(n+"#"+i+".render()",function(){if(!f&&(f=!0,"function"==typeof t.componentWillReact&&t.componentWillReact(),!0!==t.__$mobxIsUnmounted)){var e=!0;try{c=!0,s||r.prototype.forceUpdate.call(t),e=!1}finally{c=!1,e&&p.dispose()}}}),l.$mobx=p,t.render=l,l(t.props,t.state,t.context)}}},componentWillUnmount:function(){!0!==d&&(this.render.$mobx&&this.render.$mobx.dispose(),this.__$mobxIsUnmounted=!0)},shouldComponentUpdate:function(e,t){return d&&console.warn("[mobx-react] It seems that a re-rendering of a React component is triggered while in static (server-side) mode. Please make sure components are rendered only once server-side."),this.state!==t||a(this.props,e)}},y=c((function(e){return(0,e.children)()})),v={children:!0,key:!0,ref:!0},b=(function(e){function t(t,n){e.call(this,t,n),this.contextTypes={mobxStores:function(){}},this.childContextTypes={mobxStores:function(){}},this.store=t.store}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.render=function(){return this.props.children},t.prototype.getChildContext=function(){var e=this,t={},n=this.context.mobxStores;if(n)for(var r in n)t[r]=n[r];for(var o in e.props)v[o]||"suppressChangedStoreWarning"===o||(t[o]=e.props[o]);return{mobxStores:t}},t})(r),x=function(){this.listeners=[]};x.prototype.on=function(e){var t=this;return this.listeners.push(e),function(){var n=t.listeners.indexOf(e);-1!==n&&t.listeners.splice(n,1)}},x.prototype.emit=function(e){for(var t=this.listeners,n=0,r=t.length;n<r;n++)t[n](e)};var j={EventEmitter:x,Observer:y,Provider:b,inject:l,observer:c,renderReporter:x,useStaticRendering:i};e.EventEmitter=x,e.Observer=y,e.Provider=b,e.inject=l,e.observer=c,e.renderReporter=x,e.useStaticRendering=i,e.default=j,Object.defineProperty(e,"__esModule",{value:!0})}));
