{"version":3,"sources":["vs/editor/common/services/editorSimpleWorker.js","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/diff/diffChange.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/diff/diff.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/filters.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/uri.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/arrays.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/modeTransition.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/position.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/range.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/diff/diffComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/linkComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/supports/inplaceReplaceSupport.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/services/editorSimpleWorkerCommon.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/viewModel/prefixSumComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/model/mirrorModel2.ts","vs/editor/common/services/fake","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/config/defaultConfig.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/nullMode.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/model/textModelWithTokensHelpers.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/services/editorSimpleWorker.ts"],"names":["define","require","exports","DifferenceType","Add","Remove","Change","DiffChange","originalStart","originalLength","modifiedStart","modifiedLength","this","prototype","getChangeType","getOriginalEnd","getModifiedEnd","diffChange_1","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","length","i","MaxDifferencesHistory","DiffChangeHelper","m_changes","m_originalStart","Number","MAX_VALUE","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","Math","min","AddModifiedElement","getChanges","getReverseChanges","reverse","LcsDiff","originalSequence","newSequence","continueProcessingPredicate","OriginalSequence","ModifiedSequence","ContinueProcessingPredicate","m_originalIds","m_modifiedIds","m_forwardHistory","m_reverseHistory","ComputeUniqueIdentifiers","originalSequenceLength","getLength","modifiedSequenceLength","Array","hashTable","currentUniqueId","originalElementHash","getElementHash","hasOwnProperty","modifiedElementHash","ElementsAreEqual","newIndex","ComputeDiff","_ComputeDiff","originalEnd","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","changes","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","diagonal","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","MIN_VALUE","historyIndex","originalStartPoint","modifiedStartPoint","lastForwardChange","max","numDifferences","maxDifferences","numDiagonals","delta","tempOriginalIndex","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","abs","matchLengthOfLongest","temp","left","right","mergedChangeArr","ChangesOverlap","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","strings","map_1","or","filter","_i","arguments","word","wordToMatchAgainst","len","match","and","concat","_matchesPrefix","ignoreCase","toLowerCase","start","end","matchesContiguousSubString","index","indexOf","matchesSubString","_matchesSubString","j","join","isLower","code","isUpper","isNumber","isWhitespace","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","charCodeAt","_matchesCamelCase","nextUpperIndex","isCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isCamelCasePattern","whitespace","matchesCamelCase","matchesWords","target","_matchesWords","nextWord","nextWordIndex","matchesFuzzy","enableSeparateSubstringMatching","regexp","fuzzyRegExpCache","get","RegExp","convertSimple2RegExpPattern","set","exec","fuzzySeparateFilter","fuzzyContiguousFilter","matchesStrictPrefix","matchesPrefix","SubstringMatching","LinkedMap","platform","_encode","ch","toString","toUpperCase","encodeURIComponent2","str","encodeURIComponent","replace","encodeNoop","URI","_scheme","_empty","_authority","_path","_query","_fragment","_formatted","_fsPath","Object","defineProperty","enumerable","configurable","value","scheme","_driveLetterPath","test","substr","isWindows","change","ret","authority","path","query","fragment","_validate","parse","data","_parseComponents","decodeURIComponent","file","_slash","idx","substring","_regexp","create","skipEncoding","_asFormatted","uri","encoder","parts","m","_upperCaseDrive","lastIdx","toJSON","fsPath","external","$mid","revive","Arrays","findIndexInSegmentsArray","arr","desiredIndex","low","high","mid","ceil","startIndex","arrays_1","ModeTransition","mode","modeTransitions","modeTransition","Position","lineNumber","column","equals","other","a","b","isBefore","isBeforeOrEqual","clone","lift","pos","isIPosition","obj","asEmptyRange","position","startLineNumber","startColumn","endLineNumber","endColumn","startPosition","range","endPosition","position_1","Range","isEmpty","containsPosition","containsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","cloneRange","setEndPosition","setStartPosition","collapseToStart","isIRange","otherRange","areIntersectingOrTouching","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","compareRangesUsingEnds","spansMultipleLines","__extends","d","__","constructor","p","diff_1","computeDiff","modifiedSequence","diffAlgo","postProcessCharChanges","rawChanges","originalMatchingLength","modifiedMatchingLength","matchingLength","currChange","prevChange","MINIMUM_MATCHING_CHARACTER_LENGTH","MAXIMUM_RUN_TIME","MarkerSequence","buffer","startMarkers","endMarkers","otherMarkerSequence","myElement","otherElement","offset","getStartLineNumber","getStartColumn","getEndLineNumber","getEndColumn","LineMarkerSequence","_super","lines","shouldIgnoreTrimWhitespace","_getFirstNonBlankColumn","_getLastNonBlankColumn","call","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","getCharSequence","endIndex","startMarker","endMarker","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","LineChange","originalLineSequence","modifiedLineSequence","shouldPostProcessCharChanges","charChanges","DiffComputer","originalLines","modifiedLines","opts","maximumRunTimeMs","original","modified","shouldConsiderTrimWhitespaceInEmptyCase","computationStartTime","Date","getTime","_continueProcessingPredicate","bind","lineChanges","now","computeLinks","model","getLineCount","getLineContent","LinkComputer","STATE_MAP","START_STATE","END_STATE","ACCEPT_STATE","h","H","f","F","t","T","P","s","S",":","/","I","l","L","e","E","CharacterClass","_openParens","_closeParens","_openSquareBracket","_closeSquareBracket","_openCurlyBracket","_closeCurlyBracket","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","_asciiMap","None","_map","_set","ForceTermination","CannotEndIn","charCode","charClass","classify","_createLink","line","linkBeginIndex","linkEndIndex","url","lineCount","lastIncludedCharIndex","state","chCode","chClass","resetStateMachine","hasOpenParens","hasOpenSquareBracket","hasOpenCurlyBracket","characterClassifier","_characterClassifier","charAt","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","text","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","floor","String","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","EditorSimpleWorker","acceptNewModel","acceptModelChanged","modelUrl","events","acceptRemovedModel","originalUrl","modifiedUrl","ignoreTrimWhitespace","computeDirtyDiff","textualSuggest","wordDef","wordDefFlags","PrefixSumIndexOfResult","remainder","PrefixSumComputer","values","prefixSum","prefixSumValidIndex","getCount","insertValue","insertIndex","splice","insertValues","slice","_zeroArray","count","changeValue","removeValues","cnt","getTotalValue","getAccumulatedValue","getIndexOf","accumulatedValue","midStop","midStart","prefixSumComputer_1","MirrorModel2","eol","versionId","_uri","_lines","_eol","_versionId","dispose","getText","onEvents","newEOL","_lineStarts","lastVersionId","_acceptDeleteRange","_acceptInsertText","_ensureLineStarts","lineStartValues","eolLength","_setLineText","lineIndex","newValue","insertText","insertLines","split","newLengths","nls","USUAL_WORD_SEPARATORS","DEFAULT_INDENTATION","tabSize","insertSpaces","detectIndentation","DEFAULT_TRIM_AUTO_WHITESPACE","DEFAULT_WINDOWS_FONT_FAMILY","DEFAULT_MAC_FONT_FAMILY","DEFAULT_LINUX_FONT_FAMILY","GOLDEN_LINE_HEIGHT_RATIO","isMacintosh","ConfigClass","editor","experimentalScreenReader","rulers","wordSeparators","selectionClipboard","ariaLabel","localize","lineNumbers","selectOnLineNumbers","lineNumbersMinChars","glyphMargin","lineDecorationsWidth","revealHorizontalRightPadding","roundedSelection","theme","readOnly","scrollbar","verticalScrollbarSize","horizontal","useShadows","verticalHasArrows","horizontalHasArrows","overviewRulerLanes","cursorBlinking","cursorStyle","fontLigatures","disableTranslate3d","hideCursorInOverviewRuler","scrollBeyondLastLine","automaticLayout","wrappingColumn","wrappingIndent","wordWrapBreakBeforeCharacters","wordWrapBreakAfterCharacters","wordWrapBreakObtrusiveCharacters","tabFocusMode","hover","contextmenu","mouseWheelScrollSensitivity","quickSuggestions","quickSuggestionsDelay","iconsInSuggestions","autoClosingBrackets","formatOnType","suggestOnTriggerCharacters","acceptSuggestionOnEnter","selectionHighlight","outlineMarkers","referenceInfos","folding","renderWhitespace","indentGuides","useTabStops","fontFamily","isLinux","fontSize","lineHeight","DefaultConfig","defaultConfig_1","nullTokenize","deltaOffset","stopAtOffset","tokens","type","actualStopOffset","endState","NullState","stateData","stateDataClone","getMode","otherStateData","getStateData","tokenize","stream","advanceToEOS","setStateData","NullMode","richEditSupport","wordDefinition","DEFAULT_WORD_REGEXP","createWordRegExp","allowInWords","usualSeparators","source","getId","ID","toSimplifiedMode","nullMode_1","modeTransition_1","WordHelper","_safeGetWordDefinition","ensureValidWordDefinition","global","flags","multiline","lastIndex","massageWordDefinitionOf","_getWordAtColumn","modeIndex","modeStartIndex","modeEndIndex","_getWordAtText","getWordAtPosition","textSource","_lineIsTokenized","_getLineModeTransitions","columnIndex","textOffset","k","startWord","endWord","words","trim","uri_1","winjs_base_1","range_1","filters_1","diffComputer_1","mirrorModel2_1","textModelWithTokensHelpers_1","linkComputer_1","inplaceReplaceSupport_1","editorSimpleWorkerCommon_1","EditorSimpleWorkerImpl","MirrorModel","apply","getLinesContent","wordAtText","getWordUntilPosition","wordAtPosition","_getAllWords","_this","forEach","_wordenize","info","getAllUniqueWords","skipWordOnce","foundSkipWord","uniqueWords","content","getValueInRange","lineEnding","startLineIndex","endLineIndex","resultLines","_models","EOL","strURL","diffComputer","TPromise","as","_suggestFiltered","wordDefRegExp","_suggestUnfiltered","currentWord","suggestions","element","label","incomplete","allWords","map","codeSnippet","noAutoAccept","selectionText","wordRange"],"mappings":"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","file":"vs/editor/common/services/editorSimpleWorker.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.2.3(84e204b238a1eff25d4c6f611fdcd76a494005a7)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n\ndefine(\"vs/base/common/diff/diffChange\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.DifferenceType = {\r\n        Add: 0,\r\n        Remove: 1,\r\n        Change: 2\r\n    };\r\n    /**\r\n     * Represents information about a specific difference between two sequences.\r\n     */\r\n    var DiffChange = (function () {\r\n        /**\r\n         * Constructs a new DiffChange with the given sequence information\r\n         * and content.\r\n         */\r\n        function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n            //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\r\n            this.originalStart = originalStart;\r\n            this.originalLength = originalLength;\r\n            this.modifiedStart = modifiedStart;\r\n            this.modifiedLength = modifiedLength;\r\n        }\r\n        /**\r\n         * The type of difference.\r\n         */\r\n        DiffChange.prototype.getChangeType = function () {\r\n            if (this.originalLength === 0) {\r\n                return exports.DifferenceType.Add;\r\n            }\r\n            else if (this.modifiedLength === 0) {\r\n                return exports.DifferenceType.Remove;\r\n            }\r\n            else {\r\n                return exports.DifferenceType.Change;\r\n            }\r\n        };\r\n        /**\r\n         * The end point (exclusive) of the change in the original sequence.\r\n         */\r\n        DiffChange.prototype.getOriginalEnd = function () {\r\n            return this.originalStart + this.originalLength;\r\n        };\r\n        /**\r\n         * The end point (exclusive) of the change in the modified sequence.\r\n         */\r\n        DiffChange.prototype.getModifiedEnd = function () {\r\n            return this.modifiedStart + this.modifiedLength;\r\n        };\r\n        return DiffChange;\r\n    }());\r\n    exports.DiffChange = DiffChange;\r\n});\r\n\ndefine(\"vs/base/common/diff/diff\", [\"require\", \"exports\", 'vs/base/common/diff/diffChange'], function (require, exports, diffChange_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    //\r\n    // The code below has been ported from a C# implementation in VS\r\n    //\r\n    var Debug = (function () {\r\n        function Debug() {\r\n        }\r\n        Debug.Assert = function (condition, message) {\r\n            if (!condition) {\r\n                throw new Error(message);\r\n            }\r\n        };\r\n        return Debug;\r\n    }());\r\n    exports.Debug = Debug;\r\n    var MyArray = (function () {\r\n        function MyArray() {\r\n        }\r\n        /**\r\n         * Copies a range of elements from an Array starting at the specified source index and pastes\r\n         * them to another Array starting at the specified destination index. The length and the indexes\r\n         * are specified as 64-bit integers.\r\n         * sourceArray:\r\n         *\t\tThe Array that contains the data to copy.\r\n         * sourceIndex:\r\n         *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n         * destinationArray:\r\n         *\t\tThe Array that receives the data.\r\n         * destinationIndex:\r\n         *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n         * length:\r\n         *\t\tA 64-bit integer that represents the number of elements to copy.\r\n         */\r\n        MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n            for (var i = 0; i < length; i++) {\r\n                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n            }\r\n        };\r\n        return MyArray;\r\n    }());\r\n    exports.MyArray = MyArray;\r\n    //*****************************************************************************\r\n    // LcsDiff.cs\r\n    //\r\n    // An implementation of the difference algorithm described in\r\n    // \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\r\n    //\r\n    // Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\r\n    //*****************************************************************************\r\n    // Our total memory usage for storing history is (worst-case):\r\n    // 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\r\n    // 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\r\n    var MaxDifferencesHistory = 1447;\r\n    //let MaxDifferencesHistory = 100;\r\n    /**\r\n     * A utility class which helps to create the set of DiffChanges from\r\n     * a difference operation. This class accepts original DiffElements and\r\n     * modified DiffElements that are involved in a particular change. The\r\n     * MarktNextChange() method can be called to mark the separation between\r\n     * distinct changes. At the end, the Changes property can be called to retrieve\r\n     * the constructed changes.\r\n     */\r\n    var DiffChangeHelper = (function () {\r\n        /**\r\n         * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n         */\r\n        function DiffChangeHelper() {\r\n            this.m_changes = [];\r\n            this.m_originalStart = Number.MAX_VALUE;\r\n            this.m_modifiedStart = Number.MAX_VALUE;\r\n            this.m_originalCount = 0;\r\n            this.m_modifiedCount = 0;\r\n        }\r\n        /**\r\n         * Marks the beginning of the next change in the set of differences.\r\n         */\r\n        DiffChangeHelper.prototype.MarkNextChange = function () {\r\n            // Only add to the list if there is something to add\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Add the new change to our list\r\n                this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n            }\r\n            // Reset for the next change\r\n            this.m_originalCount = 0;\r\n            this.m_modifiedCount = 0;\r\n            this.m_originalStart = Number.MAX_VALUE;\r\n            this.m_modifiedStart = Number.MAX_VALUE;\r\n        };\r\n        /**\r\n         * Adds the original element at the given position to the elements\r\n         * affected by the current change. The modified index gives context\r\n         * to the change position with respect to the original sequence.\r\n         * @param originalIndex The index of the original element to add.\r\n         * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n         */\r\n        DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {\r\n            // The 'true' start index is the smallest of the ones we've seen\r\n            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n            this.m_originalCount++;\r\n        };\r\n        /**\r\n         * Adds the modified element at the given position to the elements\r\n         * affected by the current change. The original index gives context\r\n         * to the change position with respect to the modified sequence.\r\n         * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n         * @param modifiedIndex The index of the modified element to add.\r\n         */\r\n        DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {\r\n            // The 'true' start index is the smallest of the ones we've seen\r\n            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n            this.m_modifiedCount++;\r\n        };\r\n        /**\r\n         * Retrieves all of the changes marked by the class.\r\n         */\r\n        DiffChangeHelper.prototype.getChanges = function () {\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Finish up on whatever is left\r\n                this.MarkNextChange();\r\n            }\r\n            return this.m_changes;\r\n        };\r\n        DiffChangeHelper.prototype.getReverseChanges = function () {\r\n            /// <summary>\r\n            /// Retrieves all of the changes marked by the class in the reverse order\r\n            /// </summary>\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Finish up on whatever is left\r\n                this.MarkNextChange();\r\n            }\r\n            this.m_changes.reverse();\r\n            return this.m_changes;\r\n        };\r\n        return DiffChangeHelper;\r\n    }());\r\n    /**\r\n     * An implementation of the difference algorithm described in\r\n     * \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\r\n     */\r\n    var LcsDiff = (function () {\r\n        /**\r\n         * Constructs the DiffFinder\r\n         */\r\n        function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {\r\n            if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }\r\n            this.OriginalSequence = originalSequence;\r\n            this.ModifiedSequence = newSequence;\r\n            this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n            this.m_originalIds = [];\r\n            this.m_modifiedIds = [];\r\n            this.m_forwardHistory = [];\r\n            this.m_reverseHistory = [];\r\n            this.ComputeUniqueIdentifiers();\r\n        }\r\n        LcsDiff.prototype.ComputeUniqueIdentifiers = function () {\r\n            var originalSequenceLength = this.OriginalSequence.getLength();\r\n            var modifiedSequenceLength = this.ModifiedSequence.getLength();\r\n            this.m_originalIds = new Array(originalSequenceLength);\r\n            this.m_modifiedIds = new Array(modifiedSequenceLength);\r\n            // Create a new hash table for unique elements from the original\r\n            // sequence.\r\n            var hashTable = {};\r\n            var currentUniqueId = 1;\r\n            var i;\r\n            // Fill up the hash table for unique elements\r\n            for (i = 0; i < originalSequenceLength; i++) {\r\n                var originalElementHash = this.OriginalSequence.getElementHash(i);\r\n                if (!hashTable.hasOwnProperty(originalElementHash)) {\r\n                    // No entry in the hashtable so this is a new unique element.\r\n                    // Assign the element a new unique identifier and add it to the\r\n                    // hash table\r\n                    this.m_originalIds[i] = currentUniqueId++;\r\n                    hashTable[originalElementHash] = this.m_originalIds[i];\r\n                }\r\n                else {\r\n                    this.m_originalIds[i] = hashTable[originalElementHash];\r\n                }\r\n            }\r\n            // Now match up modified elements\r\n            for (i = 0; i < modifiedSequenceLength; i++) {\r\n                var modifiedElementHash = this.ModifiedSequence.getElementHash(i);\r\n                if (!hashTable.hasOwnProperty(modifiedElementHash)) {\r\n                    this.m_modifiedIds[i] = currentUniqueId++;\r\n                    hashTable[modifiedElementHash] = this.m_modifiedIds[i];\r\n                }\r\n                else {\r\n                    this.m_modifiedIds[i] = hashTable[modifiedElementHash];\r\n                }\r\n            }\r\n        };\r\n        LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {\r\n            return this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];\r\n        };\r\n        LcsDiff.prototype.ComputeDiff = function () {\r\n            return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);\r\n        };\r\n        /**\r\n         * Computes the differences between the original and modified input\r\n         * sequences on the bounded range.\r\n         * @returns An array of the differences between the two input sequences.\r\n         */\r\n        LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd) {\r\n            var quitEarlyArr = [false];\r\n            return this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        };\r\n        /**\r\n         * Private helper method which computes the differences on the bounded range\r\n         * recursively.\r\n         * @returns An array of the differences between the two input sequences.\r\n         */\r\n        LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n            quitEarlyArr[0] = false;\r\n            // Find the start of the differences\r\n            while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n                originalStart++;\r\n                modifiedStart++;\r\n            }\r\n            // Find the end of the differences\r\n            while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n                originalEnd--;\r\n                modifiedEnd--;\r\n            }\r\n            // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n            if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n                var changes = void 0;\r\n                if (modifiedStart <= modifiedEnd) {\r\n                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                    // All insertions\r\n                    changes = [\r\n                        new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n                else if (originalStart <= originalEnd) {\r\n                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                    // All deletions\r\n                    changes = [\r\n                        new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                    ];\r\n                }\r\n                else {\r\n                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                    // Identical sequences - No differences\r\n                    changes = [];\r\n                }\r\n                return changes;\r\n            }\r\n            // This problem can be solved using the Divide-And-Conquer technique.\r\n            var midOriginalArr = [0], midModifiedArr = [0];\r\n            var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n            var midOriginal = midOriginalArr[0];\r\n            var midModified = midModifiedArr[0];\r\n            if (result !== null) {\r\n                // Result is not-null when there was enough memory to compute the changes while\r\n                // searching for the recursion point\r\n                return result;\r\n            }\r\n            else if (!quitEarlyArr[0]) {\r\n                // We can break the problem down recursively by finding the changes in the\r\n                // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n                // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n                // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n                var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n                var rightChanges = [];\r\n                if (!quitEarlyArr[0]) {\r\n                    rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We did't have time to finish the first half, so we don't have time to compute this half.\r\n                    // Consider the entire rest of the sequence different.\r\n                    rightChanges = [\r\n                        new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                    ];\r\n                }\r\n                return this.ConcatenateChanges(leftChanges, rightChanges);\r\n            }\r\n            // If we hit here, we quit early, and so can't return anything meaningful\r\n            return [\r\n                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n            ];\r\n        };\r\n        LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n            var forwardChanges = null, reverseChanges = null;\r\n            // First, walk backward through the forward diagonals history\r\n            var changeHelper = new DiffChangeHelper();\r\n            var diagonalMin = diagonalForwardStart;\r\n            var diagonalMax = diagonalForwardEnd;\r\n            var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n            var lastOriginalIndex = Number.MIN_VALUE;\r\n            var historyIndex = this.m_forwardHistory.length - 1;\r\n            var diagonal;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                diagonal = diagonalRelative + diagonalForwardBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    // Vertical line (the element is an insert)\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                    if (originalIndex < lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                    diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Horizontal line (the element is a deletion)\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                    if (originalIndex < lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex - 1;\r\n                    changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    forwardPoints = this.m_forwardHistory[historyIndex];\r\n                    diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = forwardPoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // Ironically, we get the forward changes as the reverse of the\r\n            // order we added them since we technically added them backwards\r\n            forwardChanges = changeHelper.getReverseChanges();\r\n            if (quitEarlyArr[0]) {\r\n                // TODO: Calculate a partial from the reverse diagonals.\r\n                //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n                var originalStartPoint = midOriginalArr[0] + 1;\r\n                var modifiedStartPoint = midModifiedArr[0] + 1;\r\n                if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                    var lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                    originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                    modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n                }\r\n                reverseChanges = [\r\n                    new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n                ];\r\n            }\r\n            else {\r\n                // Now walk backward through the reverse diagonals history\r\n                changeHelper = new DiffChangeHelper();\r\n                diagonalMin = diagonalReverseStart;\r\n                diagonalMax = diagonalReverseEnd;\r\n                diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n                lastOriginalIndex = Number.MAX_VALUE;\r\n                historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n                do {\r\n                    // Get the diagonal index from the relative diagonal number\r\n                    diagonal = diagonalRelative + diagonalReverseBase;\r\n                    // Figure out where we came from\r\n                    if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                        // Horizontal line (the element is a deletion))\r\n                        originalIndex = reversePoints[diagonal + 1] - 1;\r\n                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                        if (originalIndex > lastOriginalIndex) {\r\n                            changeHelper.MarkNextChange();\r\n                        }\r\n                        lastOriginalIndex = originalIndex + 1;\r\n                        changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                        diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                    }\r\n                    else {\r\n                        // Vertical line (the element is an insertion)\r\n                        originalIndex = reversePoints[diagonal - 1];\r\n                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                        if (originalIndex > lastOriginalIndex) {\r\n                            changeHelper.MarkNextChange();\r\n                        }\r\n                        lastOriginalIndex = originalIndex;\r\n                        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                        diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                    }\r\n                    if (historyIndex >= 0) {\r\n                        reversePoints = this.m_reverseHistory[historyIndex];\r\n                        diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                        diagonalMin = 1;\r\n                        diagonalMax = reversePoints.length - 1;\r\n                    }\r\n                } while (--historyIndex >= -1);\r\n                // There are cases where the reverse history will find diffs that\r\n                // are correct, but not intuitive, so we need shift them.\r\n                reverseChanges = changeHelper.getChanges();\r\n            }\r\n            return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n        };\r\n        /**\r\n         * Given the range to compute the diff on, this method finds the point:\r\n         * (midOriginal, midModified)\r\n         * that exists in the middle of the LCS of the two sequences and\r\n         * is the point at which the LCS problem may be broken down recursively.\r\n         * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n         * point is calculated and the full trace is available in memory, then this method\r\n         * will return the change list.\r\n         * @param originalStart The start bound of the original sequence range\r\n         * @param originalEnd The end bound of the original sequence range\r\n         * @param modifiedStart The start bound of the modified sequence range\r\n         * @param modifiedEnd The end bound of the modified sequence range\r\n         * @param midOriginal The middle point of the original sequence range\r\n         * @param midModified The middle point of the modified sequence range\r\n         * @returns The diff changes, if available, otherwise null\r\n         */\r\n        LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n            var originalIndex, modifiedIndex;\r\n            var diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n            var diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n            var numDifferences;\r\n            // To traverse the edit graph and produce the proper LCS, our actual\r\n            // start position is just outside the given boundary\r\n            originalStart--;\r\n            modifiedStart--;\r\n            // We set these up to make the compiler happy, but they will\r\n            // be replaced before we return with the actual recursion point\r\n            midOriginalArr[0] = 0;\r\n            midModifiedArr[0] = 0;\r\n            // Clear out the history\r\n            this.m_forwardHistory = [];\r\n            this.m_reverseHistory = [];\r\n            // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n            // The integer value in the cell represents the originalIndex of the furthest\r\n            // reaching point found so far that ends in that diagonal.\r\n            // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n            var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n            var numDiagonals = maxDifferences + 1;\r\n            var forwardPoints = new Array(numDiagonals);\r\n            var reversePoints = new Array(numDiagonals);\r\n            // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n            // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n            var diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n            var diagonalReverseBase = (originalEnd - originalStart);\r\n            // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n            //    diagonal number (relative to diagonalForwardBase)\r\n            // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n            //    diagonal number (relative to diagonalReverseBase)\r\n            var diagonalForwardOffset = (originalStart - modifiedStart);\r\n            var diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n            // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n            //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n            // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n            var delta = diagonalReverseBase - diagonalForwardBase;\r\n            var deltaIsEven = (delta % 2 === 0);\r\n            // Here we set up the start and end points as the furthest points found so far\r\n            // in both the forward and reverse directions, respectively\r\n            forwardPoints[diagonalForwardBase] = originalStart;\r\n            reversePoints[diagonalReverseBase] = originalEnd;\r\n            // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n            quitEarlyArr[0] = false;\r\n            // A couple of points:\r\n            // --With this method, we iterate on the number of differences between the two sequences.\r\n            //   The more differences there actually are, the longer this will take.\r\n            // --Also, as the number of differences increases, we have to search on diagonals further\r\n            //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n            // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n            //   is even and odd diagonals only when numDifferences is odd.\r\n            var diagonal, tempOriginalIndex;\r\n            for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n                var furthestOriginalIndex = 0;\r\n                var furthestModifiedIndex = 0;\r\n                // Run the algorithm in the forward direction\r\n                diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n                diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n                for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                    // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                    // by looking at the diagonals above and below and picking the one whose point\r\n                    // is further away from the start point (originalStart, modifiedStart)\r\n                    if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                        originalIndex = forwardPoints[diagonal + 1];\r\n                    }\r\n                    else {\r\n                        originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                    }\r\n                    modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                    // Save the current originalIndex so we can test for false overlap in step 3\r\n                    tempOriginalIndex = originalIndex;\r\n                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                    // so long as the elements are equal.\r\n                    while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                        originalIndex++;\r\n                        modifiedIndex++;\r\n                    }\r\n                    forwardPoints[diagonal] = originalIndex;\r\n                    if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                        furthestOriginalIndex = originalIndex;\r\n                        furthestModifiedIndex = modifiedIndex;\r\n                    }\r\n                    // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                    // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                    // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                    // then check for overlap.\r\n                    if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                        if (originalIndex >= reversePoints[diagonal]) {\r\n                            midOriginalArr[0] = originalIndex;\r\n                            midModifiedArr[0] = modifiedIndex;\r\n                            if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                                // BINGO! We overlapped, and we have the full trace in memory!\r\n                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                            }\r\n                            else {\r\n                                // Either false overlap, or we didn't have enough memory for the full trace\r\n                                // Just return the recursion point\r\n                                return null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Check to see if we should be quitting early, before moving on to the next iteration.\r\n                var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n                if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\r\n                    // We can't finish, so skip ahead to generating a result from what we have.\r\n                    quitEarlyArr[0] = true;\r\n                    // Use the furthest distance we got in the forward direction.\r\n                    midOriginalArr[0] = furthestOriginalIndex;\r\n                    midModifiedArr[0] = furthestModifiedIndex;\r\n                    if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                        // Enough of the history is in memory to walk it backwards\r\n                        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                    }\r\n                    else {\r\n                        // We didn't actually remember enough of the history.\r\n                        //Since we are quiting the diff early, we need to shift back the originalStart and modified start\r\n                        //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                        originalStart++;\r\n                        modifiedStart++;\r\n                        return [\r\n                            new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                        ];\r\n                    }\r\n                }\r\n                // Run the algorithm in the reverse direction\r\n                diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n                diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n                for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                    // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                    // by looking at the diagonals above and below and picking the one whose point\r\n                    // is further away from the start point (originalEnd, modifiedEnd)\r\n                    if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                        originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    }\r\n                    else {\r\n                        originalIndex = reversePoints[diagonal - 1];\r\n                    }\r\n                    modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                    // Save the current originalIndex so we can test for false overlap\r\n                    tempOriginalIndex = originalIndex;\r\n                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                    // as long as the elements are equal.\r\n                    while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                        originalIndex--;\r\n                        modifiedIndex--;\r\n                    }\r\n                    reversePoints[diagonal] = originalIndex;\r\n                    // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                    // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                    // then check for overlap.\r\n                    if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                        if (originalIndex <= forwardPoints[diagonal]) {\r\n                            midOriginalArr[0] = originalIndex;\r\n                            midModifiedArr[0] = modifiedIndex;\r\n                            if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                                // BINGO! We overlapped, and we have the full trace in memory!\r\n                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                            }\r\n                            else {\r\n                                // Either false overlap, or we didn't have enough memory for the full trace\r\n                                // Just return the recursion point\r\n                                return null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Save current vectors to history before the next iteration\r\n                if (numDifferences <= MaxDifferencesHistory) {\r\n                    // We are allocating space for one extra int, which we fill with\r\n                    // the index of the diagonal base index\r\n                    var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                    temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                    MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                    this.m_forwardHistory.push(temp);\r\n                    temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                    temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                    MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                    this.m_reverseHistory.push(temp);\r\n                }\r\n            }\r\n            // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n            // NOTE: This part is a bit messy\r\n            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n        };\r\n        /**\r\n         * Concatenates the two input DiffChange lists and returns the resulting\r\n         * list.\r\n         * @param The left changes\r\n         * @param The right changes\r\n         * @returns The concatenated list\r\n         */\r\n        LcsDiff.prototype.ConcatenateChanges = function (left, right) {\r\n            var mergedChangeArr = [];\r\n            var result = null;\r\n            if (left.length === 0 || right.length === 0) {\r\n                return (right.length > 0) ? right : left;\r\n            }\r\n            else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n                // Since we break the problem down recursively, it is possible that we\r\n                // might recurse in the middle of a change thereby splitting it into\r\n                // two changes. Here in the combining stage, we detect and fuse those\r\n                // changes back together\r\n                result = new Array(left.length + right.length - 1);\r\n                MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n                result[left.length - 1] = mergedChangeArr[0];\r\n                MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n                return result;\r\n            }\r\n            else {\r\n                result = new Array(left.length + right.length);\r\n                MyArray.Copy(left, 0, result, 0, left.length);\r\n                MyArray.Copy(right, 0, result, left.length, right.length);\r\n                return result;\r\n            }\r\n        };\r\n        /**\r\n         * Returns true if the two changes overlap and can be merged into a single\r\n         * change\r\n         * @param left The left change\r\n         * @param right The right change\r\n         * @param mergedChange The merged change if the two overlap, null otherwise\r\n         * @returns True if the two changes overlap\r\n         */\r\n        LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {\r\n            Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n            Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n            if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                var originalStart = left.originalStart;\r\n                var originalLength = left.originalLength;\r\n                var modifiedStart = left.modifiedStart;\r\n                var modifiedLength = left.modifiedLength;\r\n                if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                    originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n                }\r\n                if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                    modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n                }\r\n                mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n                return true;\r\n            }\r\n            else {\r\n                mergedChangeArr[0] = null;\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Helper method used to clip a diagonal index to the range of valid\r\n         * diagonals. This also decides whether or not the diagonal index,\r\n         * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n         * one inside the boundary depending on the Even/Odd status of the boundary\r\n         * and numDifferences.\r\n         * @param diagonal The index of the diagonal to clip.\r\n         * @param numDifferences The current number of differences being iterated upon.\r\n         * @param diagonalBaseIndex The base reference diagonal.\r\n         * @param numDiagonals The total number of diagonals.\r\n         * @returns The clipped diagonal index.\r\n         */\r\n        LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n            if (diagonal >= 0 && diagonal < numDiagonals) {\r\n                // Nothing to clip, its in range\r\n                return diagonal;\r\n            }\r\n            // diagonalsBelow: The number of diagonals below the reference diagonal\r\n            // diagonalsAbove: The number of diagonals above the reference diagonal\r\n            var diagonalsBelow = diagonalBaseIndex;\r\n            var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n            var diffEven = (numDifferences % 2 === 0);\r\n            if (diagonal < 0) {\r\n                var lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n                return (diffEven === lowerBoundEven) ? 0 : 1;\r\n            }\r\n            else {\r\n                var upperBoundEven = (diagonalsAbove % 2 === 0);\r\n                return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n            }\r\n        };\r\n        return LcsDiff;\r\n    }());\r\n    exports.LcsDiff = LcsDiff;\r\n});\r\n\ndefine(\"vs/base/common/filters\", [\"require\", \"exports\", 'vs/base/common/strings', 'vs/base/common/map'], function (require, exports, strings, map_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // Combined filters\r\n    /**\r\n     * @returns A filter which combines the provided set\r\n     * of filters with an or. The *first* filters that\r\n     * matches defined the return value of the returned\r\n     * filter.\r\n     */\r\n    function or() {\r\n        var filter = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            filter[_i - 0] = arguments[_i];\r\n        }\r\n        return function (word, wordToMatchAgainst) {\r\n            for (var i = 0, len = filter.length; i < len; i++) {\r\n                var match = filter[i](word, wordToMatchAgainst);\r\n                if (match) {\r\n                    return match;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n    exports.or = or;\r\n    /**\r\n     * @returns A filter which combines the provided set\r\n     * of filters with an and. The combines matches are\r\n     * returned if *all* filters match.\r\n     */\r\n    function and() {\r\n        var filter = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            filter[_i - 0] = arguments[_i];\r\n        }\r\n        return function (word, wordToMatchAgainst) {\r\n            var result = [];\r\n            for (var i = 0, len = filter.length; i < len; i++) {\r\n                var match = filter[i](word, wordToMatchAgainst);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                result = result.concat(match);\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    exports.and = and;\r\n    // Prefix\r\n    exports.matchesStrictPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(false, word, wordToMatchAgainst); };\r\n    exports.matchesPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(true, word, wordToMatchAgainst); };\r\n    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n        if (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {\r\n            return null;\r\n        }\r\n        if (ignoreCase) {\r\n            word = word.toLowerCase();\r\n            wordToMatchAgainst = wordToMatchAgainst.toLowerCase();\r\n        }\r\n        for (var i = 0; i < word.length; i++) {\r\n            if (word[i] !== wordToMatchAgainst[i]) {\r\n                return null;\r\n            }\r\n        }\r\n        return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n    }\r\n    // Contiguous Substring\r\n    function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n        if (index === -1) {\r\n            return null;\r\n        }\r\n        return [{ start: index, end: index + word.length }];\r\n    }\r\n    exports.matchesContiguousSubString = matchesContiguousSubString;\r\n    // Substring\r\n    function matchesSubString(word, wordToMatchAgainst) {\r\n        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n    }\r\n    exports.matchesSubString = matchesSubString;\r\n    function _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === wordToMatchAgainst.length) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (word[i] === wordToMatchAgainst[j]) {\r\n                var result = null;\r\n                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                    return join({ start: j, end: j + 1 }, result);\r\n                }\r\n            }\r\n            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n        }\r\n    }\r\n    // CamelCase\r\n    function isLower(code) {\r\n        return 97 <= code && code <= 122;\r\n    }\r\n    function isUpper(code) {\r\n        return 65 <= code && code <= 90;\r\n    }\r\n    function isNumber(code) {\r\n        return 48 <= code && code <= 57;\r\n    }\r\n    function isWhitespace(code) {\r\n        return [32, 9, 10, 13].indexOf(code) > -1;\r\n    }\r\n    function isAlphanumeric(code) {\r\n        return isLower(code) || isUpper(code) || isNumber(code);\r\n    }\r\n    function join(head, tail) {\r\n        if (tail.length === 0) {\r\n            tail = [head];\r\n        }\r\n        else if (head.end === tail[0].start) {\r\n            tail[0].start = head.start;\r\n        }\r\n        else {\r\n            tail.unshift(head);\r\n        }\r\n        return tail;\r\n    }\r\n    function nextAnchor(camelCaseWord, start) {\r\n        for (var i = start; i < camelCaseWord.length; i++) {\r\n            var c = camelCaseWord.charCodeAt(i);\r\n            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n                return i;\r\n            }\r\n        }\r\n        return camelCaseWord.length;\r\n    }\r\n    function _matchesCamelCase(word, camelCaseWord, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === camelCaseWord.length) {\r\n            return null;\r\n        }\r\n        else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n            return null;\r\n        }\r\n        else {\r\n            var result = null;\r\n            var nextUpperIndex = j + 1;\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n                nextUpperIndex++;\r\n            }\r\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n        }\r\n    }\r\n    // Heuristic to avoid computing camel case matcher for words that don't\r\n    // look like camelCaseWords.\r\n    function isCamelCaseWord(word) {\r\n        if (word.length > 60) {\r\n            return false;\r\n        }\r\n        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n        for (var i = 0; i < word.length; i++) {\r\n            code = word.charCodeAt(i);\r\n            if (isUpper(code)) {\r\n                upper++;\r\n            }\r\n            if (isLower(code)) {\r\n                lower++;\r\n            }\r\n            if (isAlphanumeric(code)) {\r\n                alpha++;\r\n            }\r\n            if (isNumber(code)) {\r\n                numeric++;\r\n            }\r\n        }\r\n        var upperPercent = upper / word.length;\r\n        var lowerPercent = lower / word.length;\r\n        var alphaPercent = alpha / word.length;\r\n        var numericPercent = numeric / word.length;\r\n        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n    }\r\n    // Heuristic to avoid computing camel case matcher for words that don't\r\n    // look like camel case patterns.\r\n    function isCamelCasePattern(word) {\r\n        var upper = 0, lower = 0, code = 0, whitespace = 0;\r\n        for (var i = 0; i < word.length; i++) {\r\n            code = word.charCodeAt(i);\r\n            if (isUpper(code)) {\r\n                upper++;\r\n            }\r\n            if (isLower(code)) {\r\n                lower++;\r\n            }\r\n            if (isWhitespace(code)) {\r\n                whitespace++;\r\n            }\r\n        }\r\n        if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n            return word.length <= 30;\r\n        }\r\n        else {\r\n            return upper <= 5;\r\n        }\r\n    }\r\n    function matchesCamelCase(word, camelCaseWord) {\r\n        if (!camelCaseWord || camelCaseWord.length === 0) {\r\n            return null;\r\n        }\r\n        if (!isCamelCasePattern(word)) {\r\n            return null;\r\n        }\r\n        if (!isCamelCaseWord(camelCaseWord)) {\r\n            return null;\r\n        }\r\n        var result = null;\r\n        var i = 0;\r\n        while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {\r\n            i = nextAnchor(camelCaseWord, i + 1);\r\n        }\r\n        return result;\r\n    }\r\n    exports.matchesCamelCase = matchesCamelCase;\r\n    // Matches beginning of words supporting non-ASCII languages\r\n    // E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\r\n    // Useful in cases where the target is words (e.g. command labels)\r\n    function matchesWords(word, target) {\r\n        if (!target || target.length === 0) {\r\n            return null;\r\n        }\r\n        var result = null;\r\n        var i = 0;\r\n        while (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i)) === null) {\r\n            i = nextWord(target, i + 1);\r\n        }\r\n        return result;\r\n    }\r\n    exports.matchesWords = matchesWords;\r\n    function _matchesWords(word, target, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === target.length) {\r\n            return null;\r\n        }\r\n        else if (word[i] !== target[j].toLowerCase()) {\r\n            return null;\r\n        }\r\n        else {\r\n            var result = null;\r\n            var nextWordIndex = j + 1;\r\n            result = _matchesWords(word, target, i + 1, j + 1);\r\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\r\n                result = _matchesWords(word, target, i + 1, nextWordIndex);\r\n                nextWordIndex++;\r\n            }\r\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n        }\r\n    }\r\n    function nextWord(word, start) {\r\n        for (var i = start; i < word.length; i++) {\r\n            var c = word.charCodeAt(i);\r\n            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {\r\n                return i;\r\n            }\r\n        }\r\n        return word.length;\r\n    }\r\n    // Fuzzy\r\n    (function (SubstringMatching) {\r\n        SubstringMatching[SubstringMatching[\"Contiguous\"] = 0] = \"Contiguous\";\r\n        SubstringMatching[SubstringMatching[\"Separate\"] = 1] = \"Separate\";\r\n    })(exports.SubstringMatching || (exports.SubstringMatching = {}));\r\n    var SubstringMatching = exports.SubstringMatching;\r\n    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\n    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);\r\n    var fuzzyRegExpCache = new map_1.LinkedMap(10000); // bounded to 10000 elements\r\n    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\r\n        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\r\n        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n            return null; // return early for invalid input\r\n        }\r\n        // Form RegExp for wildcard matches\r\n        var regexp = fuzzyRegExpCache.get(word);\r\n        if (!regexp) {\r\n            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n            fuzzyRegExpCache.set(word, regexp);\r\n        }\r\n        // RegExp Filter\r\n        var match = regexp.exec(wordToMatchAgainst);\r\n        if (match) {\r\n            return [{ start: match.index, end: match.index + match[0].length }];\r\n        }\r\n        // Default Filter\r\n        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n    }\r\n    exports.matchesFuzzy = matchesFuzzy;\r\n});\r\n\ndefine(\"vs/base/common/uri\", [\"require\", \"exports\", 'vs/base/common/platform'], function (require, exports, platform) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    function _encode(ch) {\r\n        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\r\n    }\r\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\r\n    function encodeURIComponent2(str) {\r\n        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\r\n    }\r\n    function encodeNoop(str) {\r\n        return str;\r\n    }\r\n    /**\r\n     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n     * This class is a simple parser which creates the basic component paths\r\n     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n     * and encoding.\r\n     *\r\n     *       foo://example.com:8042/over/there?name=ferret#nose\r\n     *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n     *        |           |            |            |        |\r\n     *     scheme     authority       path        query   fragment\r\n     *        |   _____________________|__\r\n     *       / \\ /                        \\\r\n     *       urn:example:animal:ferret:nose\r\n     *\r\n     *\r\n     */\r\n    var URI = (function () {\r\n        function URI() {\r\n            this._scheme = URI._empty;\r\n            this._authority = URI._empty;\r\n            this._path = URI._empty;\r\n            this._query = URI._empty;\r\n            this._fragment = URI._empty;\r\n            this._formatted = null;\r\n            this._fsPath = null;\r\n        }\r\n        Object.defineProperty(URI.prototype, \"scheme\", {\r\n            /**\r\n             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             * The part before the first colon.\r\n             */\r\n            get: function () {\r\n                return this._scheme;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"authority\", {\r\n            /**\r\n             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             * The part between the first double slashes and the next slash.\r\n             */\r\n            get: function () {\r\n                return this._authority;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"path\", {\r\n            /**\r\n             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._path;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"query\", {\r\n            /**\r\n             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._query;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"fragment\", {\r\n            /**\r\n             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._fragment;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"fsPath\", {\r\n            // ---- filesystem path -----------------------\r\n            /**\r\n             * Returns a string representing the corresponding file system path of this URI.\r\n             * Will handle UNC paths and normalize windows drive letters to lower-case. Also\r\n             * uses the platform specific path separator. Will *not* validate the path for\r\n             * invalid characters and semantics. Will *not* look at the scheme of this URI.\r\n             */\r\n            get: function () {\r\n                if (!this._fsPath) {\r\n                    var value;\r\n                    if (this._authority && this.scheme === 'file') {\r\n                        // unc path: file://shares/c$/far/boo\r\n                        value = \"//\" + this._authority + this._path;\r\n                    }\r\n                    else if (URI._driveLetterPath.test(this._path)) {\r\n                        // windows drive letter: file:///c:/far/boo\r\n                        value = this._path[1].toLowerCase() + this._path.substr(2);\r\n                    }\r\n                    else {\r\n                        // other path\r\n                        value = this._path;\r\n                    }\r\n                    if (platform.isWindows) {\r\n                        value = value.replace(/\\//g, '\\\\');\r\n                    }\r\n                    this._fsPath = value;\r\n                }\r\n                return this._fsPath;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        // ---- modify to new -------------------------\r\n        URI.prototype.with = function (change) {\r\n            var ret = new URI();\r\n            ret._scheme = change.scheme || this.scheme;\r\n            ret._authority = change.authority || this.authority;\r\n            ret._path = change.path || this.path;\r\n            ret._query = change.query || this.query;\r\n            ret._fragment = change.fragment || this.fragment;\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        // ---- parse & validate ------------------------\r\n        URI.parse = function (value) {\r\n            var ret = new URI();\r\n            var data = URI._parseComponents(value);\r\n            ret._scheme = data.scheme;\r\n            ret._authority = decodeURIComponent(data.authority);\r\n            ret._path = decodeURIComponent(data.path);\r\n            ret._query = decodeURIComponent(data.query);\r\n            ret._fragment = decodeURIComponent(data.fragment);\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        URI.file = function (path) {\r\n            var ret = new URI();\r\n            ret._scheme = 'file';\r\n            // normalize to fwd-slashes\r\n            path = path.replace(/\\\\/g, URI._slash);\r\n            // check for authority as used in UNC shares\r\n            // or use the path as given\r\n            if (path[0] === URI._slash && path[0] === path[1]) {\r\n                var idx = path.indexOf(URI._slash, 2);\r\n                if (idx === -1) {\r\n                    ret._authority = path.substring(2);\r\n                }\r\n                else {\r\n                    ret._authority = path.substring(2, idx);\r\n                    ret._path = path.substring(idx);\r\n                }\r\n            }\r\n            else {\r\n                ret._path = path;\r\n            }\r\n            // Ensure that path starts with a slash\r\n            // or that it is at least a slash\r\n            if (ret._path[0] !== URI._slash) {\r\n                ret._path = URI._slash + ret._path;\r\n            }\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        URI._parseComponents = function (value) {\r\n            var ret = {\r\n                scheme: URI._empty,\r\n                authority: URI._empty,\r\n                path: URI._empty,\r\n                query: URI._empty,\r\n                fragment: URI._empty,\r\n            };\r\n            var match = URI._regexp.exec(value);\r\n            if (match) {\r\n                ret.scheme = match[2] || ret.scheme;\r\n                ret.authority = match[4] || ret.authority;\r\n                ret.path = match[5] || ret.path;\r\n                ret.query = match[7] || ret.query;\r\n                ret.fragment = match[9] || ret.fragment;\r\n            }\r\n            return ret;\r\n        };\r\n        URI.create = function (scheme, authority, path, query, fragment) {\r\n            return new URI().with({ scheme: scheme, authority: authority, path: path, query: query, fragment: fragment });\r\n        };\r\n        URI._validate = function (ret) {\r\n            // validation\r\n            // path, http://tools.ietf.org/html/rfc3986#section-3.3\r\n            // If a URI contains an authority component, then the path component\r\n            // must either be empty or begin with a slash (\"/\") character.  If a URI\r\n            // does not contain an authority component, then the path cannot begin\r\n            // with two slash characters (\"//\").\r\n            if (ret.authority && ret.path && ret.path[0] !== '/') {\r\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n            }\r\n            if (!ret.authority && ret.path.indexOf('//') === 0) {\r\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n            }\r\n        };\r\n        // ---- printing/externalize ---------------------------\r\n        /**\r\n         *\r\n         * @param skipEncoding Do not encode the result, default is `false`\r\n         */\r\n        URI.prototype.toString = function (skipEncoding) {\r\n            if (skipEncoding === void 0) { skipEncoding = false; }\r\n            if (!skipEncoding) {\r\n                if (!this._formatted) {\r\n                    this._formatted = URI._asFormatted(this, false);\r\n                }\r\n                return this._formatted;\r\n            }\r\n            else {\r\n                // we don't cache that\r\n                return URI._asFormatted(this, true);\r\n            }\r\n        };\r\n        URI._asFormatted = function (uri, skipEncoding) {\r\n            var encoder = !skipEncoding\r\n                ? encodeURIComponent2\r\n                : encodeNoop;\r\n            var parts = [];\r\n            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\r\n            if (scheme) {\r\n                parts.push(scheme, ':');\r\n            }\r\n            if (authority || scheme === 'file') {\r\n                parts.push('//');\r\n            }\r\n            if (authority) {\r\n                authority = authority.toLowerCase();\r\n                var idx = authority.indexOf(':');\r\n                if (idx === -1) {\r\n                    parts.push(encoder(authority));\r\n                }\r\n                else {\r\n                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\r\n                }\r\n            }\r\n            if (path) {\r\n                // lower-case windown drive letters in /C:/fff\r\n                var m = URI._upperCaseDrive.exec(path);\r\n                if (m) {\r\n                    path = m[1] + m[2].toLowerCase() + path.substr(m[1].length + m[2].length);\r\n                }\r\n                // encode every segement but not slashes\r\n                // make sure that # and ? are always encoded\r\n                // when occurring in paths - otherwise the result\r\n                // cannot be parsed back again\r\n                var lastIdx = 0;\r\n                while (true) {\r\n                    var idx = path.indexOf(URI._slash, lastIdx);\r\n                    if (idx === -1) {\r\n                        parts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));\r\n                        break;\r\n                    }\r\n                    parts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);\r\n                    lastIdx = idx + 1;\r\n                }\r\n                ;\r\n            }\r\n            if (query) {\r\n                parts.push('?', encoder(query));\r\n            }\r\n            if (fragment) {\r\n                parts.push('#', encoder(fragment));\r\n            }\r\n            return parts.join(URI._empty);\r\n        };\r\n        URI.prototype.toJSON = function () {\r\n            return {\r\n                scheme: this.scheme,\r\n                authority: this.authority,\r\n                path: this.path,\r\n                fsPath: this.fsPath,\r\n                query: this.query,\r\n                fragment: this.fragment.replace(/URL_MARSHAL_REMOVE.*$/, ''),\r\n                external: this.toString().replace(/#?URL_MARSHAL_REMOVE.*$/, ''),\r\n                $mid: 1\r\n            };\r\n        };\r\n        URI.revive = function (data) {\r\n            var result = new URI();\r\n            result._scheme = data.scheme;\r\n            result._authority = data.authority;\r\n            result._path = data.path;\r\n            result._query = data.query;\r\n            result._fragment = data.fragment;\r\n            result._fsPath = data.fsPath;\r\n            result._formatted = data.external;\r\n            URI._validate(result);\r\n            return result;\r\n        };\r\n        URI._empty = '';\r\n        URI._slash = '/';\r\n        URI._regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n        URI._driveLetterPath = /^\\/[a-zA-z]:/;\r\n        URI._upperCaseDrive = /^(\\/)?([A-Z]:)/;\r\n        return URI;\r\n    }());\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = URI;\r\n});\r\n\ndefine(\"vs/editor/common/core/arrays\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var Arrays;\r\n    (function (Arrays) {\r\n        /**\r\n         * Given a sorted array of natural number segments, find the segment containing a natural number.\r\n         *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:\r\n         *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]\r\n         *    Searching for 0, 1, 2, 3 or 4 will return 0.\r\n         *    Searching for 5, 6, 7 or 8 will return 1.\r\n         *    Searching for 9, 10, 11, ... will return 2.\r\n         * @param arr A sorted array representing natural number segments\r\n         * @param desiredIndex The search\r\n         * @return The index of the containing segment in the array.\r\n         */\r\n        function findIndexInSegmentsArray(arr, desiredIndex) {\r\n            var low = 0;\r\n            var high = arr.length - 1;\r\n            if (high <= 0) {\r\n                return 0;\r\n            }\r\n            while (low < high) {\r\n                var mid = low + Math.ceil((high - low) / 2);\r\n                if (arr[mid].startIndex > desiredIndex) {\r\n                    high = mid - 1;\r\n                }\r\n                else {\r\n                    low = mid;\r\n                }\r\n            }\r\n            return low;\r\n        }\r\n        Arrays.findIndexInSegmentsArray = findIndexInSegmentsArray;\r\n    })(Arrays = exports.Arrays || (exports.Arrays = {}));\r\n});\r\n\ndefine(\"vs/editor/common/core/modeTransition\", [\"require\", \"exports\", 'vs/editor/common/core/arrays'], function (require, exports, arrays_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var ModeTransition = (function () {\r\n        function ModeTransition(startIndex, mode) {\r\n            this.startIndex = startIndex | 0;\r\n            this.mode = mode;\r\n        }\r\n        ModeTransition.findIndexInSegmentsArray = function (arr, desiredIndex) {\r\n            return arrays_1.Arrays.findIndexInSegmentsArray(arr, desiredIndex);\r\n        };\r\n        ModeTransition.create = function (modeTransitions) {\r\n            var result = [];\r\n            for (var i = 0, len = modeTransitions.length; i < len; i++) {\r\n                var modeTransition = modeTransitions[i];\r\n                result.push(new ModeTransition(modeTransition.startIndex, modeTransition.mode));\r\n            }\r\n            return result;\r\n        };\r\n        return ModeTransition;\r\n    }());\r\n    exports.ModeTransition = ModeTransition;\r\n});\r\n\ndefine(\"vs/editor/common/core/position\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    /**\r\n     * A position in the editor.\r\n     */\r\n    var Position = (function () {\r\n        function Position(lineNumber, column) {\r\n            this.lineNumber = lineNumber;\r\n            this.column = column;\r\n        }\r\n        /**\r\n         * Test if this position equals other position\r\n         */\r\n        Position.prototype.equals = function (other) {\r\n            return Position.equals(this, other);\r\n        };\r\n        Position.equals = function (a, b) {\r\n            if (!a && !b) {\r\n                return true;\r\n            }\r\n            return (!!a &&\r\n                !!b &&\r\n                a.lineNumber === b.lineNumber &&\r\n                a.column === b.column);\r\n        };\r\n        /**\r\n         * Test if this position is before other position. If the two positions are equal, the result will be false.\r\n         */\r\n        Position.prototype.isBefore = function (other) {\r\n            return Position.isBefore(this, other);\r\n        };\r\n        Position.isBefore = function (a, b) {\r\n            if (a.lineNumber < b.lineNumber) {\r\n                return true;\r\n            }\r\n            if (b.lineNumber < a.lineNumber) {\r\n                return false;\r\n            }\r\n            return a.column < b.column;\r\n        };\r\n        /**\r\n         * Test if this position is before other position. If the two positions are equal, the result will be true.\r\n         */\r\n        Position.prototype.isBeforeOrEqual = function (other) {\r\n            return Position.isBeforeOrEqual(this, other);\r\n        };\r\n        Position.isBeforeOrEqual = function (a, b) {\r\n            if (a.lineNumber < b.lineNumber) {\r\n                return true;\r\n            }\r\n            if (b.lineNumber < a.lineNumber) {\r\n                return false;\r\n            }\r\n            return a.column <= b.column;\r\n        };\r\n        /**\r\n         * Clone this position.\r\n         */\r\n        Position.prototype.clone = function () {\r\n            return new Position(this.lineNumber, this.column);\r\n        };\r\n        Position.prototype.toString = function () {\r\n            return '(' + this.lineNumber + ',' + this.column + ')';\r\n        };\r\n        // ---\r\n        Position.lift = function (pos) {\r\n            return new Position(pos.lineNumber, pos.column);\r\n        };\r\n        Position.isIPosition = function (obj) {\r\n            return (obj\r\n                && (typeof obj.lineNumber === 'number')\r\n                && (typeof obj.column === 'number'));\r\n        };\r\n        Position.asEmptyRange = function (position) {\r\n            return {\r\n                startLineNumber: position.lineNumber,\r\n                startColumn: position.column,\r\n                endLineNumber: position.lineNumber,\r\n                endColumn: position.column\r\n            };\r\n        };\r\n        Position.startPosition = function (range) {\r\n            return {\r\n                lineNumber: range.startLineNumber,\r\n                column: range.startColumn\r\n            };\r\n        };\r\n        Position.endPosition = function (range) {\r\n            return {\r\n                lineNumber: range.endLineNumber,\r\n                column: range.endColumn\r\n            };\r\n        };\r\n        return Position;\r\n    }());\r\n    exports.Position = Position;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\ndefine(\"vs/editor/common/core/range\", [\"require\", \"exports\", 'vs/editor/common/core/position'], function (require, exports, position_1) {\r\n    'use strict';\r\n    /**\r\n     * A range in the editor.\r\n     */\r\n    var Range = (function () {\r\n        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n                this.startLineNumber = endLineNumber;\r\n                this.startColumn = endColumn;\r\n                this.endLineNumber = startLineNumber;\r\n                this.endColumn = startColumn;\r\n            }\r\n            else {\r\n                this.startLineNumber = startLineNumber;\r\n                this.startColumn = startColumn;\r\n                this.endLineNumber = endLineNumber;\r\n                this.endColumn = endColumn;\r\n            }\r\n        }\r\n        /**\r\n         * Test if this range is empty.\r\n         */\r\n        Range.prototype.isEmpty = function () {\r\n            return Range.isEmpty(this);\r\n        };\r\n        /**\r\n         * Test if position is in this range. If the position is at the edges, will return true.\r\n         */\r\n        Range.prototype.containsPosition = function (position) {\r\n            return Range.containsPosition(this, position);\r\n        };\r\n        /**\r\n         * Test if range is in this range. If the range is equal to this range, will return true.\r\n         */\r\n        Range.prototype.containsRange = function (range) {\r\n            return Range.containsRange(this, range);\r\n        };\r\n        /**\r\n         * A reunion of the two ranges. The smallest position will be used as the start point, and the largest one as the end point.\r\n         */\r\n        Range.prototype.plusRange = function (range) {\r\n            return Range.plusRange(this, range);\r\n        };\r\n        /**\r\n         * A intersection of the two ranges.\r\n         */\r\n        Range.prototype.intersectRanges = function (range) {\r\n            return Range.intersectRanges(this, range);\r\n        };\r\n        /**\r\n         * Test if this range equals other.\r\n         */\r\n        Range.prototype.equalsRange = function (other) {\r\n            return Range.equalsRange(this, other);\r\n        };\r\n        /**\r\n         * Return the end position (which will be after or equal to the start position)\r\n         */\r\n        Range.prototype.getEndPosition = function () {\r\n            return new position_1.Position(this.endLineNumber, this.endColumn);\r\n        };\r\n        /**\r\n         * Return the start position (which will be before or equal to the end position)\r\n         */\r\n        Range.prototype.getStartPosition = function () {\r\n            return new position_1.Position(this.startLineNumber, this.startColumn);\r\n        };\r\n        /**\r\n         * Clone this range.\r\n         */\r\n        Range.prototype.cloneRange = function () {\r\n            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);\r\n        };\r\n        /**\r\n         * Transform to a user presentable string representation.\r\n         */\r\n        Range.prototype.toString = function () {\r\n            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n        };\r\n        /**\r\n         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n         */\r\n        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {\r\n            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n        };\r\n        /**\r\n         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n         */\r\n        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {\r\n            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n        };\r\n        Range.prototype.collapseToStart = function () {\r\n            return new Range(this.startLineNumber, this.startColumn, this.startLineNumber, this.startColumn);\r\n        };\r\n        // ---\r\n        Range.lift = function (range) {\r\n            if (!range) {\r\n                return null;\r\n            }\r\n            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n        };\r\n        Range.isIRange = function (obj) {\r\n            return (obj\r\n                && (typeof obj.startLineNumber === 'number')\r\n                && (typeof obj.startColumn === 'number')\r\n                && (typeof obj.endLineNumber === 'number')\r\n                && (typeof obj.endColumn === 'number'));\r\n        };\r\n        Range.isEmpty = function (range) {\r\n            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n        };\r\n        Range.containsPosition = function (range, position) {\r\n            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n                return false;\r\n            }\r\n            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n                return false;\r\n            }\r\n            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Range.containsRange = function (range, otherRange) {\r\n            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n                return false;\r\n            }\r\n            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n                return false;\r\n            }\r\n            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n                return false;\r\n            }\r\n            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Range.areIntersectingOrTouching = function (a, b) {\r\n            // Check if `a` is before `b`\r\n            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n                return false;\r\n            }\r\n            // Check if `b` is before `a`\r\n            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n                return false;\r\n            }\r\n            // These ranges must intersect\r\n            return true;\r\n        };\r\n        Range.intersectRanges = function (a, b) {\r\n            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;\r\n            if (resultStartLineNumber < otherStartLineNumber) {\r\n                resultStartLineNumber = otherStartLineNumber;\r\n                resultStartColumn = otherStartColumn;\r\n            }\r\n            else if (resultStartLineNumber === otherStartLineNumber) {\r\n                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n            }\r\n            if (resultEndLineNumber > otherEndLineNumber) {\r\n                resultEndLineNumber = otherEndLineNumber;\r\n                resultEndColumn = otherEndColumn;\r\n            }\r\n            else if (resultEndLineNumber === otherEndLineNumber) {\r\n                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n            }\r\n            // Check if selection is now empty\r\n            if (resultStartLineNumber > resultEndLineNumber) {\r\n                return null;\r\n            }\r\n            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n                return null;\r\n            }\r\n            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n        };\r\n        Range.plusRange = function (a, b) {\r\n            var startLineNumber, startColumn, endLineNumber, endColumn;\r\n            if (b.startLineNumber < a.startLineNumber) {\r\n                startLineNumber = b.startLineNumber;\r\n                startColumn = b.startColumn;\r\n            }\r\n            else if (b.startLineNumber === a.startLineNumber) {\r\n                startLineNumber = b.startLineNumber;\r\n                startColumn = Math.min(b.startColumn, a.startColumn);\r\n            }\r\n            else {\r\n                startLineNumber = a.startLineNumber;\r\n                startColumn = a.startColumn;\r\n            }\r\n            if (b.endLineNumber > a.endLineNumber) {\r\n                endLineNumber = b.endLineNumber;\r\n                endColumn = b.endColumn;\r\n            }\r\n            else if (b.endLineNumber === a.endLineNumber) {\r\n                endLineNumber = b.endLineNumber;\r\n                endColumn = Math.max(b.endColumn, a.endColumn);\r\n            }\r\n            else {\r\n                endLineNumber = a.endLineNumber;\r\n                endColumn = a.endColumn;\r\n            }\r\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n        };\r\n        Range.equalsRange = function (a, b) {\r\n            return (!!a &&\r\n                !!b &&\r\n                a.startLineNumber === b.startLineNumber &&\r\n                a.startColumn === b.startColumn &&\r\n                a.endLineNumber === b.endLineNumber &&\r\n                a.endColumn === b.endColumn);\r\n        };\r\n        /**\r\n         * A function that compares ranges, useful for sorting ranges\r\n         * It will first compare ranges on the startPosition and then on the endPosition\r\n         */\r\n        Range.compareRangesUsingStarts = function (a, b) {\r\n            var aStartLineNumber = a.startLineNumber | 0;\r\n            var bStartLineNumber = b.startLineNumber | 0;\r\n            var aStartColumn = a.startColumn | 0;\r\n            var bStartColumn = b.startColumn | 0;\r\n            var aEndLineNumber = a.endLineNumber | 0;\r\n            var bEndLineNumber = b.endLineNumber | 0;\r\n            var aEndColumn = a.endColumn | 0;\r\n            var bEndColumn = b.endColumn | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                if (aStartColumn === bStartColumn) {\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        };\r\n        /**\r\n         * A function that compares ranges, useful for sorting ranges\r\n         * It will first compare ranges on the endPosition and then on the startPosition\r\n         */\r\n        Range.compareRangesUsingEnds = function (a, b) {\r\n            if (a.endLineNumber === b.endLineNumber) {\r\n                if (a.endColumn === b.endColumn) {\r\n                    if (a.startLineNumber === b.startLineNumber) {\r\n                        return a.startColumn - b.startColumn;\r\n                    }\r\n                    return a.startLineNumber - b.startLineNumber;\r\n                }\r\n                return a.endColumn - b.endColumn;\r\n            }\r\n            return a.endLineNumber - b.endLineNumber;\r\n        };\r\n        Range.spansMultipleLines = function (range) {\r\n            return range.endLineNumber > range.startLineNumber;\r\n        };\r\n        Range.collapseToStart = function (range) {\r\n            return {\r\n                startLineNumber: range.startLineNumber,\r\n                startColumn: range.startColumn,\r\n                endLineNumber: range.startLineNumber,\r\n                endColumn: range.startColumn\r\n            };\r\n        };\r\n        return Range;\r\n    }());\r\n    exports.Range = Range;\r\n});\r\n\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/editor/common/diff/diffComputer\", [\"require\", \"exports\", 'vs/base/common/diff/diff', 'vs/base/common/strings'], function (require, exports, diff_1, strings) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var MAXIMUM_RUN_TIME = 5000; // 5 seconds\r\n    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\n    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate) {\r\n        var diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n        return diffAlgo.ComputeDiff();\r\n    }\r\n    var MarkerSequence = (function () {\r\n        function MarkerSequence(buffer, startMarkers, endMarkers) {\r\n            this.buffer = buffer;\r\n            this.startMarkers = startMarkers;\r\n            this.endMarkers = endMarkers;\r\n        }\r\n        MarkerSequence.prototype.equals = function (other) {\r\n            if (!(other instanceof MarkerSequence)) {\r\n                return false;\r\n            }\r\n            var otherMarkerSequence = other;\r\n            if (this.getLength() !== otherMarkerSequence.getLength()) {\r\n                return false;\r\n            }\r\n            for (var i = 0, len = this.getLength(); i < len; i++) {\r\n                var myElement = this.getElementHash(i);\r\n                var otherElement = otherMarkerSequence.getElementHash(i);\r\n                if (myElement !== otherElement) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        MarkerSequence.prototype.getLength = function () {\r\n            return this.startMarkers.length;\r\n        };\r\n        MarkerSequence.prototype.getElementHash = function (i) {\r\n            return this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);\r\n        };\r\n        MarkerSequence.prototype.getStartLineNumber = function (i) {\r\n            if (i === this.startMarkers.length) {\r\n                // This is the special case where a change happened after the last marker\r\n                return this.startMarkers[i - 1].lineNumber + 1;\r\n            }\r\n            return this.startMarkers[i].lineNumber;\r\n        };\r\n        MarkerSequence.prototype.getStartColumn = function (i) {\r\n            return this.startMarkers[i].column;\r\n        };\r\n        MarkerSequence.prototype.getEndLineNumber = function (i) {\r\n            return this.endMarkers[i].lineNumber;\r\n        };\r\n        MarkerSequence.prototype.getEndColumn = function (i) {\r\n            return this.endMarkers[i].column;\r\n        };\r\n        return MarkerSequence;\r\n    }());\r\n    var LineMarkerSequence = (function (_super) {\r\n        __extends(LineMarkerSequence, _super);\r\n        function LineMarkerSequence(lines, shouldIgnoreTrimWhitespace) {\r\n            var i, length, pos;\r\n            var buffer = '';\r\n            var startMarkers = [], endMarkers = [], startColumn, endColumn;\r\n            for (pos = 0, i = 0, length = lines.length; i < length; i++) {\r\n                buffer += lines[i];\r\n                startColumn = 1;\r\n                endColumn = lines[i].length + 1;\r\n                if (shouldIgnoreTrimWhitespace) {\r\n                    startColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);\r\n                    endColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);\r\n                }\r\n                startMarkers.push({\r\n                    offset: pos + startColumn - 1,\r\n                    lineNumber: i + 1,\r\n                    column: startColumn\r\n                });\r\n                endMarkers.push({\r\n                    offset: pos + endColumn - 1,\r\n                    lineNumber: i + 1,\r\n                    column: endColumn\r\n                });\r\n                pos += lines[i].length;\r\n            }\r\n            _super.call(this, buffer, startMarkers, endMarkers);\r\n        }\r\n        LineMarkerSequence._getFirstNonBlankColumn = function (txt, defaultValue) {\r\n            var r = strings.firstNonWhitespaceIndex(txt);\r\n            if (r === -1) {\r\n                return defaultValue;\r\n            }\r\n            return r + 1;\r\n        };\r\n        LineMarkerSequence._getLastNonBlankColumn = function (txt, defaultValue) {\r\n            var r = strings.lastNonWhitespaceIndex(txt);\r\n            if (r === -1) {\r\n                return defaultValue;\r\n            }\r\n            return r + 2;\r\n        };\r\n        LineMarkerSequence.prototype.getCharSequence = function (startIndex, endIndex) {\r\n            var startMarkers = [], endMarkers = [], index, i, startMarker, endMarker;\r\n            for (index = startIndex; index <= endIndex; index++) {\r\n                startMarker = this.startMarkers[index];\r\n                endMarker = this.endMarkers[index];\r\n                for (i = startMarker.offset; i < endMarker.offset; i++) {\r\n                    startMarkers.push({\r\n                        offset: i,\r\n                        lineNumber: startMarker.lineNumber,\r\n                        column: startMarker.column + (i - startMarker.offset)\r\n                    });\r\n                    endMarkers.push({\r\n                        offset: i + 1,\r\n                        lineNumber: startMarker.lineNumber,\r\n                        column: startMarker.column + (i - startMarker.offset) + 1\r\n                    });\r\n                }\r\n            }\r\n            return new MarkerSequence(this.buffer, startMarkers, endMarkers);\r\n        };\r\n        return LineMarkerSequence;\r\n    }(MarkerSequence));\r\n    var CharChange = (function () {\r\n        function CharChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n            if (diffChange.originalLength === 0) {\r\n                this.originalStartLineNumber = 0;\r\n                this.originalStartColumn = 0;\r\n                this.originalEndLineNumber = 0;\r\n                this.originalEndColumn = 0;\r\n            }\r\n            else {\r\n                this.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n                this.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n                this.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n                this.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n            }\r\n            if (diffChange.modifiedLength === 0) {\r\n                this.modifiedStartLineNumber = 0;\r\n                this.modifiedStartColumn = 0;\r\n                this.modifiedEndLineNumber = 0;\r\n                this.modifiedEndColumn = 0;\r\n            }\r\n            else {\r\n                this.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n                this.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n                this.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n                this.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            }\r\n        }\r\n        return CharChange;\r\n    }());\r\n    function postProcessCharChanges(rawChanges) {\r\n        if (rawChanges.length <= 1) {\r\n            return rawChanges;\r\n        }\r\n        var result = [rawChanges[0]];\r\n        var i, len, originalMatchingLength, modifiedMatchingLength, matchingLength, prevChange = result[0], currChange;\r\n        for (i = 1, len = rawChanges.length; i < len; i++) {\r\n            currChange = rawChanges[i];\r\n            originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n            modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n            // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n            matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n            if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n                // Merge the current change into the previous one\r\n                prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n                prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n            }\r\n            else {\r\n                // Add the current change\r\n                result.push(currChange);\r\n                prevChange = currChange;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    var LineChange = (function () {\r\n        function LineChange(diffChange, originalLineSequence, modifiedLineSequence, continueProcessingPredicate, shouldPostProcessCharChanges) {\r\n            if (diffChange.originalLength === 0) {\r\n                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n                this.originalEndLineNumber = 0;\r\n            }\r\n            else {\r\n                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n                this.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n            }\r\n            if (diffChange.modifiedLength === 0) {\r\n                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n                this.modifiedEndLineNumber = 0;\r\n            }\r\n            else {\r\n                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n                this.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            }\r\n            if (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {\r\n                var originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n                var modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n                var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);\r\n                if (shouldPostProcessCharChanges) {\r\n                    rawChanges = postProcessCharChanges(rawChanges);\r\n                }\r\n                this.charChanges = [];\r\n                for (var i = 0, length = rawChanges.length; i < length; i++) {\r\n                    this.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n                }\r\n            }\r\n        }\r\n        return LineChange;\r\n    }());\r\n    var DiffComputer = (function () {\r\n        function DiffComputer(originalLines, modifiedLines, opts) {\r\n            this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n            this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n            this.maximumRunTimeMs = MAXIMUM_RUN_TIME;\r\n            this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\r\n            this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\r\n            if (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {\r\n                // Diff would be empty with `shouldIgnoreTrimWhitespace`\r\n                this.shouldIgnoreTrimWhitespace = false;\r\n                this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\r\n                this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\r\n            }\r\n        }\r\n        DiffComputer.prototype.computeDiff = function () {\r\n            this.computationStartTime = (new Date()).getTime();\r\n            var rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));\r\n            var lineChanges = [];\r\n            for (var i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\r\n            }\r\n            return lineChanges;\r\n        };\r\n        DiffComputer.prototype._continueProcessingPredicate = function () {\r\n            if (this.maximumRunTimeMs === 0) {\r\n                return true;\r\n            }\r\n            var now = (new Date()).getTime();\r\n            return now - this.computationStartTime < this.maximumRunTimeMs;\r\n        };\r\n        return DiffComputer;\r\n    }());\r\n    exports.DiffComputer = DiffComputer;\r\n});\r\n\ndefine(\"vs/editor/common/modes/linkComputer\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // State machine for http:// or https://\r\n    var STATE_MAP = [], START_STATE = 1, END_STATE = 9, ACCEPT_STATE = 10;\r\n    STATE_MAP[1] = { 'h': 2, 'H': 2, 'f': 11, 'F': 11 };\r\n    STATE_MAP[2] = { 't': 3, 'T': 3 };\r\n    STATE_MAP[3] = { 't': 4, 'T': 4 };\r\n    STATE_MAP[4] = { 'p': 5, 'P': 5 };\r\n    STATE_MAP[5] = { 's': 6, 'S': 6, ':': 7 };\r\n    STATE_MAP[6] = { ':': 7 };\r\n    STATE_MAP[7] = { '/': 8 };\r\n    STATE_MAP[8] = { '/': 9 };\r\n    STATE_MAP[11] = { 'i': 12, 'I': 12 };\r\n    STATE_MAP[12] = { 'l': 13, 'L': 13 };\r\n    STATE_MAP[13] = { 'e': 6, 'E': 6 };\r\n    var CharacterClass;\r\n    (function (CharacterClass) {\r\n        CharacterClass[CharacterClass[\"None\"] = 0] = \"None\";\r\n        CharacterClass[CharacterClass[\"ForceTermination\"] = 1] = \"ForceTermination\";\r\n        CharacterClass[CharacterClass[\"CannotEndIn\"] = 2] = \"CannotEndIn\";\r\n    })(CharacterClass || (CharacterClass = {}));\r\n    var _openParens = '('.charCodeAt(0);\r\n    var _closeParens = ')'.charCodeAt(0);\r\n    var _openSquareBracket = '['.charCodeAt(0);\r\n    var _closeSquareBracket = ']'.charCodeAt(0);\r\n    var _openCurlyBracket = '{'.charCodeAt(0);\r\n    var _closeCurlyBracket = '}'.charCodeAt(0);\r\n    var CharacterClassifier = (function () {\r\n        function CharacterClassifier() {\r\n            var FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；？！＠＃＄％＆＊‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';\r\n            var CANNOT_END_WITH_CHARACTERS = '.,;';\r\n            this._asciiMap = [];\r\n            for (var i = 0; i < 256; i++) {\r\n                this._asciiMap[i] = CharacterClass.None;\r\n            }\r\n            this._map = [];\r\n            for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\r\n                this._set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\r\n            }\r\n            for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\r\n                this._set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\r\n            }\r\n        }\r\n        CharacterClassifier.prototype._set = function (charCode, charClass) {\r\n            if (charCode < 256) {\r\n                this._asciiMap[charCode] = charClass;\r\n            }\r\n            this._map[charCode] = charClass;\r\n        };\r\n        CharacterClassifier.prototype.classify = function (charCode) {\r\n            if (charCode < 256) {\r\n                return this._asciiMap[charCode];\r\n            }\r\n            var charClass = this._map[charCode];\r\n            if (charClass) {\r\n                return charClass;\r\n            }\r\n            return CharacterClass.None;\r\n        };\r\n        return CharacterClassifier;\r\n    }());\r\n    var LinkComputer = (function () {\r\n        function LinkComputer() {\r\n        }\r\n        LinkComputer._createLink = function (line, lineNumber, linkBeginIndex, linkEndIndex) {\r\n            return {\r\n                range: {\r\n                    startLineNumber: lineNumber,\r\n                    startColumn: linkBeginIndex + 1,\r\n                    endLineNumber: lineNumber,\r\n                    endColumn: linkEndIndex + 1\r\n                },\r\n                url: line.substring(linkBeginIndex, linkEndIndex)\r\n            };\r\n        };\r\n        LinkComputer.computeLinks = function (model) {\r\n            var i, lineCount, result = [];\r\n            var line, j, lastIncludedCharIndex, len, linkBeginIndex, state, ch, chCode, chClass, resetStateMachine, hasOpenParens, hasOpenSquareBracket, hasOpenCurlyBracket, characterClassifier = LinkComputer._characterClassifier;\r\n            for (i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\r\n                line = model.getLineContent(i);\r\n                j = 0;\r\n                len = line.length;\r\n                linkBeginIndex = 0;\r\n                state = START_STATE;\r\n                hasOpenParens = false;\r\n                hasOpenSquareBracket = false;\r\n                hasOpenCurlyBracket = false;\r\n                while (j < len) {\r\n                    ch = line.charAt(j);\r\n                    chCode = line.charCodeAt(j);\r\n                    resetStateMachine = false;\r\n                    if (state === ACCEPT_STATE) {\r\n                        switch (chCode) {\r\n                            case _openParens:\r\n                                hasOpenParens = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeParens:\r\n                                chClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            case _openSquareBracket:\r\n                                hasOpenSquareBracket = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeSquareBracket:\r\n                                chClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            case _openCurlyBracket:\r\n                                hasOpenCurlyBracket = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeCurlyBracket:\r\n                                chClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            default:\r\n                                chClass = characterClassifier.classify(chCode);\r\n                        }\r\n                        // Check if character terminates link\r\n                        if (chClass === CharacterClass.ForceTermination) {\r\n                            // Do not allow to end link in certain characters...\r\n                            lastIncludedCharIndex = j - 1;\r\n                            do {\r\n                                chCode = line.charCodeAt(lastIncludedCharIndex);\r\n                                chClass = characterClassifier.classify(chCode);\r\n                                if (chClass !== CharacterClass.CannotEndIn) {\r\n                                    break;\r\n                                }\r\n                                lastIncludedCharIndex--;\r\n                            } while (lastIncludedCharIndex > linkBeginIndex);\r\n                            result.push(LinkComputer._createLink(line, i, linkBeginIndex, lastIncludedCharIndex + 1));\r\n                            resetStateMachine = true;\r\n                        }\r\n                    }\r\n                    else if (state === END_STATE) {\r\n                        chClass = characterClassifier.classify(chCode);\r\n                        // Check if character terminates link\r\n                        if (chClass === CharacterClass.ForceTermination) {\r\n                            resetStateMachine = true;\r\n                        }\r\n                        else {\r\n                            state = ACCEPT_STATE;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (STATE_MAP[state].hasOwnProperty(ch)) {\r\n                            state = STATE_MAP[state][ch];\r\n                        }\r\n                        else {\r\n                            resetStateMachine = true;\r\n                        }\r\n                    }\r\n                    if (resetStateMachine) {\r\n                        state = START_STATE;\r\n                        hasOpenParens = false;\r\n                        hasOpenSquareBracket = false;\r\n                        hasOpenCurlyBracket = false;\r\n                        // Record where the link started\r\n                        linkBeginIndex = j + 1;\r\n                    }\r\n                    j++;\r\n                }\r\n                if (state === ACCEPT_STATE) {\r\n                    result.push(LinkComputer._createLink(line, i, linkBeginIndex, len));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        LinkComputer._characterClassifier = new CharacterClassifier();\r\n        return LinkComputer;\r\n    }());\r\n    /**\r\n     * Returns an array of all links contains in the provided\r\n     * document. *Note* that this operation is computational\r\n     * expensive and should not run in the UI thread.\r\n     */\r\n    function computeLinks(model) {\r\n        if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\r\n            // Unknown caller!\r\n            return [];\r\n        }\r\n        return LinkComputer.computeLinks(model);\r\n    }\r\n    exports.computeLinks = computeLinks;\r\n});\r\n\ndefine(\"vs/editor/common/modes/supports/inplaceReplaceSupport\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var BasicInplaceReplace = (function () {\r\n        function BasicInplaceReplace() {\r\n            this._defaultValueSet = [\r\n                ['true', 'false'],\r\n                ['True', 'False'],\r\n                ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\r\n                ['public', 'protected', 'private'],\r\n            ];\r\n        }\r\n        BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {\r\n            if (range1 && text1) {\r\n                var result = this.doNavigateValueSet(text1, up);\r\n                if (result) {\r\n                    return {\r\n                        range: range1,\r\n                        value: result\r\n                    };\r\n                }\r\n            }\r\n            if (range2 && text2) {\r\n                var result = this.doNavigateValueSet(text2, up);\r\n                if (result) {\r\n                    return {\r\n                        range: range2,\r\n                        value: result\r\n                    };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {\r\n            var numberResult = this.numberReplace(text, up);\r\n            if (numberResult !== null) {\r\n                return numberResult;\r\n            }\r\n            return this.textReplace(text, up);\r\n        };\r\n        BasicInplaceReplace.prototype.numberReplace = function (value, up) {\r\n            var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)), n1 = Number(value), n2 = parseFloat(value);\r\n            if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\r\n                if (n1 === 0 && !up) {\r\n                    return null; // don't do negative\r\n                }\r\n                else {\r\n                    n1 = Math.floor(n1 * precision);\r\n                    n1 += up ? precision : -precision;\r\n                    return String(n1 / precision);\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.prototype.textReplace = function (value, up) {\r\n            return this.valueSetsReplace(this._defaultValueSet, value, up);\r\n        };\r\n        BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {\r\n            var result = null;\r\n            for (var i = 0, len = valueSets.length; result === null && i < len; i++) {\r\n                result = this.valueSetReplace(valueSets[i], value, up);\r\n            }\r\n            return result;\r\n        };\r\n        BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {\r\n            var idx = valueSet.indexOf(value);\r\n            if (idx >= 0) {\r\n                idx += up ? +1 : -1;\r\n                if (idx < 0) {\r\n                    idx = valueSet.length - 1;\r\n                }\r\n                else {\r\n                    idx %= valueSet.length;\r\n                }\r\n                return valueSet[idx];\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\r\n        return BasicInplaceReplace;\r\n    }());\r\n    exports.BasicInplaceReplace = BasicInplaceReplace;\r\n});\r\n\ndefine(\"vs/editor/common/services/editorSimpleWorkerCommon\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var EditorSimpleWorker = (function () {\r\n        function EditorSimpleWorker() {\r\n        }\r\n        EditorSimpleWorker.prototype.acceptNewModel = function (data) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.acceptModelChanged = function (modelUrl, events) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.acceptRemovedModel = function (modelUrl) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeLinks = function (modelUrl) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        return EditorSimpleWorker;\r\n    }());\r\n    exports.EditorSimpleWorker = EditorSimpleWorker;\r\n});\r\n\ndefine(\"vs/editor/common/viewModel/prefixSumComputer\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var PrefixSumIndexOfResult = (function () {\r\n        function PrefixSumIndexOfResult(index, remainder) {\r\n            this.index = index;\r\n            this.remainder = remainder;\r\n        }\r\n        return PrefixSumIndexOfResult;\r\n    }());\r\n    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;\r\n    var PrefixSumComputer = (function () {\r\n        function PrefixSumComputer(values) {\r\n            this.values = values;\r\n            this.prefixSum = [];\r\n            for (var i = 0, len = this.values.length; i < len; i++) {\r\n                this.prefixSum[i] = 0;\r\n            }\r\n            this.prefixSumValidIndex = -1;\r\n        }\r\n        PrefixSumComputer.prototype.getCount = function () {\r\n            return this.values.length;\r\n        };\r\n        PrefixSumComputer.prototype.insertValue = function (insertIndex, value) {\r\n            insertIndex = Math.floor(insertIndex); //@perf\r\n            value = Math.floor(value); //@perf\r\n            this.values.splice(insertIndex, 0, value);\r\n            this.prefixSum.splice(insertIndex, 0, 0);\r\n            if (insertIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = insertIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.insertValues = function (insertIndex, values) {\r\n            insertIndex = Math.floor(insertIndex); //@perf\r\n            if (values.length === 0) {\r\n                return;\r\n            }\r\n            this.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));\r\n            this.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));\r\n            if (insertIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = insertIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer._zeroArray = function (count) {\r\n            count = Math.floor(count); //@perf\r\n            var r = [];\r\n            for (var i = 0; i < count; i++) {\r\n                r[i] = 0;\r\n            }\r\n            return r;\r\n        };\r\n        PrefixSumComputer.prototype.changeValue = function (index, value) {\r\n            index = Math.floor(index); //@perf\r\n            value = Math.floor(value); //@perf\r\n            if (this.values[index] === value) {\r\n                return;\r\n            }\r\n            this.values[index] = value;\r\n            if (index - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = index - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {\r\n            startIndex = Math.floor(startIndex); //@perf\r\n            cnt = Math.floor(cnt); //@perf\r\n            this.values.splice(startIndex, cnt);\r\n            this.prefixSum.splice(startIndex, cnt);\r\n            if (startIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = startIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.getTotalValue = function () {\r\n            if (this.values.length === 0) {\r\n                return 0;\r\n            }\r\n            return this.getAccumulatedValue(this.values.length - 1);\r\n        };\r\n        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {\r\n            index = Math.floor(index); //@perf\r\n            if (index < 0) {\r\n                return 0;\r\n            }\r\n            if (index <= this.prefixSumValidIndex) {\r\n                return this.prefixSum[index];\r\n            }\r\n            var startIndex = this.prefixSumValidIndex + 1;\r\n            if (startIndex === 0) {\r\n                this.prefixSum[0] = this.values[0];\r\n                startIndex++;\r\n            }\r\n            if (index >= this.values.length) {\r\n                index = this.values.length - 1;\r\n            }\r\n            for (var i = startIndex; i <= index; i++) {\r\n                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\r\n            }\r\n            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);\r\n            return this.prefixSum[index];\r\n        };\r\n        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {\r\n            accumulatedValue = Math.floor(accumulatedValue); //@perf\r\n            var low = 0;\r\n            var high = this.values.length - 1;\r\n            var mid;\r\n            var midStop;\r\n            var midStart;\r\n            while (low <= high) {\r\n                mid = low + ((high - low) / 2) | 0;\r\n                midStop = this.getAccumulatedValue(mid);\r\n                midStart = midStop - this.values[mid];\r\n                if (accumulatedValue < midStart) {\r\n                    high = mid - 1;\r\n                }\r\n                else if (accumulatedValue >= midStop) {\r\n                    low = mid + 1;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\r\n        };\r\n        return PrefixSumComputer;\r\n    }());\r\n    exports.PrefixSumComputer = PrefixSumComputer;\r\n});\r\n\ndefine(\"vs/editor/common/model/mirrorModel2\", [\"require\", \"exports\", 'vs/editor/common/viewModel/prefixSumComputer'], function (require, exports, prefixSumComputer_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var MirrorModel2 = (function () {\r\n        function MirrorModel2(uri, lines, eol, versionId) {\r\n            this._uri = uri;\r\n            this._lines = lines;\r\n            this._eol = eol;\r\n            this._versionId = versionId;\r\n        }\r\n        MirrorModel2.prototype.dispose = function () {\r\n            this._lines.length = 0;\r\n        };\r\n        Object.defineProperty(MirrorModel2.prototype, \"version\", {\r\n            get: function () {\r\n                return this._versionId;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        MirrorModel2.prototype.getText = function () {\r\n            return this._lines.join(this._eol);\r\n        };\r\n        MirrorModel2.prototype.onEvents = function (events) {\r\n            var newEOL = null;\r\n            for (var i = 0, len = events.length; i < len; i++) {\r\n                var e = events[i];\r\n                if (e.eol) {\r\n                    newEOL = e.eol;\r\n                }\r\n            }\r\n            if (newEOL && newEOL !== this._eol) {\r\n                this._eol = newEOL;\r\n                this._lineStarts = null;\r\n            }\r\n            // Update my lines\r\n            var lastVersionId = -1;\r\n            for (var i = 0, len = events.length; i < len; i++) {\r\n                var e = events[i];\r\n                this._acceptDeleteRange(e.range);\r\n                this._acceptInsertText({\r\n                    lineNumber: e.range.startLineNumber,\r\n                    column: e.range.startColumn\r\n                }, e.text);\r\n                lastVersionId = Math.max(lastVersionId, e.versionId);\r\n            }\r\n            if (lastVersionId !== -1) {\r\n                this._versionId = lastVersionId;\r\n            }\r\n        };\r\n        MirrorModel2.prototype._ensureLineStarts = function () {\r\n            if (!this._lineStarts) {\r\n                var lineStartValues = [];\r\n                var eolLength = this._eol.length;\r\n                for (var i = 0, len = this._lines.length; i < len; i++) {\r\n                    lineStartValues.push(this._lines[i].length + eolLength);\r\n                }\r\n                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);\r\n            }\r\n        };\r\n        /**\r\n         * All changes to a line's text go through this method\r\n         */\r\n        MirrorModel2.prototype._setLineText = function (lineIndex, newValue) {\r\n            this._lines[lineIndex] = newValue;\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\r\n            }\r\n        };\r\n        MirrorModel2.prototype._acceptDeleteRange = function (range) {\r\n            if (range.startLineNumber === range.endLineNumber) {\r\n                if (range.startColumn === range.endColumn) {\r\n                    // Nothing to delete\r\n                    return;\r\n                }\r\n                // Delete text on the affected line\r\n                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\r\n                return;\r\n            }\r\n            // Take remaining text on last line and append it to remaining text on first line\r\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\r\n            // Delete middle lines\r\n            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n            }\r\n        };\r\n        MirrorModel2.prototype._acceptInsertText = function (position, insertText) {\r\n            if (insertText.length === 0) {\r\n                // Nothing to insert\r\n                return;\r\n            }\r\n            var insertLines = insertText.split(/\\r\\n|\\r|\\n/);\r\n            if (insertLines.length === 1) {\r\n                // Inserting text on one line\r\n                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                    + insertLines[0]\r\n                    + this._lines[position.lineNumber - 1].substring(position.column - 1));\r\n                return;\r\n            }\r\n            // Append overflowing text from first line to the end of text to insert\r\n            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\r\n            // Delete overflowing text from first line and insert text on first line\r\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                + insertLines[0]);\r\n            // Insert new lines & store lengths\r\n            var newLengths = new Array(insertLines.length - 1);\r\n            for (var i = 1; i < insertLines.length; i++) {\r\n                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\r\n                newLengths[i - 1] = insertLines[i].length + this._eol.length;\r\n            }\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.insertValues(position.lineNumber, newLengths);\r\n            }\r\n        };\r\n        return MirrorModel2;\r\n    }());\r\n    exports.MirrorModel2 = MirrorModel2;\r\n});\r\n\ndefine(\"vs/nls!vs/editor/common/config/defaultConfig\",['vs/nls', 'vs/nls!vs/editor/common/services/editorSimpleWorker'], function(nls, data) { return nls.create(\"vs/editor/common/config/defaultConfig\", data); });\ndefine(\"vs/editor/common/config/defaultConfig\", [\"require\", \"exports\", 'vs/nls!vs/editor/common/config/defaultConfig', 'vs/base/common/platform'], function (require, exports, nls, platform) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n    exports.DEFAULT_INDENTATION = {\r\n        tabSize: 4,\r\n        insertSpaces: true,\r\n        detectIndentation: true\r\n    };\r\n    exports.DEFAULT_TRIM_AUTO_WHITESPACE = true;\r\n    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\r\n    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\r\n    var DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'Courier New\\', monospace, \\'Droid Sans Fallback\\'';\r\n    /**\r\n     * Determined from empirical observations.\r\n     */\r\n    exports.GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\r\n    var ConfigClass = (function () {\r\n        function ConfigClass() {\r\n            this.editor = {\r\n                experimentalScreenReader: true,\r\n                rulers: [],\r\n                wordSeparators: exports.USUAL_WORD_SEPARATORS,\r\n                selectionClipboard: true,\r\n                ariaLabel: nls.localize(0, null),\r\n                lineNumbers: true,\r\n                selectOnLineNumbers: true,\r\n                lineNumbersMinChars: 5,\r\n                glyphMargin: false,\r\n                lineDecorationsWidth: 10,\r\n                revealHorizontalRightPadding: 30,\r\n                roundedSelection: true,\r\n                theme: 'vs',\r\n                readOnly: false,\r\n                scrollbar: {\r\n                    verticalScrollbarSize: 14,\r\n                    horizontal: 'auto',\r\n                    useShadows: true,\r\n                    verticalHasArrows: false,\r\n                    horizontalHasArrows: false\r\n                },\r\n                overviewRulerLanes: 2,\r\n                cursorBlinking: 'blink',\r\n                cursorStyle: 'line',\r\n                fontLigatures: false,\r\n                disableTranslate3d: false,\r\n                hideCursorInOverviewRuler: false,\r\n                scrollBeyondLastLine: true,\r\n                automaticLayout: false,\r\n                wrappingColumn: 300,\r\n                wrappingIndent: 'same',\r\n                wordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',\r\n                wordWrapBreakAfterCharacters: ' \\t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ’”〉》」』】〕）］｝｣',\r\n                wordWrapBreakObtrusiveCharacters: '.',\r\n                tabFocusMode: false,\r\n                // Features\r\n                hover: true,\r\n                contextmenu: true,\r\n                mouseWheelScrollSensitivity: 1,\r\n                quickSuggestions: true,\r\n                quickSuggestionsDelay: 10,\r\n                iconsInSuggestions: true,\r\n                autoClosingBrackets: true,\r\n                formatOnType: false,\r\n                suggestOnTriggerCharacters: true,\r\n                acceptSuggestionOnEnter: true,\r\n                selectionHighlight: true,\r\n                outlineMarkers: false,\r\n                referenceInfos: true,\r\n                folding: true,\r\n                renderWhitespace: false,\r\n                indentGuides: false,\r\n                useTabStops: true,\r\n                fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\r\n                fontSize: (platform.isMacintosh ? 12 : 14),\r\n                lineHeight: 0\r\n            };\r\n        }\r\n        return ConfigClass;\r\n    }());\r\n    exports.DefaultConfig = new ConfigClass();\r\n});\r\n\ndefine(\"vs/editor/common/modes/nullMode\", [\"require\", \"exports\", 'vs/editor/common/config/defaultConfig'], function (require, exports, defaultConfig_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var NullState = (function () {\r\n        function NullState(mode, stateData) {\r\n            this.mode = mode;\r\n            this.stateData = stateData;\r\n        }\r\n        NullState.prototype.clone = function () {\r\n            var stateDataClone = (this.stateData ? this.stateData.clone() : null);\r\n            return new NullState(this.mode, stateDataClone);\r\n        };\r\n        NullState.prototype.equals = function (other) {\r\n            if (this.mode !== other.getMode()) {\r\n                return false;\r\n            }\r\n            var otherStateData = other.getStateData();\r\n            if (!this.stateData && !otherStateData) {\r\n                return true;\r\n            }\r\n            if (this.stateData && otherStateData) {\r\n                return this.stateData.equals(otherStateData);\r\n            }\r\n            return false;\r\n        };\r\n        NullState.prototype.getMode = function () {\r\n            return this.mode;\r\n        };\r\n        NullState.prototype.tokenize = function (stream) {\r\n            stream.advanceToEOS();\r\n            return { type: '' };\r\n        };\r\n        NullState.prototype.getStateData = function () {\r\n            return this.stateData;\r\n        };\r\n        NullState.prototype.setStateData = function (stateData) {\r\n            this.stateData = stateData;\r\n        };\r\n        return NullState;\r\n    }());\r\n    exports.NullState = NullState;\r\n    var NullMode = (function () {\r\n        function NullMode() {\r\n            this.richEditSupport = {\r\n                wordDefinition: NullMode.DEFAULT_WORD_REGEXP\r\n            };\r\n        }\r\n        /**\r\n         * Create a word definition regular expression based on default word separators.\r\n         * Optionally provide allowed separators that should be included in words.\r\n         *\r\n         * The default would look like this:\r\n         * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n         */\r\n        NullMode.createWordRegExp = function (allowInWords) {\r\n            if (allowInWords === void 0) { allowInWords = ''; }\r\n            var usualSeparators = defaultConfig_1.USUAL_WORD_SEPARATORS;\r\n            var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n            for (var i = 0; i < usualSeparators.length; i++) {\r\n                if (allowInWords.indexOf(usualSeparators[i]) >= 0) {\r\n                    continue;\r\n                }\r\n                source += '\\\\' + usualSeparators[i];\r\n            }\r\n            source += '\\\\s]+)';\r\n            return new RegExp(source, 'g');\r\n        };\r\n        NullMode.prototype.getId = function () {\r\n            return NullMode.ID;\r\n        };\r\n        NullMode.prototype.toSimplifiedMode = function () {\r\n            return this;\r\n        };\r\n        // catches numbers (including floating numbers) in the first group, and alphanum in the second\r\n        NullMode.DEFAULT_WORD_REGEXP = NullMode.createWordRegExp();\r\n        NullMode.ID = 'vs.editor.modes.nullMode';\r\n        return NullMode;\r\n    }());\r\n    exports.NullMode = NullMode;\r\n    function nullTokenize(mode, buffer, state, deltaOffset, stopAtOffset) {\r\n        if (deltaOffset === void 0) { deltaOffset = 0; }\r\n        var tokens = [\r\n            {\r\n                startIndex: deltaOffset,\r\n                type: ''\r\n            }\r\n        ];\r\n        var modeTransitions = [\r\n            {\r\n                startIndex: deltaOffset,\r\n                mode: mode\r\n            }\r\n        ];\r\n        return {\r\n            tokens: tokens,\r\n            actualStopOffset: deltaOffset + buffer.length,\r\n            endState: state,\r\n            modeTransitions: modeTransitions\r\n        };\r\n    }\r\n    exports.nullTokenize = nullTokenize;\r\n});\r\n\ndefine(\"vs/editor/common/model/textModelWithTokensHelpers\", [\"require\", \"exports\", 'vs/editor/common/modes/nullMode', 'vs/editor/common/core/modeTransition'], function (require, exports, nullMode_1, modeTransition_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var WordHelper = (function () {\r\n        function WordHelper() {\r\n        }\r\n        WordHelper._safeGetWordDefinition = function (mode) {\r\n            return (mode.richEditSupport ? mode.richEditSupport.wordDefinition : null);\r\n        };\r\n        WordHelper.ensureValidWordDefinition = function (wordDefinition) {\r\n            var result = nullMode_1.NullMode.DEFAULT_WORD_REGEXP;\r\n            if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n                if (!wordDefinition.global) {\r\n                    var flags = 'g';\r\n                    if (wordDefinition.ignoreCase) {\r\n                        flags += 'i';\r\n                    }\r\n                    if (wordDefinition.multiline) {\r\n                        flags += 'm';\r\n                    }\r\n                    result = new RegExp(wordDefinition.source, flags);\r\n                }\r\n                else {\r\n                    result = wordDefinition;\r\n                }\r\n            }\r\n            result.lastIndex = 0;\r\n            return result;\r\n        };\r\n        WordHelper.massageWordDefinitionOf = function (mode) {\r\n            return WordHelper.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));\r\n        };\r\n        WordHelper._getWordAtColumn = function (txt, column, modeIndex, modeTransitions) {\r\n            var modeStartIndex = modeTransitions[modeIndex].startIndex, modeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length), mode = modeTransitions[modeIndex].mode;\r\n            return WordHelper._getWordAtText(column, WordHelper.massageWordDefinitionOf(mode), txt.substring(modeStartIndex, modeEndIndex), modeStartIndex);\r\n        };\r\n        WordHelper.getWordAtPosition = function (textSource, position) {\r\n            if (!textSource._lineIsTokenized(position.lineNumber)) {\r\n                return WordHelper._getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);\r\n            }\r\n            var result = null;\r\n            var txt = textSource.getLineContent(position.lineNumber), modeTransitions = textSource._getLineModeTransitions(position.lineNumber), columnIndex = position.column - 1, modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, columnIndex);\r\n            result = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);\r\n            if (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {\r\n                // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too\r\n                result = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);\r\n            }\r\n            return result;\r\n        };\r\n        WordHelper._getWordAtText = function (column, wordDefinition, text, textOffset) {\r\n            // console.log('_getWordAtText: ', column, text, textOffset);\r\n            var words = text.match(wordDefinition), k, startWord, endWord, startColumn, endColumn, word;\r\n            if (words) {\r\n                for (k = 0; k < words.length; k++) {\r\n                    word = words[k].trim();\r\n                    if (word.length > 0) {\r\n                        startWord = text.indexOf(word, endWord);\r\n                        endWord = startWord + word.length;\r\n                        startColumn = textOffset + startWord + 1;\r\n                        endColumn = textOffset + endWord + 1;\r\n                        if (startColumn <= column && column <= endColumn) {\r\n                            return {\r\n                                word: word,\r\n                                startColumn: startColumn,\r\n                                endColumn: endColumn\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        return WordHelper;\r\n    }());\r\n    exports.WordHelper = WordHelper;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/editor/common/services/editorSimpleWorker\", [\"require\", \"exports\", 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/core/range', 'vs/base/common/filters', 'vs/editor/common/diff/diffComputer', 'vs/editor/common/model/mirrorModel2', 'vs/editor/common/model/textModelWithTokensHelpers', 'vs/editor/common/modes/linkComputer', 'vs/editor/common/modes/supports/inplaceReplaceSupport', 'vs/editor/common/services/editorSimpleWorkerCommon'], function (require, exports, uri_1, winjs_base_1, range_1, filters_1, diffComputer_1, mirrorModel2_1, textModelWithTokensHelpers_1, linkComputer_1, inplaceReplaceSupport_1, editorSimpleWorkerCommon_1) {\r\n    'use strict';\r\n    var MirrorModel = (function (_super) {\r\n        __extends(MirrorModel, _super);\r\n        function MirrorModel() {\r\n            _super.apply(this, arguments);\r\n        }\r\n        MirrorModel.prototype.getLinesContent = function () {\r\n            return this._lines.slice(0);\r\n        };\r\n        MirrorModel.prototype.getLineCount = function () {\r\n            return this._lines.length;\r\n        };\r\n        MirrorModel.prototype.getLineContent = function (lineNumber) {\r\n            return this._lines[lineNumber - 1];\r\n        };\r\n        MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {\r\n            var wordAtText = textModelWithTokensHelpers_1.WordHelper._getWordAtText(position.column, textModelWithTokensHelpers_1.WordHelper.ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\r\n            if (wordAtText) {\r\n                return new range_1.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\r\n            }\r\n            return null;\r\n        };\r\n        MirrorModel.prototype.getWordUntilPosition = function (position, wordDefinition) {\r\n            var wordAtPosition = this.getWordAtPosition(position, wordDefinition);\r\n            if (!wordAtPosition) {\r\n                return {\r\n                    word: '',\r\n                    startColumn: position.column,\r\n                    endColumn: position.column\r\n                };\r\n            }\r\n            return {\r\n                word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\r\n                startColumn: wordAtPosition.startColumn,\r\n                endColumn: position.column\r\n            };\r\n        };\r\n        MirrorModel.prototype._getAllWords = function (wordDefinition) {\r\n            var _this = this;\r\n            var result = [];\r\n            this._lines.forEach(function (line) {\r\n                _this._wordenize(line, wordDefinition).forEach(function (info) {\r\n                    result.push(line.substring(info.start, info.end));\r\n                });\r\n            });\r\n            return result;\r\n        };\r\n        MirrorModel.prototype.getAllUniqueWords = function (wordDefinition, skipWordOnce) {\r\n            var foundSkipWord = false;\r\n            var uniqueWords = {};\r\n            return this._getAllWords(wordDefinition).filter(function (word) {\r\n                if (skipWordOnce && !foundSkipWord && skipWordOnce === word) {\r\n                    foundSkipWord = true;\r\n                    return false;\r\n                }\r\n                else if (uniqueWords[word]) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    uniqueWords[word] = true;\r\n                    return true;\r\n                }\r\n            });\r\n        };\r\n        //\t// TODO@Joh, TODO@Alex - remove these and make sure the super-things work\r\n        MirrorModel.prototype._wordenize = function (content, wordDefinition) {\r\n            var result = [];\r\n            var match;\r\n            while (match = wordDefinition.exec(content)) {\r\n                if (match[0].length === 0) {\r\n                    // it did match the empty string\r\n                    break;\r\n                }\r\n                result.push({ start: match.index, end: match.index + match[0].length });\r\n            }\r\n            return result;\r\n        };\r\n        MirrorModel.prototype.getValueInRange = function (range) {\r\n            if (range.startLineNumber === range.endLineNumber) {\r\n                return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\r\n            }\r\n            var lineEnding = this._eol, startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];\r\n            resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\r\n            for (var i = startLineIndex + 1; i < endLineIndex; i++) {\r\n                resultLines.push(this._lines[i]);\r\n            }\r\n            resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\r\n            return resultLines.join(lineEnding);\r\n        };\r\n        return MirrorModel;\r\n    }(mirrorModel2_1.MirrorModel2));\r\n    var EditorSimpleWorkerImpl = (function (_super) {\r\n        __extends(EditorSimpleWorkerImpl, _super);\r\n        function EditorSimpleWorkerImpl() {\r\n            _super.call(this);\r\n            this._models = Object.create(null);\r\n        }\r\n        EditorSimpleWorkerImpl.prototype.acceptNewModel = function (data) {\r\n            this._models[data.url] = new MirrorModel(uri_1.default.parse(data.url), data.value.lines, data.value.EOL, data.versionId);\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.acceptModelChanged = function (strURL, events) {\r\n            if (!this._models[strURL]) {\r\n                return;\r\n            }\r\n            var model = this._models[strURL];\r\n            model.onEvents(events);\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.acceptRemovedModel = function (strURL) {\r\n            if (!this._models[strURL]) {\r\n                return;\r\n            }\r\n            delete this._models[strURL];\r\n        };\r\n        // ---- BEGIN diff --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            var original = this._models[originalUrl];\r\n            var modified = this._models[modifiedUrl];\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            var originalLines = original.getLinesContent();\r\n            var modifiedLines = modified.getLinesContent();\r\n            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\r\n                shouldPostProcessCharChanges: true,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldConsiderTrimWhitespaceInEmptyCase: true\r\n            });\r\n            return winjs_base_1.TPromise.as(diffComputer.computeDiff());\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            var original = this._models[originalUrl];\r\n            var modified = this._models[modifiedUrl];\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            var originalLines = original.getLinesContent();\r\n            var modifiedLines = modified.getLinesContent();\r\n            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\r\n                shouldPostProcessCharChanges: false,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldConsiderTrimWhitespaceInEmptyCase: false\r\n            });\r\n            return winjs_base_1.TPromise.as(diffComputer.computeDiff());\r\n        };\r\n        // ---- END diff --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.computeLinks = function (modelUrl) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return winjs_base_1.TPromise.as(linkComputer_1.computeLinks(model));\r\n        };\r\n        // ---- BEGIN suggest --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return winjs_base_1.TPromise.as(this._suggestFiltered(model, position, new RegExp(wordDef, wordDefFlags)));\r\n        };\r\n        EditorSimpleWorkerImpl.prototype._suggestFiltered = function (model, position, wordDefRegExp) {\r\n            var value = this._suggestUnfiltered(model, position, wordDefRegExp);\r\n            // filter suggestions\r\n            return [{\r\n                    currentWord: value.currentWord,\r\n                    suggestions: value.suggestions.filter(function (element) { return !!filters_1.fuzzyContiguousFilter(value.currentWord, element.label); }),\r\n                    incomplete: value.incomplete\r\n                }];\r\n        };\r\n        EditorSimpleWorkerImpl.prototype._suggestUnfiltered = function (model, position, wordDefRegExp) {\r\n            var currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;\r\n            var allWords = model.getAllUniqueWords(wordDefRegExp, currentWord);\r\n            var suggestions = allWords.filter(function (word) {\r\n                return !(/^-?\\d*\\.?\\d/.test(word)); // filter out numbers\r\n            }).map(function (word) {\r\n                return {\r\n                    type: 'text',\r\n                    label: word,\r\n                    codeSnippet: word,\r\n                    noAutoAccept: true\r\n                };\r\n            });\r\n            return {\r\n                currentWord: currentWord,\r\n                suggestions: suggestions\r\n            };\r\n        };\r\n        // ---- END suggest --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            var wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            if (range.startColumn === range.endColumn) {\r\n                range.endColumn += 1;\r\n            }\r\n            var selectionText = model.getValueInRange(range);\r\n            var wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\r\n            var word = null;\r\n            if (wordRange !== null) {\r\n                word = model.getValueInRange(wordRange);\r\n            }\r\n            var result = inplaceReplaceSupport_1.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\r\n            return winjs_base_1.TPromise.as(result);\r\n        };\r\n        return EditorSimpleWorkerImpl;\r\n    }(editorSimpleWorkerCommon_1.EditorSimpleWorker));\r\n    exports.EditorSimpleWorkerImpl = EditorSimpleWorkerImpl;\r\n    /**\r\n     * Called on the worker side\r\n     */\r\n    function create() {\r\n        return new EditorSimpleWorkerImpl();\r\n    }\r\n    exports.create = create;\r\n});\r\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport const DifferenceType = {\n\tAdd : 0,\n\tRemove : 1,\n\tChange : 2\n};\n\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\tpublic originalStart:number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\tpublic originalLength:number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tpublic modifiedStart:number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tpublic modifiedLength:number;\n\n\t/**\n\t * Constructs a new DiffChange with the given sequence information\n\t * and content.\n\t */\n\tconstructor(originalStart:number, originalLength:number, modifiedStart:number, modifiedLength:number) {\n\t\t//Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n\t\tthis.originalStart = originalStart;\n\t\tthis.originalLength = originalLength;\n\t\tthis.modifiedStart = modifiedStart;\n\t\tthis.modifiedLength = modifiedLength;\n\t}\n\n\t/**\n\t * The type of difference.\n\t */\n\tpublic getChangeType() {\n\t\tif (this.originalLength === 0) {\n\t\t\treturn DifferenceType.Add;\n\t\t} else if (this.modifiedLength === 0) {\n\t\t\treturn DifferenceType.Remove;\n\t\t} else {\n\t\t\treturn DifferenceType.Change;\n\t\t}\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the original sequence.\n\t */\n\tpublic getOriginalEnd() {\n\t\treturn this.originalStart + this.originalLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the modified sequence.\n\t */\n\tpublic getModifiedEnd() {\n\t\treturn this.modifiedStart + this.modifiedLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {DiffChange} from 'vs/base/common/diff/diffChange';\n\nexport interface ISequence {\n\tgetLength(): number;\n\tgetElementHash(index:number): string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart:number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength:number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart:number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength:number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex:number, originalSequence:ISequence, matchLengthOfLongest:number): boolean;\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nexport class Debug {\n\n\tpublic static Assert(condition:boolean, message:string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nexport class MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray:any[], sourceIndex:number, destinationArray:any[], destinationIndex:number, length:number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nlet MaxDifferencesHistory = 1447;\n//let MaxDifferencesHistory = 100;\n\n\n\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes:DiffChange[];\n\tprivate m_originalStart:number;\n\tprivate m_modifiedStart:number;\n\tprivate m_originalCount:number;\n\tprivate m_modifiedCount:number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex:number, modifiedIndex:number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex:number, modifiedIndex:number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\tpublic getReverseChanges(): DiffChange[] {\n\t\t/// <summary>\n\t\t/// Retrieves all of the changes marked by the class in the reverse order\n\t\t/// </summary>\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate OriginalSequence:ISequence;\n\tprivate ModifiedSequence:ISequence;\n\tprivate ContinueProcessingPredicate:IContinueProcessingPredicate;\n\n\tprivate m_originalIds:number[];\n\tprivate m_modifiedIds:number[];\n\tprivate m_forwardHistory:number[][];\n\tprivate m_reverseHistory:number[][];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence:ISequence, newSequence:ISequence, continueProcessingPredicate:IContinueProcessingPredicate = null) {\n\t\tthis.OriginalSequence = originalSequence;\n\t\tthis.ModifiedSequence = newSequence;\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\t\tthis.m_originalIds = [];\n\t\tthis.m_modifiedIds = [];\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\tthis.ComputeUniqueIdentifiers();\n\t}\n\n\tprivate ComputeUniqueIdentifiers(): void {\n\t\tlet originalSequenceLength = this.OriginalSequence.getLength();\n\t\tlet modifiedSequenceLength = this.ModifiedSequence.getLength();\n\t\tthis.m_originalIds = new Array<number>(originalSequenceLength);\n\t\tthis.m_modifiedIds = new Array<number>(modifiedSequenceLength);\n\n\t\t// Create a new hash table for unique elements from the original\n\t\t// sequence.\n\t\tlet hashTable:{[key:string]:number;} = {};\n\t\tlet currentUniqueId = 1;\n\t\tlet i: number;\n\n\t\t// Fill up the hash table for unique elements\n\t\tfor (i = 0; i < originalSequenceLength; i++) {\n\t\t\tlet originalElementHash = this.OriginalSequence.getElementHash(i);\n\t\t\tif (!hashTable.hasOwnProperty(originalElementHash)) {\n\t\t\t\t// No entry in the hashtable so this is a new unique element.\n\t\t\t\t// Assign the element a new unique identifier and add it to the\n\t\t\t\t// hash table\n\t\t\t\tthis.m_originalIds[i] = currentUniqueId++;\n\t\t\t\thashTable[originalElementHash] = this.m_originalIds[i];\n\t\t\t} else {\n\t\t\t\tthis.m_originalIds[i] = hashTable[originalElementHash];\n\t\t\t}\n\t\t}\n\n\t\t// Now match up modified elements\n\t\tfor (i = 0; i < modifiedSequenceLength; i++) {\n\t\t\tlet modifiedElementHash = this.ModifiedSequence.getElementHash(i);\n\t\t\tif (!hashTable.hasOwnProperty(modifiedElementHash)) {\n\t\t\t\tthis.m_modifiedIds[i] = currentUniqueId++;\n\t\t\t\thashTable[modifiedElementHash] = this.m_modifiedIds[i];\n\t\t\t} else {\n\t\t\t\tthis.m_modifiedIds[i] = hashTable[modifiedElementHash];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ElementsAreEqual(originalIndex:number, newIndex:number): boolean {\n\t\treturn this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];\n\t}\n\n\tpublic ComputeDiff(): IDiffChange[] {\n\t\treturn this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number): DiffChange[] {\n\t\tlet quitEarlyArr = [ false ];\n\t\treturn this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number, quitEarlyArr:boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes:DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tlet midOriginalArr = [0], midModifiedArr = [0];\n\t\tlet result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tlet midOriginal = midOriginalArr[0];\n\t\tlet midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tlet leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We did't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd -originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase:number, diagonalForwardStart:number, diagonalForwardEnd:number, diagonalForwardOffset:number,\n\t\t\t\t\tdiagonalReverseBase:number, diagonalReverseStart:number, diagonalReverseEnd:number, diagonalReverseOffset:number,\n\t\t\t\t\tforwardPoints:number[], reversePoints:number[],\n\t\t\t\t\toriginalIndex:number, originalEnd:number, midOriginalArr:number[],\n\t\t\t\t\tmodifiedIndex:number, modifiedEnd:number, midModifiedArr:number[],\n\t\t\t\t\tdeltaIsEven:boolean, quitEarlyArr:boolean[]): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] = null, reverseChanges: DiffChange[] = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Number.MIN_VALUE;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\t\tlet diagonal: number;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tdiagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tlet lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Number.MAX_VALUE;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tdiagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number, midOriginalArr:number[], midModifiedArr:number[], quitEarlyArr:boolean[]) {\n\t\tlet originalIndex:number, modifiedIndex:number;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\t\tlet numDifferences:number;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tlet maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tlet numDiagonals = maxDifferences + 1;\n\t\tlet forwardPoints:number[] = new Array<number>(numDiagonals);\n\t\tlet reversePoints:number[] = new Array<number>(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tlet diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tlet diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tlet diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tlet diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tlet delta = diagonalReverseBase - diagonalForwardBase;\n\t\tlet deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tlet diagonal:number, tempOriginalIndex:number;\n\t\tfor (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tlet matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quiting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp:number[] = new Array<number>(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Array<number>(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left:DiffChange[], right:DiffChange[]): DiffChange[] {\n\t\tlet mergedChangeArr:DiffChange[] = [];\n\t\tlet result:DiffChange[] = null;\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tresult = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left:DiffChange, right:DiffChange, mergedChangeArr:DiffChange[]): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart)\n\t\t{\n\t\t\tlet originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tlet modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\n\tprivate ClipDiagonalBound(diagonal:number, numDifferences:number, diagonalBaseIndex:number, numDiagonals:number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tlet diagonalsBelow = diagonalBaseIndex;\n\t\tlet diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tlet diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tlet lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tlet upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport strings = require('vs/base/common/strings');\nimport {LinkedMap} from 'vs/base/common/map';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[];\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tlet match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an and. The combines matches are\n * returned if *all* filters match.\n */\nexport function and(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] {\n\t\tlet result: IMatch[] = [];\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tlet match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresult = result.concat(match);\n\t\t}\n\t\treturn result;\n\t};\n}\n\n// Prefix\n\nexport let matchesStrictPrefix: IFilter = (word: string, wordToMatchAgainst: string): IMatch[] => { return _matchesPrefix(false, word, wordToMatchAgainst); };\nexport let matchesPrefix: IFilter = (word: string, wordToMatchAgainst: string): IMatch[] => { return _matchesPrefix(true, word, wordToMatchAgainst); };\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\tif (ignoreCase) {\n\t\tword = word.toLowerCase();\n\t\twordToMatchAgainst = wordToMatchAgainst.toLowerCase();\n\t}\n\tfor (let i = 0; i < word.length; i++) {\n\t\tif (word[i] !== wordToMatchAgainst[i]) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] {\n\tlet index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn 97 <= code && code <= 122;\n}\n\nfunction isUpper(code: number): boolean {\n\treturn 65 <= code && code <= 90;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn 48 <= code && code <= 57;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn [32, 9, 10, 13].indexOf(code) > -1;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tlet c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction isCamelCaseWord(word: string): boolean {\n\tif (word.length > 60) {\n\t\treturn false;\n\t}\n\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tlet upperPercent = upper / word.length;\n\tlet lowerPercent = lower / word.length;\n\tlet alphaPercent = alpha / word.length;\n\tlet numericPercent = numeric / word.length;\n\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] {\n\tif (!camelCaseWord || camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCaseWord(camelCaseWord)) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] = null;\n\tlet i = 0;\n\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string): IMatch[] {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] = null;\n\tlet i = 0;\n\n\twhile (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i)) === null) {\n\t\ti = nextWord(target, i + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === target.length) {\n\t\treturn null;\n\t} else if (word[i] !== target[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result = null;\n\t\tlet nextWordIndex = j + 1;\n\t\tresult = _matchesWords(word, target, i + 1, j + 1);\n\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\tresult = _matchesWords(word, target, i + 1, nextWordIndex);\n\t\t\tnextWordIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tlet c = word.charCodeAt(i);\n\t\tif (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nexport enum SubstringMatching {\n\tContiguous,\n\tSeparate\n}\n\nexport const fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LinkedMap<RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tlet match: RegExpExecArray = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport platform = require('vs/base/common/platform');\n\n\nfunction _encode(ch: string): string {\n\treturn '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n}\n\n// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\nfunction encodeURIComponent2(str: string): string {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n}\n\nfunction encodeNoop(str: string): string {\n\treturn str;\n}\n\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component paths\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n *\n *\n */\nexport default class URI {\n\n\tprivate static _empty = '';\n\tprivate static _slash = '/';\n\tprivate static _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\tprivate static _driveLetterPath = /^\\/[a-zA-z]:/;\n\tprivate static _upperCaseDrive = /^(\\/)?([A-Z]:)/;\n\n\tprivate _scheme: string;\n\tprivate _authority: string;\n\tprivate _path: string;\n\tprivate _query: string;\n\tprivate _fragment: string;\n\tprivate _formatted: string;\n\tprivate _fsPath: string;\n\n\tconstructor() {\n\t\tthis._scheme = URI._empty;\n\t\tthis._authority = URI._empty;\n\t\tthis._path = URI._empty;\n\t\tthis._query = URI._empty;\n\t\tthis._fragment = URI._empty;\n\n\t\tthis._formatted = null;\n\t\tthis._fsPath = null;\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\tget scheme() {\n\t\treturn this._scheme;\n\t}\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\tget authority() {\n\t\treturn this._authority;\n\t}\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget path() {\n\t\treturn this._path;\n\t}\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget query() {\n\t\treturn this._query;\n\t}\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget fragment() {\n\t\treturn this._fragment;\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n\t * uses the platform specific path separator. Will *not* validate the path for\n\t * invalid characters and semantics. Will *not* look at the scheme of this URI.\n\t */\n\tget fsPath() {\n\t\tif (!this._fsPath) {\n\t\t\tvar value: string;\n\t\t\tif (this._authority && this.scheme === 'file') {\n\t\t\t\t// unc path: file://shares/c$/far/boo\n\t\t\t\tvalue = `//${this._authority}${this._path}`;\n\t\t\t} else if (URI._driveLetterPath.test(this._path)) {\n\t\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\t\tvalue = this._path[1].toLowerCase() + this._path.substr(2);\n\t\t\t} else {\n\t\t\t\t// other path\n\t\t\t\tvalue = this._path;\n\t\t\t}\n\t\t\tif (platform.isWindows) {\n\t\t\t\tvalue = value.replace(/\\//g, '\\\\');\n\t\t\t}\n\t\t\tthis._fsPath = value;\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\t// ---- modify to new -------------------------\n\n\tpublic with(change: { scheme?: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tvar ret = new URI();\n\t\tret._scheme = change.scheme || this.scheme;\n\t\tret._authority = change.authority || this.authority;\n\t\tret._path = change.path || this.path;\n\t\tret._query = change.query || this.query;\n\t\tret._fragment = change.fragment || this.fragment;\n\t\tURI._validate(ret);\n\t\treturn ret;\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\tpublic static parse(value: string): URI {\n\t\tconst ret = new URI();\n\t\tconst data = URI._parseComponents(value);\n\t\tret._scheme = data.scheme;\n\t\tret._authority = decodeURIComponent(data.authority);\n\t\tret._path = decodeURIComponent(data.path);\n\t\tret._query = decodeURIComponent(data.query);\n\t\tret._fragment = decodeURIComponent(data.fragment);\n\t\tURI._validate(ret);\n\t\treturn ret;\n\t}\n\n\tpublic static file(path: string): URI {\n\n\t\tconst ret = new URI();\n\t\tret._scheme = 'file';\n\n\t\t// normalize to fwd-slashes\n\t\tpath = path.replace(/\\\\/g, URI._slash);\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === URI._slash && path[0] === path[1]) {\n\t\t\tlet idx = path.indexOf(URI._slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tret._authority = path.substring(2);\n\t\t\t} else {\n\t\t\t\tret._authority = path.substring(2, idx);\n\t\t\t\tret._path = path.substring(idx);\n\t\t\t}\n\t\t} else {\n\t\t\tret._path = path;\n\t\t}\n\n\t\t// Ensure that path starts with a slash\n\t\t// or that it is at least a slash\n\t\tif (ret._path[0] !== URI._slash) {\n\t\t\tret._path = URI._slash + ret._path;\n\t\t}\n\n\t\tURI._validate(ret);\n\n\t\treturn ret;\n\t}\n\n\tprivate static _parseComponents(value: string): UriComponents {\n\n\t\tconst ret: UriComponents = {\n\t\t\tscheme: URI._empty,\n\t\t\tauthority: URI._empty,\n\t\t\tpath: URI._empty,\n\t\t\tquery: URI._empty,\n\t\t\tfragment: URI._empty,\n\t\t};\n\n\t\tconst match = URI._regexp.exec(value);\n\t\tif (match) {\n\t\t\tret.scheme = match[2] || ret.scheme;\n\t\t\tret.authority = match[4] || ret.authority;\n\t\t\tret.path = match[5] || ret.path;\n\t\t\tret.query = match[7] || ret.query;\n\t\t\tret.fragment = match[9] || ret.fragment;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static create(scheme?: string, authority?: string, path?: string, query?: string, fragment?: string): URI {\n\t\treturn new URI().with({ scheme, authority, path, query, fragment });\n\t}\n\n\tprivate static _validate(ret: URI): void {\n\n\t\t// validation\n\t\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t\t// If a URI contains an authority component, then the path component\n\t\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t\t// does not contain an authority component, then the path cannot begin\n\t\t// with two slash characters (\"//\").\n\t\tif (ret.authority && ret.path && ret.path[0] !== '/') {\n\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t}\n\t\tif (!ret.authority && ret.path.indexOf('//') === 0) {\n\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t}\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = URI._asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn URI._asFormatted(this, true);\n\t\t}\n\t}\n\n\tprivate static _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\t\tconst encoder = !skipEncoding\n\t\t\t? encodeURIComponent2\n\t\t\t: encodeNoop;\n\n\t\tconst parts: string[] = [];\n\n\t\tlet {scheme, authority, path, query, fragment} = uri;\n\t\tif (scheme) {\n\t\t\tparts.push(scheme, ':');\n\t\t}\n\t\tif (authority || scheme === 'file') {\n\t\t\tparts.push('//');\n\t\t}\n\t\tif (authority) {\n\t\t\tauthority = authority.toLowerCase();\n\t\t\tlet idx = authority.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tparts.push(encoder(authority));\n\t\t\t} else {\n\t\t\t\tparts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n\t\t\t}\n\t\t}\n\t\tif (path) {\n\t\t\t// lower-case windown drive letters in /C:/fff\n\t\t\tconst m = URI._upperCaseDrive.exec(path);\n\t\t\tif (m) {\n\t\t\t\tpath = m[1] + m[2].toLowerCase() + path.substr(m[1].length + m[2].length);\n\t\t\t}\n\n\t\t\t// encode every segement but not slashes\n\t\t\t// make sure that # and ? are always encoded\n\t\t\t// when occurring in paths - otherwise the result\n\t\t\t// cannot be parsed back again\n\t\t\tlet lastIdx = 0;\n\t\t\twhile(true) {\n\t\t\t\tlet idx = path.indexOf(URI._slash, lastIdx);\n\t\t\t\tif (idx === -1) {\n\t\t\t\t\tparts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);\n\t\t\t\tlastIdx = idx + 1;\n\t\t\t};\n\t\t}\n\t\tif (query) {\n\t\t\tparts.push('?', encoder(query));\n\t\t}\n\t\tif (fragment) {\n\t\t\tparts.push('#', encoder(fragment));\n\t\t}\n\n\t\treturn parts.join(URI._empty);\n\t}\n\n\tpublic toJSON(): any {\n\t\treturn <UriState> {\n\t\t\tscheme: this.scheme,\n\t\t\tauthority: this.authority,\n\t\t\tpath: this.path,\n\t\t\tfsPath: this.fsPath,\n\t\t\tquery: this.query,\n\t\t\tfragment: this.fragment.replace(/URL_MARSHAL_REMOVE.*$/, ''), // TODO@Alex: implement derived resources (embedded mirror models) better\n\t\t\texternal: this.toString().replace(/#?URL_MARSHAL_REMOVE.*$/, ''), // TODO@Alex: implement derived resources (embedded mirror models) better\n\t\t\t$mid: 1\n\t\t};\n\t}\n\n\tstatic revive(data: any): URI {\n\t\tlet result = new URI();\n\t\tresult._scheme = (<UriState> data).scheme;\n\t\tresult._authority = (<UriState> data).authority;\n\t\tresult._path = (<UriState> data).path;\n\t\tresult._query = (<UriState> data).query;\n\t\tresult._fragment = (<UriState> data).fragment;\n\t\tresult._fsPath = (<UriState> data).fsPath;\n\t\tresult._formatted = (<UriState>data).external;\n\t\tURI._validate(result);\n\t\treturn result;\n\t}\n}\n\ninterface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\tfsPath: string;\n\texternal: string;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport namespace Arrays {\n\n\t/**\n\t * Given a sorted array of natural number segments, find the segment containing a natural number.\n\t *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:\n\t *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]\n\t *    Searching for 0, 1, 2, 3 or 4 will return 0.\n\t *    Searching for 5, 6, 7 or 8 will return 1.\n\t *    Searching for 9, 10, 11, ... will return 2.\n\t * @param arr A sorted array representing natural number segments\n\t * @param desiredIndex The search\n\t * @return The index of the containing segment in the array.\n\t */\n\texport function findIndexInSegmentsArray(arr: { startIndex: number; }[], desiredIndex: number): number {\n\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\tif (high <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (low < high) {\n\n\t\t\tlet mid = low + Math.ceil((high - low) / 2);\n\n\t\t\tif (arr[mid].startIndex > desiredIndex) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IMode, IModeTransition} from 'vs/editor/common/modes';\nimport {Arrays} from 'vs/editor/common/core/arrays';\n\nexport class ModeTransition {\n\t_modeTransitionBrand: void;\n\n\tpublic startIndex:number;\n\tpublic mode:IMode;\n\n\tconstructor(startIndex:number, mode:IMode) {\n\t\tthis.startIndex = startIndex|0;\n\t\tthis.mode = mode;\n\t}\n\n\tpublic static findIndexInSegmentsArray(arr:ModeTransition[], desiredIndex: number): number {\n\t\treturn Arrays.findIndexInSegmentsArray(arr, desiredIndex);\n\t}\n\n\tpublic static create(modeTransitions:IModeTransition[]): ModeTransition[] {\n\t\tlet result:ModeTransition[] = [];\n\t\tfor (let i = 0, len = modeTransitions.length; i < len; i++) {\n\t\t\tlet modeTransition = modeTransitions[i];\n\t\t\tresult.push(new ModeTransition(modeTransition.startIndex, modeTransition.mode));\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IPosition, IRange} from 'vs/editor/common/editorCommon';\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\n\tpublic lineNumber: number;\n\tpublic column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other:IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\tpublic static equals(a:IPosition, b:IPosition): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other:IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\tpublic static isBefore(a:IPosition, b:IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other:IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\tpublic static isBeforeOrEqual(a:IPosition, b:IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\tpublic static lift(pos:IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic static asEmptyRange(position:IPosition):IRange {\n\t\treturn {\n\t\t\tstartLineNumber: position.lineNumber,\n\t\t\tstartColumn: position.column,\n\t\t\tendLineNumber: position.lineNumber,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\tpublic static startPosition(range:IRange):IPosition {\n\t\treturn {\n\t\t\tlineNumber: range.startLineNumber,\n\t\t\tcolumn: range.startColumn\n\t\t};\n\t}\n\n\tpublic static endPosition(range:IRange):IPosition {\n\t\treturn {\n\t\t\tlineNumber: range.endLineNumber,\n\t\t\tcolumn: range.endColumn\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport {Position} from 'vs/editor/common/core/position';\nimport {IPosition, IRange} from 'vs/editor/common/editorCommon';\n\n/**\n * A range in the editor.\n */\nexport class Range {\n\n\tpublic startLineNumber:number;\n\tpublic startColumn:number;\n\tpublic endLineNumber:number;\n\tpublic endColumn:number;\n\n\tconstructor(startLineNumber:number, startColumn:number, endLineNumber:number, endColumn:number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position:IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range:IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges. The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range:IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range:IRange): Range {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other:IRange): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn new Position(this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn new Position(this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Clone this range.\n\t */\n\tpublic cloneRange(): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\tpublic collapseToStart():Range  {\n\t\treturn new Range(this.startLineNumber, this.startColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t// ---\n\n\tpublic static lift(range:IRange): Range {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\tpublic static isEmpty(range:IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\tpublic static containsPosition(range:IRange, position:IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static containsRange(range:IRange, otherRange:IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static areIntersectingOrTouching(a:IRange, b:IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\tpublic static intersectRanges(a:IRange, b:IRange): Range {\n\t\tvar resultStartLineNumber = a.startLineNumber,\n\t\t\tresultStartColumn = a.startColumn,\n\t\t\tresultEndLineNumber = a.endLineNumber,\n\t\t\tresultEndColumn = a.endColumn,\n\t\t\totherStartLineNumber = b.startLineNumber,\n\t\t\totherStartColumn = b.startColumn,\n\t\t\totherEndLineNumber = b.endLineNumber,\n\t\t\totherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\tpublic static plusRange(a:IRange, b:IRange): Range {\n\t\tvar startLineNumber:number, startColumn:number, endLineNumber:number, endColumn:number;\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tpublic static equalsRange(a:IRange, b:IRange): boolean {\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a:IRange, b:IRange): number {\n\t\tlet aStartLineNumber = a.startLineNumber|0;\n\t\tlet bStartLineNumber = b.startLineNumber|0;\n\t\tlet aStartColumn = a.startColumn|0;\n\t\tlet bStartColumn = b.startColumn|0;\n\t\tlet aEndLineNumber = a.endLineNumber|0;\n\t\tlet bEndLineNumber = b.endLineNumber|0;\n\t\tlet aEndColumn = a.endColumn|0;\n\t\tlet bEndColumn = b.endColumn|0;\n\n\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t}\n\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t}\n\t\t\treturn aStartColumn - bStartColumn;\n\t\t}\n\t\treturn aStartLineNumber - bStartLineNumber;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a:IRange, b:IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\tpublic static spansMultipleLines(range:IRange):boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic static collapseToStart(range:IRange):IRange  {\n\t\treturn {\n\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendLineNumber: range.startLineNumber,\n\t\t\tendColumn: range.startColumn\n\t\t};\n\t}\n\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IDiffChange, ISequence, LcsDiff} from 'vs/base/common/diff/diff';\nimport * as strings from 'vs/base/common/strings';\nimport {ICharChange, ILineChange} from 'vs/editor/common/editorCommon';\n\nvar MAXIMUM_RUN_TIME = 5000; // 5 seconds\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\ninterface IMarker {\n\tlineNumber: number;\n\tcolumn: number;\n\toffset: number;\n}\n\nfunction computeDiff(originalSequence:ISequence, modifiedSequence:ISequence, continueProcessingPredicate:()=>boolean): IDiffChange[] {\n\tvar diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff();\n}\n\nclass MarkerSequence implements ISequence {\n\n\tpublic buffer:string;\n\tpublic startMarkers:IMarker[];\n\tpublic endMarkers:IMarker[];\n\n\tconstructor(buffer:string, startMarkers:IMarker[], endMarkers:IMarker[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.startMarkers = startMarkers;\n\t\tthis.endMarkers = endMarkers;\n\t}\n\n\tpublic equals(other:any): boolean {\n\t\tif (!(other instanceof MarkerSequence)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherMarkerSequence = <MarkerSequence>other;\n\t\tif (this.getLength() !== otherMarkerSequence.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0, len = this.getLength(); i < len; i++) {\n\t\t\tvar myElement = this.getElementHash(i);\n\t\t\tvar otherElement = otherMarkerSequence.getElementHash(i);\n\t\t\tif (myElement !== otherElement) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this.startMarkers.length;\n\t}\n\n\tpublic getElementHash(i:number): string {\n\t\treturn this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);\n\t}\n\n\tpublic getStartLineNumber(i:number): number {\n\t\tif (i === this.startMarkers.length) {\n\t\t\t// This is the special case where a change happened after the last marker\n\t\t\treturn this.startMarkers[i - 1].lineNumber + 1;\n\t\t}\n\t\treturn this.startMarkers[i].lineNumber;\n\t}\n\n\tpublic getStartColumn(i:number): number {\n\t\treturn this.startMarkers[i].column;\n\t}\n\n\tpublic getEndLineNumber(i:number): number {\n\t\treturn this.endMarkers[i].lineNumber;\n\t}\n\n\tpublic getEndColumn(i:number): number {\n\t\treturn this.endMarkers[i].column;\n\t}\n\n}\n\nclass LineMarkerSequence extends MarkerSequence {\n\n\tconstructor(lines:string[], shouldIgnoreTrimWhitespace:boolean) {\n\t\tvar i:number, length:number, pos:number;\n\t\tvar buffer = '';\n\t\tvar startMarkers:IMarker[] = [], endMarkers:IMarker[] = [], startColumn:number, endColumn:number;\n\n\t\tfor (pos = 0, i = 0, length = lines.length; i < length; i++) {\n\t\t\tbuffer += lines[i];\n\t\t\tstartColumn = 1;\n\t\t\tendColumn = lines[i].length + 1;\n\n\t\t\tif (shouldIgnoreTrimWhitespace) {\n\t\t\t\tstartColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);\n\t\t\t\tendColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);\n\t\t\t}\n\n\t\t\tstartMarkers.push({\n\t\t\t\toffset: pos + startColumn - 1,\n\t\t\t\tlineNumber: i + 1,\n\t\t\t\tcolumn: startColumn\n\t\t\t});\n\n\t\t\tendMarkers.push({\n\t\t\t\toffset: pos + endColumn - 1,\n\t\t\t\tlineNumber: i+1,\n\t\t\t\tcolumn: endColumn\n\t\t\t});\n\n\t\t\tpos += lines[i].length;\n\t\t}\n\n\t\tsuper(buffer, startMarkers, endMarkers);\n\t}\n\n\tprivate static _getFirstNonBlankColumn(txt:string, defaultValue:number): number {\n\t\tvar r = strings.firstNonWhitespaceIndex(txt);\n\t\tif (r === -1) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn r + 1;\n\t}\n\n\tprivate static _getLastNonBlankColumn(txt:string, defaultValue:number): number {\n\t\tvar r = strings.lastNonWhitespaceIndex(txt);\n\t\tif (r === -1) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn r + 2;\n\t}\n\n\tpublic getCharSequence(startIndex:number, endIndex:number):MarkerSequence {\n\t\tvar startMarkers:IMarker[] = [], endMarkers:IMarker[] = [], index:number, i:number, startMarker:IMarker, endMarker:IMarker;\n\t\tfor (index = startIndex; index <= endIndex; index++) {\n\t\t\tstartMarker = this.startMarkers[index];\n\t\t\tendMarker = this.endMarkers[index];\n\t\t\tfor (i = startMarker.offset; i < endMarker.offset; i++) {\n\t\t\t\tstartMarkers.push({\n\t\t\t\t\toffset: i,\n\t\t\t\t\tlineNumber: startMarker.lineNumber,\n\t\t\t\t\tcolumn: startMarker.column + (i - startMarker.offset)\n\t\t\t\t});\n\t\t\t\tendMarkers.push({\n\t\t\t\t\toffset: i + 1,\n\t\t\t\t\tlineNumber: startMarker.lineNumber,\n\t\t\t\t\tcolumn: startMarker.column + (i - startMarker.offset) + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new MarkerSequence(this.buffer, startMarkers, endMarkers);\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber:number;\n\tpublic originalStartColumn:number;\n\tpublic originalEndLineNumber:number;\n\tpublic originalEndColumn:number;\n\n\tpublic modifiedStartLineNumber:number;\n\tpublic modifiedStartColumn:number;\n\tpublic modifiedEndLineNumber:number;\n\tpublic modifiedEndColumn:number;\n\n\tconstructor(diffChange:IDiffChange, originalCharSequence:MarkerSequence, modifiedCharSequence:MarkerSequence) {\n\t\tif (diffChange.originalLength === 0) {\n\t\t\tthis.originalStartLineNumber = 0;\n\t\t\tthis.originalStartColumn = 0;\n\t\t\tthis.originalEndLineNumber = 0;\n\t\t\tthis.originalEndColumn = 0;\n\t\t} else {\n\t\t\tthis.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\tthis.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\t\tthis.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tthis.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tthis.modifiedStartLineNumber = 0;\n\t\t\tthis.modifiedStartColumn = 0;\n\t\t\tthis.modifiedEndLineNumber = 0;\n\t\t\tthis.modifiedEndColumn = 0;\n\t\t} else {\n\t\t\tthis.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tthis.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\t\tthis.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t\tthis.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\t}\n\n}\n\nfunction postProcessCharChanges(rawChanges:IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\tvar result = [ rawChanges[0] ];\n\n\tvar i:number, len:number, originalMatchingLength:number, modifiedMatchingLength:number, matchingLength:number, prevChange = result[0], currChange:IDiffChange;\n\tfor (i = 1, len = rawChanges.length; i < len; i++) {\n\t\tcurrChange = rawChanges[i];\n\n\t\toriginalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tmodifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tmatchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber:number;\n\tpublic originalEndLineNumber:number;\n\tpublic modifiedStartLineNumber:number;\n\tpublic modifiedEndLineNumber:number;\n\tpublic charChanges:CharChange[];\n\n\tconstructor(diffChange:IDiffChange, originalLineSequence:LineMarkerSequence, modifiedLineSequence:LineMarkerSequence, continueProcessingPredicate:()=>boolean, shouldPostProcessCharChanges:boolean) {\n\t\tif (diffChange.originalLength === 0) {\n\t\t\tthis.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\tthis.originalEndLineNumber = 0;\n\t\t} else {\n\t\t\tthis.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\tthis.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tthis.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tthis.modifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tthis.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tthis.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {\n\t\t\tvar originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tvar modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tvar rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);\n\n\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t}\n\n\t\t\tthis.charChanges = [];\n\t\t\tfor (var i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tthis.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nexport interface IDiffComputerOpts {\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldConsiderTrimWhitespaceInEmptyCase: boolean;\n}\n\nexport class DiffComputer {\n\n\tprivate shouldPostProcessCharChanges:boolean;\n\tprivate shouldIgnoreTrimWhitespace:boolean;\n\tprivate maximumRunTimeMs:number;\n\tprivate original:LineMarkerSequence;\n\tprivate modified:LineMarkerSequence;\n\n\tprivate computationStartTime:number;\n\n\tconstructor(originalLines:string[], modifiedLines:string[], opts:IDiffComputerOpts) {\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.maximumRunTimeMs = MAXIMUM_RUN_TIME;\n\t\tthis.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\n\t\tthis.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\n\t\tif (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {\n\t\t\t// Diff would be empty with `shouldIgnoreTrimWhitespace`\n\t\t\tthis.shouldIgnoreTrimWhitespace = false;\n\t\t\tthis.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\n\t\t\tthis.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\n\t\t}\n\t}\n\n\tpublic computeDiff():ILineChange[] {\n\t\tthis.computationStartTime = (new Date()).getTime();\n\n\t\tvar rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));\n\n\t\tvar lineChanges: ILineChange[] = [];\n\t\tfor (var i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\tlineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\n\t\t}\n\t\treturn lineChanges;\n\t}\n\n\tprivate _continueProcessingPredicate(): boolean {\n\t\tif (this.maximumRunTimeMs === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tvar now = (new Date()).getTime();\n\t\treturn now - this.computationStartTime < this.maximumRunTimeMs;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {ILink} from 'vs/editor/common/modes';\n\nexport interface ILinkComputerTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber:number): string;\n}\n\n// State machine for http:// or https://\nvar STATE_MAP:{[ch:string]:number}[] = [], START_STATE = 1, END_STATE = 9, ACCEPT_STATE = 10;\nSTATE_MAP[1] = { 'h': 2, 'H': 2, 'f': 11, 'F': 11 };\nSTATE_MAP[2] = { 't': 3, 'T': 3 };\nSTATE_MAP[3] = { 't': 4, 'T': 4 };\nSTATE_MAP[4] = { 'p': 5, 'P': 5 };\nSTATE_MAP[5] = { 's': 6, 'S': 6, ':': 7 };\nSTATE_MAP[6] = { ':': 7 };\nSTATE_MAP[7] = { '/': 8 };\nSTATE_MAP[8] = { '/': 9 };\nSTATE_MAP[11] = { 'i': 12, 'I': 12 };\nSTATE_MAP[12] = { 'l': 13, 'L': 13 };\nSTATE_MAP[13] = { 'e': 6, 'E': 6 };\n\nenum CharacterClass {\n\tNone = 0,\n\tForceTermination = 1,\n\tCannotEndIn = 2\n}\n\nlet _openParens = '('.charCodeAt(0);\nlet _closeParens = ')'.charCodeAt(0);\nlet _openSquareBracket = '['.charCodeAt(0);\nlet _closeSquareBracket = ']'.charCodeAt(0);\nlet _openCurlyBracket = '{'.charCodeAt(0);\nlet _closeCurlyBracket = '}'.charCodeAt(0);\n\nclass CharacterClassifier {\n\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprivate _asciiMap: CharacterClass[];\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprivate _map: CharacterClass[];\n\n\tconstructor() {\n\t\tvar FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；？！＠＃＄％＆＊‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';\n\t\tvar CANNOT_END_WITH_CHARACTERS = '.,;';\n\n\t\tthis._asciiMap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tthis._asciiMap[i] = CharacterClass.None;\n\t\t}\n\n\t\tthis._map = [];\n\n\t\tfor (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n\t\t\tthis._set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\n\t\t}\n\n\t\tfor (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n\t\t\tthis._set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\n\t\t}\n\t}\n\n\tprivate _set(charCode:number, charClass:CharacterClass): void {\n\t\tif (charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = charClass;\n\t\t}\n\t\tthis._map[charCode] = charClass;\n\t}\n\n\tpublic classify(charCode:number): CharacterClass {\n\t\tif (charCode < 256) {\n\t\t\treturn this._asciiMap[charCode];\n\t\t}\n\n\t\tlet charClass = this._map[charCode];\n\t\tif (charClass) {\n\t\t\treturn charClass;\n\t\t}\n\n\t\treturn CharacterClass.None;\n\t}\n}\n\nclass LinkComputer {\n\n\tprivate static _characterClassifier = new CharacterClassifier();\n\n\tprivate static _createLink(line:string, lineNumber:number, linkBeginIndex:number, linkEndIndex:number):ILink {\n\t\treturn {\n\t\t\trange: {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn: linkBeginIndex + 1,\n\t\t\t\tendLineNumber: lineNumber,\n\t\t\t\tendColumn: linkEndIndex + 1\n\t\t\t},\n\t\t\turl: line.substring(linkBeginIndex, linkEndIndex)\n\t\t};\n\t}\n\n\tpublic static computeLinks(model:ILinkComputerTarget):ILink[] {\n\n\t\tvar i:number,\n\t\t\tlineCount:number,\n\t\t\tresult:ILink[] = [];\n\n\t\tvar line:string,\n\t\t\tj:number,\n\t\t\tlastIncludedCharIndex:number,\n\t\t\tlen:number,\n\t\t\tlinkBeginIndex:number,\n\t\t\tstate:number,\n\t\t\tch:string,\n\t\t\tchCode:number,\n\t\t\tchClass:CharacterClass,\n\t\t\tresetStateMachine:boolean,\n\t\t\thasOpenParens:boolean,\n\t\t\thasOpenSquareBracket:boolean,\n\t\t\thasOpenCurlyBracket:boolean,\n\t\t\tcharacterClassifier = LinkComputer._characterClassifier;\n\n\t\tfor (i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n\t\t\tline = model.getLineContent(i);\n\t\t\tj = 0;\n\t\t\tlen = line.length;\n\t\t\tlinkBeginIndex = 0;\n\t\t\tstate = START_STATE;\n\t\t\thasOpenParens = false;\n\t\t\thasOpenSquareBracket = false;\n\t\t\thasOpenCurlyBracket = false;\n\n\t\t\twhile (j < len) {\n\t\t\t\tch = line.charAt(j);\n\t\t\t\tchCode = line.charCodeAt(j);\n\t\t\t\tresetStateMachine = false;\n\n\t\t\t\tif (state === ACCEPT_STATE) {\n\n\t\t\t\t\tswitch (chCode) {\n\t\t\t\t\t\tcase _openParens:\n\t\t\t\t\t\t\thasOpenParens = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeParens:\n\t\t\t\t\t\t\tchClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _openSquareBracket:\n\t\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeSquareBracket:\n\t\t\t\t\t\t\tchClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _openCurlyBracket:\n\t\t\t\t\t\t\thasOpenCurlyBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeCurlyBracket:\n\t\t\t\t\t\t\tchClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\n\t\t\t\t\t\t// Do not allow to end link in certain characters...\n\t\t\t\t\t\tlastIncludedCharIndex = j - 1;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tchCode = line.charCodeAt(lastIncludedCharIndex);\n\t\t\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\t\t\t\t\t\t\tif (chClass !== CharacterClass.CannotEndIn) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastIncludedCharIndex--;\n\t\t\t\t\t\t} while (lastIncludedCharIndex > linkBeginIndex);\n\n\t\t\t\t\t\tresult.push(LinkComputer._createLink(line, i, linkBeginIndex, lastIncludedCharIndex + 1));\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (state === END_STATE) {\n\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = ACCEPT_STATE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (STATE_MAP[state].hasOwnProperty(ch)) {\n\t\t\t\t\t\tstate = STATE_MAP[state][ch];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resetStateMachine) {\n\t\t\t\t\tstate = START_STATE;\n\t\t\t\t\thasOpenParens = false;\n\t\t\t\t\thasOpenSquareBracket = false;\n\t\t\t\t\thasOpenCurlyBracket = false;\n\n\t\t\t\t\t// Record where the link started\n\t\t\t\t\tlinkBeginIndex = j + 1;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (state === ACCEPT_STATE) {\n\t\t\t\tresult.push(LinkComputer._createLink(line, i, linkBeginIndex, len));\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model:ILinkComputerTarget):ILink[] {\n\tif (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IRange} from 'vs/editor/common/editorCommon';\nimport {IInplaceReplaceSupportResult} from 'vs/editor/common/modes';\n\nexport class BasicInplaceReplace {\n\n\tpublic static INSTANCE = new BasicInplaceReplace();\n\n\tpublic navigateValueSet(range1:IRange, text1:string, range2:IRange, text2:string, up:boolean): IInplaceReplaceSupportResult {\n\n\t\tif (range1 && text1) {\n\t\t\tlet result = this.doNavigateValueSet(text1, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range1,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (range2 && text2) {\n\t\t\tlet result = this.doNavigateValueSet(text2, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range2,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate doNavigateValueSet(text:string, up:boolean): string {\n\t\tlet numberResult = this.numberReplace(text, up);\n\t\tif (numberResult !== null) {\n\t\t\treturn numberResult;\n\t\t}\n\t\treturn this.textReplace(text, up);\n\t}\n\n\tprivate numberReplace(value:string, up:boolean):string {\n\t\tvar precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)),\n\t\t\tn1 = Number(value),\n\t\t\tn2 = parseFloat(value);\n\n\t\tif(!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n\n\t\t\tif(n1 === 0 && !up) {\n\t\t\t\treturn null; // don't do negative\n//\t\t\t} else if(n1 === 9 && up) {\n//\t\t\t\treturn null; // don't insert 10 into a number\n\t\t\t} else {\n\t\t\t\tn1 = Math.floor(n1 * precision);\n\t\t\t\tn1 += up ? precision : -precision;\n\t\t\t\treturn String(n1 / precision);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _defaultValueSet: string[][] = [\n\t\t['true', 'false'],\n\t\t['True', 'False'],\n\t\t['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n\t\t['public', 'protected', 'private'],\n\t];\n\n\tprivate textReplace(value:string, up:boolean):string {\n\t\treturn this.valueSetsReplace(this._defaultValueSet, value, up);\n\t}\n\n\tprivate valueSetsReplace(valueSets:string[][], value:string, up:boolean):string {\n\t\tvar result:string = null;\n\t\tfor (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n\t\t\tresult = this.valueSetReplace(valueSets[i], value, up);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate valueSetReplace(valueSet:string[], value:string, up:boolean):string {\n\t\tvar idx = valueSet.indexOf(value);\n\t\tif(idx >= 0) {\n\t\t\tidx += up ? +1 : -1;\n\t\t\tif(idx < 0) {\n\t\t\t\tidx = valueSet.length - 1;\n\t\t\t} else {\n\t\t\t\tidx %= valueSet.length;\n\t\t\t}\n\t\t\treturn valueSet[idx];\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport {IInplaceReplaceSupportResult, ILink, ISuggestResult} from 'vs/editor/common/modes';\n\nexport interface IRawModelData {\n\turl:string;\n\tversionId:number;\n\tvalue:editorCommon.IRawText;\n}\n\nexport interface IEditorModelWorker {\n\tacceptNewModel(data: IRawModelData): void;\n\tacceptModelChanged(modelUrl: string, events: editorCommon.IModelContentChangedEvent2[]);\n\tacceptRemovedModel(modelUrl: string): void;\n}\n\nexport abstract class EditorSimpleWorker implements IEditorModelWorker {\n\n\tpublic acceptNewModel(data:IRawModelData): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic acceptModelChanged(modelUrl: string, events: editorCommon.IModelContentChangedEvent2[]): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic acceptRemovedModel(modelUrl: string): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.ILineChange[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeDirtyDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.IChange[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeLinks(modelUrl:string):TPromise<ILink[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic textualSuggest(modelUrl:string, position: editorCommon.IPosition, wordDef:string, wordDefFlags:string): TPromise<ISuggestResult[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic navigateValueSet(modelUrl:string, range:editorCommon.IRange, up:boolean, wordDef:string, wordDefFlags:string): TPromise<IInplaceReplaceSupportResult> {\n\t\tthrow new Error('Not implemented!');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void;\n\n\tindex: number;\n\tremainder: number;\n\n\tconstructor(index:number, remainder:number) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values:number[];\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum:number[];\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate prefixSumValidIndex:number;\n\n\tconstructor(values:number[]) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = [];\n\t\tfor (let i = 0, len = this.values.length; i < len; i++) {\n\t\t\tthis.prefixSum[i] = 0;\n\t\t}\n\t\tthis.prefixSumValidIndex = -1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this.values.length;\n\t}\n\n\tpublic insertValue(insertIndex:number, value:number): void {\n\t\tinsertIndex = Math.floor(insertIndex); //@perf\n\t\tvalue = Math.floor(value); //@perf\n\n\t\tthis.values.splice(insertIndex, 0, value);\n\t\tthis.prefixSum.splice(insertIndex, 0, 0);\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = insertIndex - 1;\n\t\t}\n\t}\n\n\tpublic insertValues(insertIndex: number, values: number[]): void {\n\t\tinsertIndex = Math.floor(insertIndex); //@perf\n\n\t\tif (values.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));\n\t\tthis.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = insertIndex - 1;\n\t\t}\n\t}\n\n\tprivate static _zeroArray(count: number): number[] {\n\t\tcount = Math.floor(count); //@perf\n\n\t\tlet r: number[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tr[i] = 0;\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic changeValue(index:number, value:number): void {\n\t\tindex = Math.floor(index); //@perf\n\t\tvalue = Math.floor(value); //@perf\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = index - 1;\n\t\t}\n\t}\n\n\tpublic removeValues(startIndex:number, cnt:number): void {\n\t\tstartIndex = Math.floor(startIndex); //@perf\n\t\tcnt = Math.floor(cnt); //@perf\n\n\t\tthis.values.splice(startIndex, cnt);\n\t\tthis.prefixSum.splice(startIndex, cnt);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = startIndex - 1;\n\t\t}\n\t}\n\n\tpublic getTotalValue(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getAccumulatedValue(this.values.length - 1);\n\t}\n\n\tpublic getAccumulatedValue(index:number): number {\n\t\tindex = Math.floor(index); //@perf\n\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (index <= this.prefixSumValidIndex) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(accumulatedValue:number): PrefixSumIndexOfResult {\n\t\taccumulatedValue = Math.floor(accumulatedValue); //@perf\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid:number;\n\t\tlet midStop:number;\n\t\tlet midStart:number;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ( (high-low)/2 ) | 0;\n\n\t\t\tmidStop = this.getAccumulatedValue(mid);\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (accumulatedValue < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (accumulatedValue >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport {IModelContentChangedEvent2, IPosition, IRange} from 'vs/editor/common/editorCommon';\nimport {PrefixSumComputer} from 'vs/editor/common/viewModel/prefixSumComputer';\n\nexport class MirrorModel2 {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\treturn this._lines.join(this._eol);\n\t}\n\n\tonEvents(events: IModelContentChangedEvent2[]): void {\n\t\tlet newEOL: string = null;\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tlet e = events[i];\n\t\t\tif (e.eol) {\n\t\t\t\tnewEOL = e.eol;\n\t\t\t}\n\t\t}\n\t\tif (newEOL && newEOL !== this._eol) {\n\t\t\tthis._eol = newEOL;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tlet lastVersionId = -1;\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tlet e = events[i];\n\n\t\t\tthis._acceptDeleteRange(e.range);\n\t\t\tthis._acceptInsertText({\n\t\t\t\tlineNumber: e.range.startLineNumber,\n\t\t\t\tcolumn: e.range.startColumn\n\t\t\t}, e.text);\n\t\t\tlastVersionId = Math.max(lastVersionId, e.versionId);\n\t\t}\n\t\tif (lastVersionId !== -1) {\n\t\t\tthis._versionId = lastVersionId;\n\t\t}\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst lineStartValues:number[] = [];\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tfor (let i = 0, len = this._lines.length; i < len; i++) {\n\t\t\t\tlineStartValues.push(this._lines[i].length + eolLength);\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex:number, newValue:string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: IPosition, insertText:string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tlet insertLines = insertText.split(/\\r\\n|\\r|\\n/);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tlet newLengths:number[] = new Array<number>(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n","define(\"vs/nls!vs/editor/common/config/defaultConfig\",['vs/nls', 'vs/nls!vs/editor/common/services/editorSimpleWorker'], function(nls, data) { return nls.create(\"vs/editor/common/config/defaultConfig\", data); });","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as nls from 'vs/nls';\nimport {IEditorOptions} from 'vs/editor/common/editorCommon';\nimport * as platform from 'vs/base/common/platform';\n\nexport interface IConfiguration {\n\teditor:IEditorOptions;\n}\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\nexport const DEFAULT_INDENTATION = {\n\ttabSize: 4,\n\tinsertSpaces: true,\n\tdetectIndentation: true\n};\nexport const DEFAULT_TRIM_AUTO_WHITESPACE = true;\n\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'Courier New\\', monospace, \\'Droid Sans Fallback\\'';\n\n/**\n * Determined from empirical observations.\n */\nexport const GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\n\nclass ConfigClass implements IConfiguration {\n\n\tpublic editor: IEditorOptions;\n\n\tconstructor() {\n\t\tthis.editor = {\n\t\t\texperimentalScreenReader: true,\n\t\t\trulers: [],\n\t\t\twordSeparators: USUAL_WORD_SEPARATORS,\n\t\t\tselectionClipboard: true,\n\t\t\tariaLabel: nls.localize('editorViewAccessibleLabel', \"Editor content\"),\n\t\t\tlineNumbers: true,\n\t\t\tselectOnLineNumbers: true,\n\t\t\tlineNumbersMinChars: 5,\n\t\t\tglyphMargin: false,\n\t\t\tlineDecorationsWidth: 10,\n\t\t\trevealHorizontalRightPadding: 30,\n\t\t\troundedSelection: true,\n\t\t\ttheme: 'vs',\n\t\t\treadOnly: false,\n\t\t\tscrollbar: {\n\t\t\t\tverticalScrollbarSize: 14,\n\t\t\t\thorizontal: 'auto',\n\t\t\t\tuseShadows: true,\n\t\t\t\tverticalHasArrows: false,\n\t\t\t\thorizontalHasArrows: false\n\t\t\t},\n\t\t\toverviewRulerLanes: 2,\n\t\t\tcursorBlinking: 'blink',\n\t\t\tcursorStyle: 'line',\n\t\t\tfontLigatures: false,\n\t\t\tdisableTranslate3d: false,\n\t\t\thideCursorInOverviewRuler: false,\n\t\t\tscrollBeyondLastLine: true,\n\t\t\tautomaticLayout: false,\n\t\t\twrappingColumn: 300,\n\t\t\twrappingIndent: 'same',\n\t\t\twordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',\n\t\t\twordWrapBreakAfterCharacters: ' \\t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ’”〉》」』】〕）］｝｣',\n\t\t\twordWrapBreakObtrusiveCharacters: '.',\n\t\t\ttabFocusMode: false,\n\n\t\t\t// Features\n\t\t\thover: true,\n\t\t\tcontextmenu: true,\n\t\t\tmouseWheelScrollSensitivity: 1,\n\t\t\tquickSuggestions: true,\n\t\t\tquickSuggestionsDelay: 10,\n\t\t\ticonsInSuggestions: true,\n\t\t\tautoClosingBrackets: true,\n\t\t\tformatOnType: false,\n\t\t\tsuggestOnTriggerCharacters: true,\n\t\t\tacceptSuggestionOnEnter: true,\n\t\t\tselectionHighlight: true,\n\t\t\toutlineMarkers: false,\n\t\t\treferenceInfos: true,\n\t\t\tfolding: true,\n\t\t\trenderWhitespace: false,\n\t\t\tindentGuides: false,\n\t\t\tuseTabStops: true,\n\n\t\t\tfontFamily: (\n\t\t\t\tplatform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)\n\t\t\t),\n\t\t\tfontSize: (\n\t\t\t\tplatform.isMacintosh ? 12 : 14\n\t\t\t),\n\t\t\tlineHeight: 0\n\t\t};\n\t}\n}\n\nexport var DefaultConfig: IConfiguration = new ConfigClass();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as modes from 'vs/editor/common/modes';\nimport {USUAL_WORD_SEPARATORS} from 'vs/editor/common/config/defaultConfig';\n\nexport class NullState implements modes.IState {\n\n\tprivate mode: modes.IMode;\n\tprivate stateData: modes.IState;\n\n\tconstructor(mode: modes.IMode, stateData: modes.IState) {\n\t\tthis.mode = mode;\n\t\tthis.stateData = stateData;\n\t}\n\n\tpublic clone(): modes.IState {\n\t\tvar stateDataClone:modes.IState = (this.stateData ? this.stateData.clone() : null);\n\t\treturn new NullState(this.mode, stateDataClone);\n\t}\n\n\tpublic equals(other:modes.IState): boolean {\n\t\tif (this.mode !== other.getMode()) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherStateData = other.getStateData();\n\t\tif (!this.stateData && !otherStateData) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.stateData && otherStateData) {\n\t\t\treturn this.stateData.equals(otherStateData);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getMode(): modes.IMode {\n\t\treturn this.mode;\n\t}\n\n\tpublic tokenize(stream:modes.IStream):modes.ITokenizationResult {\n\t\tstream.advanceToEOS();\n\t\treturn { type:'' };\n\t}\n\n\tpublic getStateData(): modes.IState {\n\t\treturn this.stateData;\n\t}\n\n\tpublic setStateData(stateData:modes.IState):void {\n\t\tthis.stateData = stateData;\n\t}\n}\n\nexport class NullMode implements modes.IMode {\n\n\t/**\n\t * Create a word definition regular expression based on default word separators.\n\t * Optionally provide allowed separators that should be included in words.\n\t *\n\t * The default would look like this:\n\t * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n\t */\n\tpublic static createWordRegExp(allowInWords:string = ''): RegExp {\n\t\tvar usualSeparators = USUAL_WORD_SEPARATORS;\n\t\tvar source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\t\tfor (var i = 0; i < usualSeparators.length; i++) {\n\t\t\tif (allowInWords.indexOf(usualSeparators[i]) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsource += '\\\\' + usualSeparators[i];\n\t\t}\n\t\tsource += '\\\\s]+)';\n\t\treturn new RegExp(source, 'g');\n\t}\n\n\t// catches numbers (including floating numbers) in the first group, and alphanum in the second\n\tstatic DEFAULT_WORD_REGEXP = NullMode.createWordRegExp();\n\n\tpublic static ID = 'vs.editor.modes.nullMode';\n\n\tpublic richEditSupport: modes.IRichEditSupport;\n\n\tconstructor() {\n\t\tthis.richEditSupport = {\n\t\t\twordDefinition: NullMode.DEFAULT_WORD_REGEXP\n\t\t};\n\t}\n\n\tpublic getId():string {\n\t\treturn NullMode.ID;\n\t}\n\n\tpublic toSimplifiedMode(): modes.IMode {\n\t\treturn this;\n\t}\n}\n\nexport function nullTokenize(mode: modes.IMode, buffer:string, state: modes.IState, deltaOffset:number = 0, stopAtOffset?:number): modes.ILineTokens {\n\tvar tokens:modes.IToken[] = [\n\t\t{\n\t\t\tstartIndex: deltaOffset,\n\t\t\ttype: ''\n\t\t}\n\t];\n\n\tvar modeTransitions:modes.IModeTransition[] = [\n\t\t{\n\t\t\tstartIndex: deltaOffset,\n\t\t\tmode: mode\n\t\t}\n\t];\n\n\treturn {\n\t\ttokens: tokens,\n\t\tactualStopOffset: deltaOffset + buffer.length,\n\t\tendState: state,\n\t\tmodeTransitions: modeTransitions\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IPosition, IWordAtPosition} from 'vs/editor/common/editorCommon';\nimport {IMode, IModeTransition} from 'vs/editor/common/modes';\nimport {NullMode} from 'vs/editor/common/modes/nullMode';\nimport {ModeTransition} from 'vs/editor/common/core/modeTransition';\n\nexport interface ITextSource {\n\n\t_lineIsTokenized(lineNumber:number): boolean;\n\n\tgetLineContent(lineNumber:number): string;\n\n\tgetMode(): IMode;\n\n\t_getLineModeTransitions(lineNumber:number): ModeTransition[];\n}\n\nexport interface INonWordTokenMap {\n\t[key:string]:boolean;\n}\n\nexport class WordHelper {\n\n\tprivate static _safeGetWordDefinition(mode:IMode): RegExp {\n\t\treturn (mode.richEditSupport ? mode.richEditSupport.wordDefinition : null);\n\t}\n\n\tpublic static ensureValidWordDefinition(wordDefinition?:RegExp): RegExp {\n\t\tvar result: RegExp = NullMode.DEFAULT_WORD_REGEXP;\n\n\t\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\t\tif (!wordDefinition.global) {\n\t\t\t\tvar flags = 'g';\n\t\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\t\tflags += 'i';\n\t\t\t\t}\n\t\t\t\tif (wordDefinition.multiline) {\n\t\t\t\t\tflags += 'm';\n\t\t\t\t}\n\t\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t\t} else {\n\t\t\t\tresult = wordDefinition;\n\t\t\t}\n\t\t}\n\n\t\tresult.lastIndex = 0;\n\n\t\treturn result;\n\t}\n\n\tpublic static massageWordDefinitionOf(mode:IMode): RegExp {\n\t\treturn WordHelper.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));\n\t}\n\n\tprivate static _getWordAtColumn(txt:string, column:number, modeIndex: number, modeTransitions:IModeTransition[]): IWordAtPosition {\n\t\tvar modeStartIndex = modeTransitions[modeIndex].startIndex,\n\t\t\tmodeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length),\n\t\t\tmode = modeTransitions[modeIndex].mode;\n\n\t\treturn WordHelper._getWordAtText(\n\t\t\tcolumn, WordHelper.massageWordDefinitionOf(mode),\n\t\t\ttxt.substring(modeStartIndex, modeEndIndex), modeStartIndex\n\t\t);\n\t}\n\n\tpublic static getWordAtPosition(textSource:ITextSource, position:IPosition): IWordAtPosition {\n\n\t\tif (!textSource._lineIsTokenized(position.lineNumber)) {\n\t\t\treturn WordHelper._getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);\n\t\t}\n\n\t\tvar result: IWordAtPosition = null;\n\t\tvar txt = textSource.getLineContent(position.lineNumber),\n\t\t\tmodeTransitions = textSource._getLineModeTransitions(position.lineNumber),\n\t\t\tcolumnIndex = position.column - 1,\n\t\t\tmodeIndex = ModeTransition.findIndexInSegmentsArray(modeTransitions, columnIndex);\n\n\t\tresult = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);\n\n\t\tif (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {\n\t\t\t// The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too\n\t\t\tresult = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic _getWordAtText(column:number, wordDefinition:RegExp, text:string, textOffset:number): IWordAtPosition {\n\n\t\t// console.log('_getWordAtText: ', column, text, textOffset);\n\n\t\tvar words = text.match(wordDefinition),\n\t\t\tk:number,\n\t\t\tstartWord:number,\n\t\t\tendWord:number,\n\t\t\tstartColumn:number,\n\t\t\tendColumn:number,\n\t\t\tword:string;\n\n\t\tif (words) {\n\t\t\tfor (k = 0; k < words.length; k++) {\n\t\t\t\tword = words[k].trim();\n\t\t\t\tif (word.length > 0) {\n\t\t\t\t\tstartWord = text.indexOf(word, endWord);\n\t\t\t\t\tendWord = startWord + word.length;\n\n\t\t\t\t\tstartColumn = textOffset + startWord + 1;\n\t\t\t\t\tendColumn = textOffset + endWord + 1;\n\n\t\t\t\t\tif (startColumn <= column && column <= endColumn) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tword: word,\n\t\t\t\t\t\t\tstartColumn: startColumn,\n\t\t\t\t\t\t\tendColumn: endColumn\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport {IRequestHandler} from 'vs/base/common/worker/simpleWorker';\nimport {Range} from 'vs/editor/common/core/range';\nimport {fuzzyContiguousFilter} from 'vs/base/common/filters';\nimport {DiffComputer} from 'vs/editor/common/diff/diffComputer';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport {MirrorModel2} from 'vs/editor/common/model/mirrorModel2';\nimport {WordHelper} from 'vs/editor/common/model/textModelWithTokensHelpers';\nimport {IInplaceReplaceSupportResult, ILink, ISuggestResult, ISuggestion} from 'vs/editor/common/modes';\nimport {computeLinks} from 'vs/editor/common/modes/linkComputer';\nimport {BasicInplaceReplace} from 'vs/editor/common/modes/supports/inplaceReplaceSupport';\nimport {EditorSimpleWorker, IRawModelData} from 'vs/editor/common/services/editorSimpleWorkerCommon';\n\nclass MirrorModel extends MirrorModel2 {\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber:number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position:editorCommon.IPosition, wordDefinition:RegExp): Range {\n\n\t\tlet wordAtText = WordHelper._getWordAtText(\n\t\t\tposition.column,\n\t\t\tWordHelper.ensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: editorCommon.IPosition, wordDefinition:RegExp): editorCommon.IWordAtPosition {\n\t\tvar wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\tprivate _getAllWords(wordDefinition:RegExp): string[] {\n\t\tvar result:string[] = [];\n\t\tthis._lines.forEach((line) => {\n\t\t\tthis._wordenize(line, wordDefinition).forEach((info) => {\n\t\t\t\tresult.push(line.substring(info.start, info.end));\n\t\t\t});\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic getAllUniqueWords(wordDefinition:RegExp, skipWordOnce?:string) : string[] {\n\t\tvar foundSkipWord = false;\n\t\tvar uniqueWords = {};\n\t\treturn this._getAllWords(wordDefinition).filter((word) => {\n\t\t\tif (skipWordOnce && !foundSkipWord && skipWordOnce === word) {\n\t\t\t\tfoundSkipWord = true;\n\t\t\t\treturn false;\n\t\t\t} else if (uniqueWords[word]) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tuniqueWords[word] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\n//\t// TODO@Joh, TODO@Alex - remove these and make sure the super-things work\n\tprivate _wordenize(content:string, wordDefinition:RegExp): editorCommon.IWordRange[] {\n\t\tvar result:editorCommon.IWordRange[] = [];\n\t\tvar match:RegExpExecArray;\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range:editorCommon.IRange): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tvar lineEnding = this._eol,\n\t\t\tstartLineIndex = range.startLineNumber - 1,\n\t\t\tendLineIndex = range.endLineNumber - 1,\n\t\t\tresultLines:string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (var i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n}\n\nexport class EditorSimpleWorkerImpl extends EditorSimpleWorker implements IRequestHandler {\n\t_requestHandlerTrait: any;\n\n\tprivate _models:{[uri:string]:MirrorModel;};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._models = Object.create(null);\n\t}\n\n\tpublic acceptNewModel(data:IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.value.lines, data.value.EOL, data.versionId);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, events: editorCommon.IModelContentChangedEvent2[]): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tlet model = this._models[strURL];\n\t\tmodel.onEvents(events);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic computeDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean): TPromise<editorCommon.ILineChange[]> {\n\t\tlet original = this._models[originalUrl];\n\t\tlet modified = this._models[modifiedUrl];\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet originalLines = original.getLinesContent();\n\t\tlet modifiedLines = modified.getLinesContent();\n\t\tlet diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldConsiderTrimWhitespaceInEmptyCase: true\n\t\t});\n\t\treturn TPromise.as(diffComputer.computeDiff());\n\t}\n\n\tpublic computeDirtyDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.IChange[]> {\n\t\tlet original = this._models[originalUrl];\n\t\tlet modified = this._models[modifiedUrl];\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet originalLines = original.getLinesContent();\n\t\tlet modifiedLines = modified.getLinesContent();\n\t\tlet diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldConsiderTrimWhitespaceInEmptyCase: false\n\t\t});\n\t\treturn TPromise.as(diffComputer.computeDiff());\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\tpublic computeLinks(modelUrl:string):TPromise<ILink[]> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TPromise.as(computeLinks(model));\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tpublic textualSuggest(modelUrl:string, position: editorCommon.IPosition, wordDef:string, wordDefFlags:string): TPromise<ISuggestResult[]> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TPromise.as(this._suggestFiltered(model, position, new RegExp(wordDef, wordDefFlags)));\n\t}\n\n\tprivate _suggestFiltered(model:MirrorModel, position: editorCommon.IPosition, wordDefRegExp: RegExp): ISuggestResult[] {\n\t\tlet value = this._suggestUnfiltered(model, position, wordDefRegExp);\n\n\t\t// filter suggestions\n\t\treturn [{\n\t\t\tcurrentWord: value.currentWord,\n\t\t\tsuggestions: value.suggestions.filter((element) => !!fuzzyContiguousFilter(value.currentWord, element.label)),\n\t\t\tincomplete: value.incomplete\n\t\t}];\n\t}\n\n\tprivate _suggestUnfiltered(model:MirrorModel, position:editorCommon.IPosition, wordDefRegExp: RegExp): ISuggestResult {\n\t\tlet currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;\n\t\tlet allWords = model.getAllUniqueWords(wordDefRegExp, currentWord);\n\n\t\tlet suggestions = allWords.filter((word) => {\n\t\t\treturn !(/^-?\\d*\\.?\\d/.test(word)); // filter out numbers\n\t\t}).map((word) => {\n\t\t\treturn <ISuggestion> {\n\t\t\t\ttype: 'text',\n\t\t\t\tlabel: word,\n\t\t\t\tcodeSnippet: word,\n\t\t\t\tnoAutoAccept: true\n\t\t\t};\n\t\t});\n\n\t\treturn {\n\t\t\tcurrentWord: currentWord,\n\t\t\tsuggestions: suggestions\n\t\t};\n\t}\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\tpublic navigateValueSet(modelUrl:string, range:editorCommon.IRange, up:boolean, wordDef:string, wordDefFlags:string): TPromise<IInplaceReplaceSupportResult> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange.endColumn += 1;\n\t\t}\n\n\t\tlet selectionText = model.getValueInRange(range);\n\n\t\tlet\twordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tlet word: string = null;\n\t\tif (wordRange !== null) {\n\t\t\tword = model.getValueInRange(wordRange);\n\t\t}\n\n\t\tlet result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn TPromise.as(result);\n\t}\n}\n\n/**\n * Called on the worker side\n */\nexport function create(): IRequestHandler {\n\treturn new EditorSimpleWorkerImpl();\n}\n"]}