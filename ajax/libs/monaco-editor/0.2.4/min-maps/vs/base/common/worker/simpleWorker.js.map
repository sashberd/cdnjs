{"version":3,"sources":["vs/base/common/worker/simpleWorker.js","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/arrays.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/map.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/platform.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/strings.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/types.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/lifecycle.ts","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/objects.ts","vs/base/common/worker/vs/base/common/winjs.base.raw.js","vs/base/common/worker/fake","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/errors.ts","vs/base/common/worker/vs/base/common/winjs.base.js","vs/base/common/worker/file:/C:/Alex/src/vscode/src/vs/base/common/worker/simpleWorker.ts"],"names":["define","require","exports","tail","array","n","length","forEach","callback","i","len","splice","equals","one","other","itemEquals","binarySearch","key","comparator","low","high","mid","comp","findFirst","p","Math","floor","merge","arrays","hashFn","result","Array","map","j","element","hash","hasOwnProperty","push","apply","coalesce","filter","e","contains","item","indexOf","swap","pos1","pos2","element1","element2","move","from","to","isFalsyOrEmpty","obj","isArray","distinct","keyFn","position","seen","Object","create","elem","uniqueFilter","firstIndex","fn","first","notFoundValue","index","commonPrefixLength","a","b","min","flatten","arr","reduce","r","v","concat","fill","num","valueFn","__extends","this","d","__","constructor","prototype","SimpleMap","_size","defineProperty","get","enumerable","configurable","k","value","peek","keys","entries","set","t","pop","has","clear","entry","toString","LinkedMap","limit","ratio","Number","MAX_VALUE","trim","next","prev","head","current","LRUCache","_super","call","hasWebWorkerSupport","_globals","Worker","_isWindows","_isMacintosh","_isLinux","_isRootUser","_isNative","_isWeb","_isQunit","_locale","undefined","_language","LANGUAGE_DEFAULT","process","platform","getuid","vscode_nls_config","env","nlsConfig","JSON","parse","resolved","availableLanguages","locale","navigator","userAgent","language","self","QUnit","Platform","_platform","Web","Mac","Windows","Linux","isWindows","isMacintosh","isLinux","isRootUser","isNative","isWeb","isQunit","global","globals","setTimeout","bind","clearTimeout","setInterval","clearInterval","map_1","pad","l","char","str","reverse","join","format","args","_i","arguments","replace","_formatRegexp","match","group","idx","parseInt","isNaN","escape","html","escapeRegExpCharacters","haystack","needle","trimmed","ltrim","rtrim","needleLen","offset","substring","haystackLen","lastIndexOf","convertSimple2RegExpPattern","pattern","stripWildcards","startsWith","endsWith","diff","createRegExp","searchString","isRegex","matchCase","wholeWord","Error","test","charAt","modifiers","RegExp","createSafeRegExp","regex","err","regExpLeadsToEndlessLoop","regexp","source","exec","lastIndex","normalizeNFC","canNormalize","cached","normalizedCache","res","nonAsciiCharactersPattern","normalize","firstNonWhitespaceIndex","getLeadingWhitespace","lastNonWhitespaceIndex","startIndex","localeCompare","strA","strB","isAsciiChar","code","equalsIgnoreCase","len1","len2","codeA","charCodeAt","codeB","abs","String","fromCharCode","toLocaleLowerCase","commonSuffixLength","aLastIndex","bLastIndex","isFullWidthCharacter","charCode","difference","second","maxLenDelta","lengthDifference","LCS","zeroArray","max","sqrt","computeLineStarts","text","ret","lcut","segments","split","count","empty","removeAnsiEscapeCodes","EL","LF","COLOR_START","COLOR_END","startsWithUTF8BOM","__utf8_bom","appendWithLimit","maxLength","newLength","substr","safeBtoa","btoa","encodeURIComponent","repeat","s","UTF8_BOM_CHARACTER","_typeof","number","isString","string","isStringArray","every","isObject","object","Date","isNumber","isBoolean","isUndefined","isUndefinedOrNull","isEmptyObject","isFunction","areFunctions","objects","validateConstraints","constraints","validateConstraint","arg","constraint","ctor","function","types_1","dispose","disposables","combinedDisposable","toDisposable","fns","freeze","Disposable","_toDispose","_register","Disposables","add","arg_1","Types","clone","deepClone","getOwnPropertyNames","cloneAndChange","changer","_cloneAndChange","encounteredObjects","changed","r1","i1","r2","i2","mixin","destination","overwrite","assign","sources","toObject","keyMap","valueMap","x","o","_a","oneKeys","sort","otherKeys","ensureProperty","property","defaultValue","arrayToHash","createKeywordMatcher","caseInsensitive","toLowerCase","word","derive","baseClass","derivedClass","prop","basePrototype","derivedPrototype","getOwnPropertyDescriptor","writable","safeStringify","stringify","getOrDefault","WinJS","setImmediate","nextTick","initializeProperties","target","members","properties","member","defineProperties","rootNamespace","defineWithParent","parentNamespace","name","currentNamespace","namespaceFragments","namespaceName","_rootNamespace","Namespace","instanceMembers","staticMembers","Utilities","markSupportedForProcessing","mix","nop","getMemberFiltered","root","hasWinRT","strings","notSupportedForProcessing","_setHasWinRT","_getMemberFiltered","getMember","ready","async","Promise","c","complete","readyState","testReadyState","document","body","addEventListener","strictProcessing","func","supportedForProcessing","requireSupportedForProcessing","location","HTMLIFrameElement","frames","ErrorFromName","Resources","_formatString","validation","message","tag","type","m","typeR","spaceR","defAction","formatLog","console","startLog","options","tags","el","not","excludeTags","action","log","stopLog","createEventProperty","eventPropStateName","state","userHandler","handler","wrapper","evt","removeEventListener","createEventProperties","events","props","EventMixinEvent","Class","detail","timeStamp","now","bubbles","cancelable","currentTarget","defaultPrevented","_preventDefaultCalled","trusted","eventPhase","preventDefault","stopImmediatePropagation","_stopImmediatePropagationCalled","stopPropagation","eventMixin","_listeners","listener","useCapture","eventListeners","dispatchEvent","details","listeners","eventValue","slice","_createEventProperty","resourceMap","mrtEventHook","contextChangedET","ListenerType","malformedFormatStringInput","ApplicationModel","Core","ResourceManager","defaultContext","qualifierValues","qualifier","unused","left","right","illegalLeft","illegalRight","_getStringWinRT","resourceId","mainResourceMap","getSubtree","stringValue","langValue","resCandidate","getValue","valueAsString","getQualifierValue","lang","_getStringJS","getStringImpl","getString","_","completed","promise","targetState","then","state_waiting","state_success_notify","_value","_setState","createErrorDetails","exception","error","id","parent","detailsForHandledError","errorValue","context","_isException","errorId","_errorId","detailsForChainedError","setErrorInfo","detailsForError","error_number","detailsForException","exceptionValue","done","onComplete","onError","onProgress","pushListener","onerrorDetails","callonerror","state_error_notify","notifySuccess","queue","_setCompleteValue","ex","_setExceptionValue","_state","CompletePromise","notifyError","handlesOnError","_setChainedErrorValue","ErrorPromise","onerrorDetailsGenerator","promiseEventListeners","errorET","canceledName","progress","_progress","isException","setErrorValue","state_error","setCompleteValue","state_success","ThenPromise","timeout","timeoutMS","timeoutWithPromise","cancelPromise","cancel","cancelTimeout","Debug","setNonUserCodeExceptions","tagWithStack","thenPromise","errorPromise","exceptionPromise","completePromise","all","state_created","state_working","state_waiting_canceled","state_canceled","state_canceling","enter","_completed","_error","_notify","_setErrorValue","waitedUpon","_chainedError","_cancelAction","_cleanupAction","staticCanceledPromise","PromiseStateMachine","_nextState","_run","creator","_stack","_getStack","_creator","ExceptionPromise","newValue","init","oncancel","_oncancel","stack","eventType","capture","any","values","canceled","as","is","errors","results","undefineds","pending","argDone","errorCount","canceledCount","Key","Done","thenEach","time","wrap","wrapError","_veryExpensiveTagWithStack","_veryExpensiveTagWithStack_tag","debuggerEnabled","SignalPromise","Signal","_promise","_Signal","xhr","req","XMLHttpRequest","onreadystatechange","_canceled","status","open","url","user","password","responseType","headers","setRequestHeader","customRequestInitializer","send","data","abort","setInnerHTML","setInnerHTMLUnsafe","setOuterHTML","setOuterHTMLUnsafe","insertAdjacentHTML","insertAdjacentHTMLUnsafe","nonStaticHTML","innerHTML","outerHTML","msApp","MSApp","execUnsafeLocalFunction","msIsStaticHTML","check","amd","module","nls","types","setUnexpectedErrorHandler","newUnexpectedErrorHandler","errorHandler","onUnexpectedError","isPromiseCanceledError","onUnexpectedPromiseError","transformErrorForSerialization","name_1","stacktrace","$isError","xhrToErrorMessage","verbose","ce","ConnectionError","verboseMessage","exceptionToErrorMessage","localize","detectSystemErrorMessage","errno","syscall","toErrorMessage","msg","notImplemented","illegalArgument","illegalState","readonly","loaderError","severity","actions","ErrorHandler","unexpectedErrorHandler","addListener","_this","_removeListener","emit","getUnexpectedErrorHandler","statusText","responseText","errorMessage","errorCode","errorObject","errorObj","connectionErrorToMessage","connectionErrorDetailsToMessage","raw","__Errors__","promiseErrorHandler","outstandingPromiseErrors","decoratePromise","completeCallback","errorCallback","pc","pe","pp","resultPromise","winjs","TPromise","PPromise","errors_1","lifecycle_1","winjs_base_1","postMessage","SimpleWorkerServer","INITIALIZE","SimpleWorkerProtocol","_workerId","_handler","_lastSentReq","_pendingReplies","setWorkerId","workerId","sendMessage","method","reply","_send","vsWorker","handleMessage","serializedMessage","_handleMessage","seq","replyMessage","warn","requestMessage","strMsg","SimpleWorkerClient","workerFactory","moduleId","_lastRequestTimestamp","_worker","_protocol","getId","loaderConfiguration","globalRequire","window","getConfig","requirejs","contexts","config","lazyProxyFulfill","lazyProxyReject","_lazyProxy","_onModuleLoaded","availableMethods","proxy","createProxyMethod","proxyMethodRequest","_onError","_request","_proxy","getProxyObject","getLastRequestTimestamp","info","postSerializedMessage","onmessage","initialize","_requestHandler","loaderConfig","baseUrl","paths","vs","nlsConfig_1","pseudo","nlsPlugin","setPseudoTranslation","catchError","cc","ee","handlerModule","methods"],"mappings":"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","file":"vs/base/common/worker/simpleWorker.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.2.3(84e204b238a1eff25d4c6f611fdcd76a494005a7)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n\ndefine(\"vs/base/common/arrays\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    /**\r\n     * Returns the last element of an array.\r\n     * @param array The array.\r\n     * @param n Which element from the end (default ist zero).\r\n     */\r\n    function tail(array, n) {\r\n        if (n === void 0) { n = 0; }\r\n        return array[array.length - (1 + n)];\r\n    }\r\n    exports.tail = tail;\r\n    /**\r\n     * Iterates the provided array and allows to remove\r\n     * elements while iterating.\r\n     */\r\n    function forEach(array, callback) {\r\n        for (var i = 0, len = array.length; i < len; i++) {\r\n            callback(array[i], function () {\r\n                array.splice(i, 1);\r\n                i--;\r\n                len--;\r\n            });\r\n        }\r\n    }\r\n    exports.forEach = forEach;\r\n    function equals(one, other, itemEquals) {\r\n        if (one.length !== other.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0, len = one.length; i < len; i++) {\r\n            if (!itemEquals(one[i], other[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    exports.equals = equals;\r\n    function binarySearch(array, key, comparator) {\r\n        var low = 0, high = array.length - 1;\r\n        while (low <= high) {\r\n            var mid = ((low + high) / 2) | 0;\r\n            var comp = comparator(array[mid], key);\r\n            if (comp < 0) {\r\n                low = mid + 1;\r\n            }\r\n            else if (comp > 0) {\r\n                high = mid - 1;\r\n            }\r\n            else {\r\n                return mid;\r\n            }\r\n        }\r\n        return -(low + 1);\r\n    }\r\n    exports.binarySearch = binarySearch;\r\n    /**\r\n     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\r\n     * are located before all elements where p(x) is true.\r\n     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\r\n     */\r\n    function findFirst(array, p) {\r\n        var low = 0, high = array.length;\r\n        if (high === 0) {\r\n            return 0; // no children\r\n        }\r\n        while (low < high) {\r\n            var mid = Math.floor((low + high) / 2);\r\n            if (p(array[mid])) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        return low;\r\n    }\r\n    exports.findFirst = findFirst;\r\n    function merge(arrays, hashFn) {\r\n        var result = new Array();\r\n        if (!hashFn) {\r\n            for (var i = 0, len = arrays.length; i < len; i++) {\r\n                result.push.apply(result, arrays[i]);\r\n            }\r\n        }\r\n        else {\r\n            var map = {};\r\n            for (var i = 0; i < arrays.length; i++) {\r\n                for (var j = 0; j < arrays[i].length; j++) {\r\n                    var element = arrays[i][j], hash = hashFn(element);\r\n                    if (!map.hasOwnProperty(hash)) {\r\n                        map[hash] = true;\r\n                        result.push(element);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    exports.merge = merge;\r\n    /**\r\n     * @returns a new array with all undefined or null values removed. The original array is not modified at all.\r\n     */\r\n    function coalesce(array) {\r\n        if (!array) {\r\n            return array;\r\n        }\r\n        return array.filter(function (e) { return !!e; });\r\n    }\r\n    exports.coalesce = coalesce;\r\n    /**\r\n     * @returns true if the given item is contained in the array.\r\n     */\r\n    function contains(array, item) {\r\n        return array.indexOf(item) >= 0;\r\n    }\r\n    exports.contains = contains;\r\n    /**\r\n     * Swaps the elements in the array for the provided positions.\r\n     */\r\n    function swap(array, pos1, pos2) {\r\n        var element1 = array[pos1];\r\n        var element2 = array[pos2];\r\n        array[pos1] = element2;\r\n        array[pos2] = element1;\r\n    }\r\n    exports.swap = swap;\r\n    /**\r\n     * Moves the element in the array for the provided positions.\r\n     */\r\n    function move(array, from, to) {\r\n        array.splice(to, 0, array.splice(from, 1)[0]);\r\n    }\r\n    exports.move = move;\r\n    /**\r\n     * @returns {{false}} if the provided object is an array\r\n     * \tand not empty.\r\n     */\r\n    function isFalsyOrEmpty(obj) {\r\n        return !Array.isArray(obj) || obj.length === 0;\r\n    }\r\n    exports.isFalsyOrEmpty = isFalsyOrEmpty;\r\n    /**\r\n     * Removes duplicates from the given array. The optional keyFn allows to specify\r\n     * how elements are checked for equalness by returning a unique string for each.\r\n     */\r\n    function distinct(array, keyFn) {\r\n        if (!keyFn) {\r\n            return array.filter(function (element, position) {\r\n                return array.indexOf(element) === position;\r\n            });\r\n        }\r\n        var seen = Object.create(null);\r\n        return array.filter(function (elem) {\r\n            var key = keyFn(elem);\r\n            if (seen[key]) {\r\n                return false;\r\n            }\r\n            seen[key] = true;\r\n            return true;\r\n        });\r\n    }\r\n    exports.distinct = distinct;\r\n    function uniqueFilter(keyFn) {\r\n        var seen = Object.create(null);\r\n        return function (element) {\r\n            var key = keyFn(element);\r\n            if (seen[key]) {\r\n                return false;\r\n            }\r\n            seen[key] = true;\r\n            return true;\r\n        };\r\n    }\r\n    exports.uniqueFilter = uniqueFilter;\r\n    function firstIndex(array, fn) {\r\n        for (var i = 0; i < array.length; i++) {\r\n            var element = array[i];\r\n            if (fn(element)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    exports.firstIndex = firstIndex;\r\n    function first(array, fn, notFoundValue) {\r\n        if (notFoundValue === void 0) { notFoundValue = null; }\r\n        var index = firstIndex(array, fn);\r\n        return index < 0 ? notFoundValue : array[index];\r\n    }\r\n    exports.first = first;\r\n    function commonPrefixLength(one, other, equals) {\r\n        if (equals === void 0) { equals = function (a, b) { return a === b; }; }\r\n        var result = 0;\r\n        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\r\n            result++;\r\n        }\r\n        return result;\r\n    }\r\n    exports.commonPrefixLength = commonPrefixLength;\r\n    function flatten(arr) {\r\n        return arr.reduce(function (r, v) { return r.concat(v); }, []);\r\n    }\r\n    exports.flatten = flatten;\r\n    function fill(num, valueFn, arr) {\r\n        if (arr === void 0) { arr = []; }\r\n        for (var i = 0; i < num; i++) {\r\n            arr[i] = valueFn();\r\n        }\r\n        return arr;\r\n    }\r\n    exports.fill = fill;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/base/common/map\", [\"require\", \"exports\"], function (require, exports) {\r\n    'use strict';\r\n    /**\r\n     * A simple map to store value by a key object. Key can be any object that has toString() function to get\r\n     * string value of the key.\r\n     */\r\n    var SimpleMap = (function () {\r\n        function SimpleMap() {\r\n            this.map = Object.create(null);\r\n            this._size = 0;\r\n        }\r\n        Object.defineProperty(SimpleMap.prototype, \"size\", {\r\n            get: function () {\r\n                return this._size;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        SimpleMap.prototype.get = function (k) {\r\n            var value = this.peek(k);\r\n            return value ? value : null;\r\n        };\r\n        SimpleMap.prototype.keys = function () {\r\n            var keys = [];\r\n            for (var key in this.map) {\r\n                keys.push(this.map[key].key);\r\n            }\r\n            return keys;\r\n        };\r\n        SimpleMap.prototype.entries = function () {\r\n            var entries = [];\r\n            for (var key in this.map) {\r\n                entries.push(this.map[key]);\r\n            }\r\n            return entries;\r\n        };\r\n        SimpleMap.prototype.set = function (k, t) {\r\n            if (this.get(k)) {\r\n                return false; // already present!\r\n            }\r\n            this.push(k, t);\r\n            return true;\r\n        };\r\n        SimpleMap.prototype.delete = function (k) {\r\n            var value = this.get(k);\r\n            if (value) {\r\n                this.pop(k);\r\n                return value;\r\n            }\r\n            return null;\r\n        };\r\n        SimpleMap.prototype.has = function (k) {\r\n            return !!this.get(k);\r\n        };\r\n        SimpleMap.prototype.clear = function () {\r\n            this.map = Object.create(null);\r\n            this._size = 0;\r\n        };\r\n        SimpleMap.prototype.push = function (key, value) {\r\n            var entry = { key: key, value: value };\r\n            this.map[key.toString()] = entry;\r\n            this._size++;\r\n        };\r\n        SimpleMap.prototype.pop = function (k) {\r\n            delete this.map[k.toString()];\r\n            this._size--;\r\n        };\r\n        SimpleMap.prototype.peek = function (k) {\r\n            var entry = this.map[k.toString()];\r\n            return entry ? entry.value : null;\r\n        };\r\n        return SimpleMap;\r\n    }());\r\n    exports.SimpleMap = SimpleMap;\r\n    /**\r\n     * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,\r\n     * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,\r\n     * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).\r\n     */\r\n    var LinkedMap = (function () {\r\n        function LinkedMap(limit, ratio) {\r\n            if (limit === void 0) { limit = Number.MAX_VALUE; }\r\n            if (ratio === void 0) { ratio = 1; }\r\n            this.limit = limit;\r\n            this.map = Object.create(null);\r\n            this._size = 0;\r\n            this.ratio = limit * ratio;\r\n        }\r\n        Object.defineProperty(LinkedMap.prototype, \"size\", {\r\n            get: function () {\r\n                return this._size;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        LinkedMap.prototype.set = function (key, value) {\r\n            if (this.map[key]) {\r\n                return false; // already present!\r\n            }\r\n            var entry = { key: key, value: value };\r\n            this.push(entry);\r\n            if (this._size > this.limit) {\r\n                this.trim();\r\n            }\r\n            return true;\r\n        };\r\n        LinkedMap.prototype.get = function (key) {\r\n            var entry = this.map[key];\r\n            return entry ? entry.value : null;\r\n        };\r\n        LinkedMap.prototype.delete = function (key) {\r\n            var entry = this.map[key];\r\n            if (entry) {\r\n                this.map[key] = void 0;\r\n                this._size--;\r\n                if (entry.next) {\r\n                    entry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]\r\n                }\r\n                else {\r\n                    this.head = entry.prev; // [A]-[x] = [A]\r\n                }\r\n                if (entry.prev) {\r\n                    entry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]\r\n                }\r\n                else {\r\n                    this.tail = entry.next; // [x]-[A] = [A]\r\n                }\r\n                return entry.value;\r\n            }\r\n            return null;\r\n        };\r\n        LinkedMap.prototype.has = function (key) {\r\n            return !!this.map[key];\r\n        };\r\n        LinkedMap.prototype.clear = function () {\r\n            this.map = Object.create(null);\r\n            this._size = 0;\r\n            this.head = null;\r\n            this.tail = null;\r\n        };\r\n        LinkedMap.prototype.push = function (entry) {\r\n            if (this.head) {\r\n                // [A]-[B] = [A]-[B]->[X]\r\n                entry.prev = this.head;\r\n                this.head.next = entry;\r\n            }\r\n            if (!this.tail) {\r\n                this.tail = entry;\r\n            }\r\n            this.head = entry;\r\n            this.map[entry.key] = entry;\r\n            this._size++;\r\n        };\r\n        LinkedMap.prototype.trim = function () {\r\n            if (this.tail) {\r\n                // Remove all elements until ratio is reached\r\n                if (this.ratio < this.limit) {\r\n                    var index = 0;\r\n                    var current = this.tail;\r\n                    while (current.next) {\r\n                        // Remove the entry\r\n                        this.map[current.key] = void 0;\r\n                        this._size--;\r\n                        // if we reached the element that overflows our ratio condition\r\n                        // make its next element the new tail of the Map and adjust the size\r\n                        if (index === this.ratio) {\r\n                            this.tail = current.next;\r\n                            this.tail.prev = null;\r\n                            break;\r\n                        }\r\n                        // Move on\r\n                        current = current.next;\r\n                        index++;\r\n                    }\r\n                }\r\n                else {\r\n                    this.map[this.tail.key] = void 0;\r\n                    this._size--;\r\n                    // [x]-[B] = [B]\r\n                    this.tail = this.tail.next;\r\n                    this.tail.prev = null;\r\n                }\r\n            }\r\n        };\r\n        return LinkedMap;\r\n    }());\r\n    exports.LinkedMap = LinkedMap;\r\n    /**\r\n     * A subclass of Map<T> that makes an entry the MRU entry as soon\r\n     * as it is being accessed. In combination with the limit for the\r\n     * maximum number of elements in the cache, it helps to remove those\r\n     * entries from the cache that are LRU.\r\n     */\r\n    var LRUCache = (function (_super) {\r\n        __extends(LRUCache, _super);\r\n        function LRUCache(limit) {\r\n            _super.call(this, limit);\r\n        }\r\n        LRUCache.prototype.get = function (key) {\r\n            // Upon access of an entry, make it the head of\r\n            // the linked map so that it is the MRU element\r\n            var entry = this.map[key];\r\n            if (entry) {\r\n                this.delete(key);\r\n                this.push(entry);\r\n                return entry.value;\r\n            }\r\n            return null;\r\n        };\r\n        return LRUCache;\r\n    }(LinkedMap));\r\n    exports.LRUCache = LRUCache;\r\n});\r\n\ndefine(\"vs/base/common/platform\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---\r\n    var _isWindows = false;\r\n    var _isMacintosh = false;\r\n    var _isLinux = false;\r\n    var _isRootUser = false;\r\n    var _isNative = false;\r\n    var _isWeb = false;\r\n    var _isQunit = false;\r\n    var _locale = undefined;\r\n    var _language = undefined;\r\n    exports.LANGUAGE_DEFAULT = 'en';\r\n    // OS detection\r\n    if (typeof process === 'object') {\r\n        _isWindows = (process.platform === 'win32');\r\n        _isMacintosh = (process.platform === 'darwin');\r\n        _isLinux = (process.platform === 'linux');\r\n        _isRootUser = !_isWindows && (process.getuid() === 0);\r\n        var vscode_nls_config = process.env['VSCODE_NLS_CONFIG'];\r\n        if (vscode_nls_config) {\r\n            try {\r\n                var nlsConfig = JSON.parse(vscode_nls_config);\r\n                var resolved = nlsConfig.availableLanguages['*'];\r\n                _locale = nlsConfig.locale;\r\n                // VSCode's default language is 'en'\r\n                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;\r\n            }\r\n            catch (e) {\r\n            }\r\n        }\r\n        _isNative = true;\r\n    }\r\n    else if (typeof navigator === 'object') {\r\n        var userAgent = navigator.userAgent;\r\n        _isWindows = userAgent.indexOf('Windows') >= 0;\r\n        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;\r\n        _isLinux = userAgent.indexOf('Linux') >= 0;\r\n        _isWeb = true;\r\n        _locale = navigator.language;\r\n        _language = _locale;\r\n        _isQunit = !!self.QUnit;\r\n    }\r\n    (function (Platform) {\r\n        Platform[Platform[\"Web\"] = 0] = \"Web\";\r\n        Platform[Platform[\"Mac\"] = 1] = \"Mac\";\r\n        Platform[Platform[\"Linux\"] = 2] = \"Linux\";\r\n        Platform[Platform[\"Windows\"] = 3] = \"Windows\";\r\n    })(exports.Platform || (exports.Platform = {}));\r\n    var Platform = exports.Platform;\r\n    exports._platform = Platform.Web;\r\n    if (_isNative) {\r\n        if (_isMacintosh) {\r\n            exports._platform = Platform.Mac;\r\n        }\r\n        else if (_isWindows) {\r\n            exports._platform = Platform.Windows;\r\n        }\r\n        else if (_isLinux) {\r\n            exports._platform = Platform.Linux;\r\n        }\r\n    }\r\n    exports.isWindows = _isWindows;\r\n    exports.isMacintosh = _isMacintosh;\r\n    exports.isLinux = _isLinux;\r\n    exports.isRootUser = _isRootUser;\r\n    exports.isNative = _isNative;\r\n    exports.isWeb = _isWeb;\r\n    exports.isQunit = _isQunit;\r\n    exports.platform = exports._platform;\r\n    /**\r\n     * The language used for the user interface. The format of\r\n     * the string is all lower case (e.g. zh-tw for Traditional\r\n     * Chinese)\r\n     */\r\n    exports.language = _language;\r\n    /**\r\n     * The OS locale or the locale specified by --locale. The format of\r\n     * the string is all lower case (e.g. zh-tw for Traditional\r\n     * Chinese). The UI is not necessarily shown in the provided locale.\r\n     */\r\n    exports.locale = _locale;\r\n    var _globals = (typeof self === 'object' ? self : global);\r\n    exports.globals = _globals;\r\n    function hasWebWorkerSupport() {\r\n        return typeof _globals.Worker !== 'undefined';\r\n    }\r\n    exports.hasWebWorkerSupport = hasWebWorkerSupport;\r\n    exports.setTimeout = _globals.setTimeout.bind(_globals);\r\n    exports.clearTimeout = _globals.clearTimeout.bind(_globals);\r\n    exports.setInterval = _globals.setInterval.bind(_globals);\r\n    exports.clearInterval = _globals.clearInterval.bind(_globals);\r\n});\r\n\ndefine(\"vs/base/common/strings\", [\"require\", \"exports\", 'vs/base/common/map'], function (require, exports, map_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    /**\r\n     * The empty string.\r\n     */\r\n    exports.empty = '';\r\n    /**\r\n     * @returns the provided number with the given number of preceding zeros.\r\n     */\r\n    function pad(n, l, char) {\r\n        if (char === void 0) { char = '0'; }\r\n        var str = '' + n;\r\n        var r = [str];\r\n        for (var i = str.length; i < l; i++) {\r\n            r.push(char);\r\n        }\r\n        return r.reverse().join('');\r\n    }\r\n    exports.pad = pad;\r\n    var _formatRegexp = /{(\\d+)}/g;\r\n    /**\r\n     * Helper to produce a string with a variable number of arguments. Insert variable segments\r\n     * into the string using the {n} notation where N is the index of the argument following the string.\r\n     * @param value string to which formatting is applied\r\n     * @param args replacements for {n}-entries\r\n     */\r\n    function format(value) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        if (args.length === 0) {\r\n            return value;\r\n        }\r\n        return value.replace(_formatRegexp, function (match, group) {\r\n            var idx = parseInt(group, 10);\r\n            return isNaN(idx) || idx < 0 || idx >= args.length ?\r\n                match :\r\n                args[idx];\r\n        });\r\n    }\r\n    exports.format = format;\r\n    /**\r\n     * Converts HTML characters inside the string to use entities instead. Makes the string safe from\r\n     * being used e.g. in HTMLElement.innerHTML.\r\n     */\r\n    function escape(html) {\r\n        return html.replace(/[<|>|&]/g, function (match) {\r\n            switch (match) {\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '&': return '&amp;';\r\n                default: return match;\r\n            }\r\n        });\r\n    }\r\n    exports.escape = escape;\r\n    /**\r\n     * Escapes regular expression characters in a given string\r\n     */\r\n    function escapeRegExpCharacters(value) {\r\n        return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\r\n    }\r\n    exports.escapeRegExpCharacters = escapeRegExpCharacters;\r\n    /**\r\n     * Removes all occurrences of needle from the beginning and end of haystack.\r\n     * @param haystack string to trim\r\n     * @param needle the thing to trim (default is a blank)\r\n     */\r\n    function trim(haystack, needle) {\r\n        if (needle === void 0) { needle = ' '; }\r\n        var trimmed = ltrim(haystack, needle);\r\n        return rtrim(trimmed, needle);\r\n    }\r\n    exports.trim = trim;\r\n    /**\r\n     * Removes all occurrences of needle from the beginning of haystack.\r\n     * @param haystack string to trim\r\n     * @param needle the thing to trim\r\n     */\r\n    function ltrim(haystack, needle) {\r\n        if (!haystack || !needle) {\r\n            return haystack;\r\n        }\r\n        var needleLen = needle.length;\r\n        if (needleLen === 0 || haystack.length === 0) {\r\n            return haystack;\r\n        }\r\n        var offset = 0, idx = -1;\r\n        while ((idx = haystack.indexOf(needle, offset)) === offset) {\r\n            offset = offset + needleLen;\r\n        }\r\n        return haystack.substring(offset);\r\n    }\r\n    exports.ltrim = ltrim;\r\n    /**\r\n     * Removes all occurrences of needle from the end of haystack.\r\n     * @param haystack string to trim\r\n     * @param needle the thing to trim\r\n     */\r\n    function rtrim(haystack, needle) {\r\n        if (!haystack || !needle) {\r\n            return haystack;\r\n        }\r\n        var needleLen = needle.length, haystackLen = haystack.length;\r\n        if (needleLen === 0 || haystackLen === 0) {\r\n            return haystack;\r\n        }\r\n        var offset = haystackLen, idx = -1;\r\n        while (true) {\r\n            idx = haystack.lastIndexOf(needle, offset - 1);\r\n            if (idx === -1 || idx + needleLen !== offset) {\r\n                break;\r\n            }\r\n            if (idx === 0) {\r\n                return '';\r\n            }\r\n            offset = idx;\r\n        }\r\n        return haystack.substring(0, offset);\r\n    }\r\n    exports.rtrim = rtrim;\r\n    function convertSimple2RegExpPattern(pattern) {\r\n        return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\r\n    }\r\n    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;\r\n    function stripWildcards(pattern) {\r\n        return pattern.replace(/\\*/g, '');\r\n    }\r\n    exports.stripWildcards = stripWildcards;\r\n    /**\r\n     * Determines if haystack starts with needle.\r\n     */\r\n    function startsWith(haystack, needle) {\r\n        if (haystack.length < needle.length) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < needle.length; i++) {\r\n            if (haystack[i] !== needle[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    exports.startsWith = startsWith;\r\n    /**\r\n     * Determines if haystack ends with needle.\r\n     */\r\n    function endsWith(haystack, needle) {\r\n        var diff = haystack.length - needle.length;\r\n        if (diff > 0) {\r\n            return haystack.lastIndexOf(needle) === diff;\r\n        }\r\n        else if (diff === 0) {\r\n            return haystack === needle;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    exports.endsWith = endsWith;\r\n    function createRegExp(searchString, isRegex, matchCase, wholeWord, global) {\r\n        if (searchString === '') {\r\n            throw new Error('Cannot create regex from empty string');\r\n        }\r\n        if (!isRegex) {\r\n            searchString = searchString.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\r\n        }\r\n        if (wholeWord) {\r\n            if (!/\\B/.test(searchString.charAt(0))) {\r\n                searchString = '\\\\b' + searchString;\r\n            }\r\n            if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\r\n                searchString = searchString + '\\\\b';\r\n            }\r\n        }\r\n        var modifiers = '';\r\n        if (global) {\r\n            modifiers += 'g';\r\n        }\r\n        if (!matchCase) {\r\n            modifiers += 'i';\r\n        }\r\n        return new RegExp(searchString, modifiers);\r\n    }\r\n    exports.createRegExp = createRegExp;\r\n    /**\r\n     * Create a regular expression only if it is valid and it doesn't lead to endless loop.\r\n     */\r\n    function createSafeRegExp(searchString, isRegex, matchCase, wholeWord) {\r\n        if (searchString === '') {\r\n            return null;\r\n        }\r\n        // Try to create a RegExp out of the params\r\n        var regex = null;\r\n        try {\r\n            regex = createRegExp(searchString, isRegex, matchCase, wholeWord, true);\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        // Guard against endless loop RegExps & wrap around try-catch as very long regexes produce an exception when executed the first time\r\n        try {\r\n            if (regExpLeadsToEndlessLoop(regex)) {\r\n                return null;\r\n            }\r\n        }\r\n        catch (err) {\r\n            return null;\r\n        }\r\n        return regex;\r\n    }\r\n    exports.createSafeRegExp = createSafeRegExp;\r\n    function regExpLeadsToEndlessLoop(regexp) {\r\n        // Exit early if it's one of these special cases which are meant to match\r\n        // against an empty string\r\n        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {\r\n            return false;\r\n        }\r\n        // We check against an empty string. If the regular expression doesn't advance\r\n        // (e.g. ends in an endless loop) it will match an empty string.\r\n        var match = regexp.exec('');\r\n        return (match && regexp.lastIndex === 0);\r\n    }\r\n    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;\r\n    /**\r\n     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\r\n     * the Normalization Form Canonical Composition.\r\n     *\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\r\n     */\r\n    exports.canNormalize = typeof (''.normalize) === 'function';\r\n    var nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\r\n    var normalizedCache = new map_1.LinkedMap(10000); // bounded to 10000 elements\r\n    function normalizeNFC(str) {\r\n        if (!exports.canNormalize || !str) {\r\n            return str;\r\n        }\r\n        var cached = normalizedCache.get(str);\r\n        if (cached) {\r\n            return cached;\r\n        }\r\n        var res;\r\n        if (nonAsciiCharactersPattern.test(str)) {\r\n            res = str.normalize('NFC');\r\n        }\r\n        else {\r\n            res = str;\r\n        }\r\n        // Use the cache for fast lookup\r\n        normalizedCache.set(str, res);\r\n        return res;\r\n    }\r\n    exports.normalizeNFC = normalizeNFC;\r\n    /**\r\n     * Returns first index of the string that is not whitespace.\r\n     * If string is empty or contains only whitespaces, returns -1\r\n     */\r\n    function firstNonWhitespaceIndex(str) {\r\n        for (var i = 0, len = str.length; i < len; i++) {\r\n            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;\r\n    /**\r\n     * Returns the leading whitespace of the string.\r\n     * If the string contains only whitespaces, returns entire string\r\n     */\r\n    function getLeadingWhitespace(str) {\r\n        for (var i = 0, len = str.length; i < len; i++) {\r\n            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\r\n                return str.substring(0, i);\r\n            }\r\n        }\r\n        return str;\r\n    }\r\n    exports.getLeadingWhitespace = getLeadingWhitespace;\r\n    /**\r\n     * Returns last index of the string that is not whitespace.\r\n     * If string is empty or contains only whitespaces, returns -1\r\n     */\r\n    function lastNonWhitespaceIndex(str, startIndex) {\r\n        if (startIndex === void 0) { startIndex = str.length - 1; }\r\n        for (var i = startIndex; i >= 0; i--) {\r\n            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;\r\n    function localeCompare(strA, strB) {\r\n        return strA.localeCompare(strB);\r\n    }\r\n    exports.localeCompare = localeCompare;\r\n    function isAsciiChar(code) {\r\n        return (code >= 97 && code <= 122) || (code >= 65 && code <= 90);\r\n    }\r\n    function equalsIgnoreCase(a, b) {\r\n        var len1 = a.length, len2 = b.length;\r\n        if (len1 !== len2) {\r\n            return false;\r\n        }\r\n        for (var i = 0; i < len1; i++) {\r\n            var codeA = a.charCodeAt(i), codeB = b.charCodeAt(i);\r\n            if (codeA === codeB) {\r\n                continue;\r\n            }\r\n            else if (isAsciiChar(codeA) && isAsciiChar(codeB)) {\r\n                var diff = Math.abs(codeA - codeB);\r\n                if (diff !== 0 && diff !== 32) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                if (String.fromCharCode(codeA).toLocaleLowerCase() !== String.fromCharCode(codeB).toLocaleLowerCase()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    exports.equalsIgnoreCase = equalsIgnoreCase;\r\n    /**\r\n     * @returns the length of the common prefix of the two strings.\r\n     */\r\n    function commonPrefixLength(a, b) {\r\n        var i, len = Math.min(a.length, b.length);\r\n        for (i = 0; i < len; i++) {\r\n            if (a.charCodeAt(i) !== b.charCodeAt(i)) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    exports.commonPrefixLength = commonPrefixLength;\r\n    /**\r\n     * @returns the length of the common suffix of the two strings.\r\n     */\r\n    function commonSuffixLength(a, b) {\r\n        var i, len = Math.min(a.length, b.length);\r\n        var aLastIndex = a.length - 1;\r\n        var bLastIndex = b.length - 1;\r\n        for (i = 0; i < len; i++) {\r\n            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n    exports.commonSuffixLength = commonSuffixLength;\r\n    // --- unicode\r\n    // http://en.wikipedia.org/wiki/Surrogate_pair\r\n    // Returns the code point starting at a specified index in a string\r\n    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\r\n    // Code points U+10000 to U+10FFFF are represented on two consecutive characters\r\n    //export function getUnicodePoint(str:string, index:number, len:number):number {\r\n    //\tlet chrCode = str.charCodeAt(index);\r\n    //\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\r\n    //\t\tlet nextChrCode = str.charCodeAt(index + 1);\r\n    //\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\r\n    //\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\r\n    //\t\t}\r\n    //\t}\r\n    //\treturn chrCode;\r\n    //}\r\n    //export function isLeadSurrogate(chr:string) {\r\n    //\tlet chrCode = chr.charCodeAt(0);\r\n    //\treturn ;\r\n    //}\r\n    //\r\n    //export function isTrailSurrogate(chr:string) {\r\n    //\tlet chrCode = chr.charCodeAt(0);\r\n    //\treturn 0xDC00 <= chrCode && chrCode <= 0xDFFF;\r\n    //}\r\n    function isFullWidthCharacter(charCode) {\r\n        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\r\n        // http://jrgraphix.net/research/unicode_blocks.php\r\n        //          2E80 — 2EFF   CJK Radicals Supplement\r\n        //          2F00 — 2FDF   Kangxi Radicals\r\n        //          2FF0 — 2FFF   Ideographic Description Characters\r\n        //          3000 — 303F   CJK Symbols and Punctuation\r\n        //          3040 — 309F   Hiragana\r\n        //          30A0 — 30FF   Katakana\r\n        //          3100 — 312F   Bopomofo\r\n        //          3130 — 318F   Hangul Compatibility Jamo\r\n        //          3190 — 319F   Kanbun\r\n        //          31A0 — 31BF   Bopomofo Extended\r\n        //          31F0 — 31FF   Katakana Phonetic Extensions\r\n        //          3200 — 32FF   Enclosed CJK Letters and Months\r\n        //          3300 — 33FF   CJK Compatibility\r\n        //          3400 — 4DBF   CJK Unified Ideographs Extension A\r\n        //          4DC0 — 4DFF   Yijing Hexagram Symbols\r\n        //          4E00 — 9FFF   CJK Unified Ideographs\r\n        //          A000 — A48F   Yi Syllables\r\n        //          A490 — A4CF   Yi Radicals\r\n        //          AC00 — D7AF   Hangul Syllables\r\n        // [IGNORE] D800 — DB7F   High Surrogates\r\n        // [IGNORE] DB80 — DBFF   High Private Use Surrogates\r\n        // [IGNORE] DC00 — DFFF   Low Surrogates\r\n        // [IGNORE] E000 — F8FF   Private Use Area\r\n        //          F900 — FAFF   CJK Compatibility Ideographs\r\n        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\r\n        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\r\n        // [IGNORE] FE00 — FE0F   Variation Selectors\r\n        // [IGNORE] FE20 — FE2F   Combining Half Marks\r\n        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms\r\n        // [IGNORE] FE50 — FE6F   Small Form Variants\r\n        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\r\n        //          FF00 — FFEF   Halfwidth and Fullwidth Forms\r\n        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\r\n        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\r\n        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\r\n        // [IGNORE] FFF0 — FFFF   Specials\r\n        charCode = +charCode; // @perf\r\n        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\r\n            || (charCode >= 0xF900 && charCode <= 0xFAFF)\r\n            || (charCode >= 0xFF01 && charCode <= 0xFF5E));\r\n    }\r\n    exports.isFullWidthCharacter = isFullWidthCharacter;\r\n    /**\r\n     * Computes the difference score for two strings. More similar strings have a higher score.\r\n     * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.\r\n     * Strings that have a large length difference will get a bad default score 0.\r\n     * Complexity - both time and space O(first.length * second.length)\r\n     * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\r\n     *\r\n     * @param first a string\r\n     * @param second a string\r\n     */\r\n    function difference(first, second, maxLenDelta) {\r\n        if (maxLenDelta === void 0) { maxLenDelta = 4; }\r\n        var lengthDifference = Math.abs(first.length - second.length);\r\n        // We only compute score if length of the currentWord and length of entry.name are similar.\r\n        if (lengthDifference > maxLenDelta) {\r\n            return 0;\r\n        }\r\n        // Initialize LCS (largest common subsequence) matrix.\r\n        var LCS = [];\r\n        var zeroArray = [];\r\n        var i, j;\r\n        for (i = 0; i < second.length + 1; ++i) {\r\n            zeroArray.push(0);\r\n        }\r\n        for (i = 0; i < first.length + 1; ++i) {\r\n            LCS.push(zeroArray);\r\n        }\r\n        for (i = 1; i < first.length + 1; ++i) {\r\n            for (j = 1; j < second.length + 1; ++j) {\r\n                if (first[i - 1] === second[j - 1]) {\r\n                    LCS[i][j] = LCS[i - 1][j - 1] + 1;\r\n                }\r\n                else {\r\n                    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return LCS[first.length][second.length] - Math.sqrt(lengthDifference);\r\n    }\r\n    exports.difference = difference;\r\n    /**\r\n     * Returns an array in which every entry is the offset of a\r\n     * line. There is always one entry which is zero.\r\n     */\r\n    function computeLineStarts(text) {\r\n        var regexp = /\\r\\n|\\r|\\n/g, ret = [0], match;\r\n        while ((match = regexp.exec(text))) {\r\n            ret.push(regexp.lastIndex);\r\n        }\r\n        return ret;\r\n    }\r\n    exports.computeLineStarts = computeLineStarts;\r\n    /**\r\n     * Given a string and a max length returns a shorted version. Shorting\r\n     * happens at favorable positions - such as whitespace or punctuation characters.\r\n     */\r\n    function lcut(text, n) {\r\n        if (text.length < n) {\r\n            return text;\r\n        }\r\n        var segments = text.split(/\\b/), count = 0;\r\n        for (var i = segments.length - 1; i >= 0; i--) {\r\n            count += segments[i].length;\r\n            if (count > n) {\r\n                segments.splice(0, i);\r\n                break;\r\n            }\r\n        }\r\n        return segments.join(exports.empty).replace(/^\\s/, exports.empty);\r\n    }\r\n    exports.lcut = lcut;\r\n    // Escape codes\r\n    // http://en.wikipedia.org/wiki/ANSI_escape_code\r\n    var EL = /\\x1B\\x5B[12]?K/g; // Erase in line\r\n    var LF = /\\xA/g; // line feed\r\n    var COLOR_START = /\\x1b\\[\\d+m/g; // Color\r\n    var COLOR_END = /\\x1b\\[0?m/g; // Color\r\n    function removeAnsiEscapeCodes(str) {\r\n        if (str) {\r\n            str = str.replace(EL, '');\r\n            str = str.replace(LF, '\\n');\r\n            str = str.replace(COLOR_START, '');\r\n            str = str.replace(COLOR_END, '');\r\n        }\r\n        return str;\r\n    }\r\n    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;\r\n    // -- UTF-8 BOM\r\n    var __utf8_bom = 65279;\r\n    exports.UTF8_BOM_CHARACTER = String.fromCharCode(__utf8_bom);\r\n    function startsWithUTF8BOM(str) {\r\n        return (str && str.length > 0 && str.charCodeAt(0) === __utf8_bom);\r\n    }\r\n    exports.startsWithUTF8BOM = startsWithUTF8BOM;\r\n    /**\r\n     * Appends two strings. If the appended result is longer than maxLength,\r\n     * trims the start of the result and replaces it with '...'.\r\n     */\r\n    function appendWithLimit(first, second, maxLength) {\r\n        var newLength = first.length + second.length;\r\n        if (newLength > maxLength) {\r\n            first = '...' + first.substr(newLength - maxLength);\r\n        }\r\n        if (second.length > maxLength) {\r\n            first += second.substr(second.length - maxLength);\r\n        }\r\n        else {\r\n            first += second;\r\n        }\r\n        return first;\r\n    }\r\n    exports.appendWithLimit = appendWithLimit;\r\n    function safeBtoa(str) {\r\n        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\r\n    }\r\n    exports.safeBtoa = safeBtoa;\r\n    function repeat(s, count) {\r\n        var result = '';\r\n        for (var i = 0; i < count; i++) {\r\n            result += s;\r\n        }\r\n        return result;\r\n    }\r\n    exports.repeat = repeat;\r\n});\r\n\ndefine(\"vs/base/common/types\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var _typeof = {\r\n        number: 'number',\r\n        string: 'string',\r\n        undefined: 'undefined',\r\n        object: 'object',\r\n        function: 'function'\r\n    };\r\n    /**\r\n     * @returns whether the provided parameter is a JavaScript Array or not.\r\n     */\r\n    function isArray(array) {\r\n        if (Array.isArray) {\r\n            return Array.isArray(array);\r\n        }\r\n        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.isArray = isArray;\r\n    /**\r\n     * @returns whether the provided parameter is a JavaScript String or not.\r\n     */\r\n    function isString(str) {\r\n        if (typeof (str) === _typeof.string || str instanceof String) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.isString = isString;\r\n    /**\r\n     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\r\n     */\r\n    function isStringArray(value) {\r\n        return isArray(value) && value.every(function (elem) { return isString(elem); });\r\n    }\r\n    exports.isStringArray = isStringArray;\r\n    /**\r\n     *\r\n     * @returns whether the provided parameter is of type `object` but **not**\r\n     *\t`null`, an `array`, a `regexp`, nor a `date`.\r\n     */\r\n    function isObject(obj) {\r\n        return typeof obj === _typeof.object\r\n            && obj !== null\r\n            && !Array.isArray(obj)\r\n            && !(obj instanceof RegExp)\r\n            && !(obj instanceof Date);\r\n    }\r\n    exports.isObject = isObject;\r\n    /**\r\n     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\r\n     * @returns whether the provided parameter is a JavaScript Number or not.\r\n     */\r\n    function isNumber(obj) {\r\n        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    exports.isNumber = isNumber;\r\n    /**\r\n     * @returns whether the provided parameter is a JavaScript Boolean or not.\r\n     */\r\n    function isBoolean(obj) {\r\n        return obj === true || obj === false;\r\n    }\r\n    exports.isBoolean = isBoolean;\r\n    /**\r\n     * @returns whether the provided parameter is undefined.\r\n     */\r\n    function isUndefined(obj) {\r\n        return typeof (obj) === _typeof.undefined;\r\n    }\r\n    exports.isUndefined = isUndefined;\r\n    /**\r\n     * @returns whether the provided parameter is undefined or null.\r\n     */\r\n    function isUndefinedOrNull(obj) {\r\n        return isUndefined(obj) || obj === null;\r\n    }\r\n    exports.isUndefinedOrNull = isUndefinedOrNull;\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    /**\r\n     * @returns whether the provided parameter is an empty JavaScript Object or not.\r\n     */\r\n    function isEmptyObject(obj) {\r\n        if (!isObject(obj)) {\r\n            return false;\r\n        }\r\n        for (var key in obj) {\r\n            if (hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    exports.isEmptyObject = isEmptyObject;\r\n    /**\r\n     * @returns whether the provided parameter is a JavaScript Function or not.\r\n     */\r\n    function isFunction(obj) {\r\n        return typeof obj === _typeof.function;\r\n    }\r\n    exports.isFunction = isFunction;\r\n    /**\r\n     * @returns whether the provided parameters is are JavaScript Function or not.\r\n     */\r\n    function areFunctions() {\r\n        var objects = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            objects[_i - 0] = arguments[_i];\r\n        }\r\n        return objects && objects.length > 0 && objects.every(isFunction);\r\n    }\r\n    exports.areFunctions = areFunctions;\r\n    function validateConstraints(args, constraints) {\r\n        var len = Math.min(args.length, constraints.length);\r\n        for (var i = 0; i < len; i++) {\r\n            validateConstraint(args[i], constraints[i]);\r\n        }\r\n    }\r\n    exports.validateConstraints = validateConstraints;\r\n    function validateConstraint(arg, constraint) {\r\n        if (isString(constraint)) {\r\n            if (typeof arg !== constraint) {\r\n                throw new Error(\"argument does not match constraint: typeof \" + constraint);\r\n            }\r\n        }\r\n        else if (isFunction(constraint)) {\r\n            if (arg instanceof constraint) {\r\n                return;\r\n            }\r\n            if (arg && arg.constructor === constraint) {\r\n                return;\r\n            }\r\n            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\r\n                return;\r\n            }\r\n            throw new Error(\"argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true\");\r\n        }\r\n    }\r\n    exports.validateConstraint = validateConstraint;\r\n    /**\r\n     * Creates a new object of the provided class and will call the constructor with\r\n     * any additional argument supplied.\r\n     */\r\n    function create(ctor) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var obj = Object.create(ctor.prototype);\r\n        ctor.apply(obj, args);\r\n        return obj;\r\n    }\r\n    exports.create = create;\r\n});\r\n\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/base/common/lifecycle\", [\"require\", \"exports\", './types'], function (require, exports, types_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.empty = Object.freeze({\r\n        dispose: function () { }\r\n    });\r\n    function dispose() {\r\n        var disposables = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            disposables[_i - 0] = arguments[_i];\r\n        }\r\n        var first = disposables[0];\r\n        if (types_1.isArray(first)) {\r\n            disposables = first;\r\n        }\r\n        disposables.forEach(function (d) { return d && d.dispose(); });\r\n        return [];\r\n    }\r\n    exports.dispose = dispose;\r\n    function combinedDisposable(disposables) {\r\n        return { dispose: function () { return dispose(disposables); } };\r\n    }\r\n    exports.combinedDisposable = combinedDisposable;\r\n    function toDisposable() {\r\n        var fns = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            fns[_i - 0] = arguments[_i];\r\n        }\r\n        return combinedDisposable(fns.map(function (fn) { return ({ dispose: fn }); }));\r\n    }\r\n    exports.toDisposable = toDisposable;\r\n    var Disposable = (function () {\r\n        function Disposable() {\r\n            this._toDispose = [];\r\n        }\r\n        Disposable.prototype.dispose = function () {\r\n            this._toDispose = dispose(this._toDispose);\r\n        };\r\n        Disposable.prototype._register = function (t) {\r\n            this._toDispose.push(t);\r\n            return t;\r\n        };\r\n        return Disposable;\r\n    }());\r\n    exports.Disposable = Disposable;\r\n    var Disposables = (function (_super) {\r\n        __extends(Disposables, _super);\r\n        function Disposables() {\r\n            _super.apply(this, arguments);\r\n        }\r\n        Disposables.prototype.add = function (arg) {\r\n            if (!Array.isArray(arg)) {\r\n                return this._register(arg);\r\n            }\r\n            else {\r\n                for (var _i = 0, arg_1 = arg; _i < arg_1.length; _i++) {\r\n                    var element = arg_1[_i];\r\n                    return this._register(element);\r\n                }\r\n            }\r\n        };\r\n        return Disposables;\r\n    }(Disposable));\r\n    exports.Disposables = Disposables;\r\n});\r\n\ndefine(\"vs/base/common/objects\", [\"require\", \"exports\", 'vs/base/common/types'], function (require, exports, Types) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    function clone(obj) {\r\n        if (!obj || typeof obj !== 'object') {\r\n            return obj;\r\n        }\r\n        if (obj instanceof RegExp) {\r\n            return obj;\r\n        }\r\n        var result = (Array.isArray(obj)) ? [] : {};\r\n        Object.keys(obj).forEach(function (key) {\r\n            if (obj[key] && typeof obj[key] === 'object') {\r\n                result[key] = clone(obj[key]);\r\n            }\r\n            else {\r\n                result[key] = obj[key];\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    exports.clone = clone;\r\n    function deepClone(obj) {\r\n        if (!obj || typeof obj !== 'object') {\r\n            return obj;\r\n        }\r\n        var result = (Array.isArray(obj)) ? [] : {};\r\n        Object.getOwnPropertyNames(obj).forEach(function (key) {\r\n            if (obj[key] && typeof obj[key] === 'object') {\r\n                result[key] = deepClone(obj[key]);\r\n            }\r\n            else {\r\n                result[key] = obj[key];\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    exports.deepClone = deepClone;\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    function cloneAndChange(obj, changer) {\r\n        return _cloneAndChange(obj, changer, []);\r\n    }\r\n    exports.cloneAndChange = cloneAndChange;\r\n    function _cloneAndChange(obj, changer, encounteredObjects) {\r\n        if (Types.isUndefinedOrNull(obj)) {\r\n            return obj;\r\n        }\r\n        var changed = changer(obj);\r\n        if (typeof changed !== 'undefined') {\r\n            return changed;\r\n        }\r\n        if (Types.isArray(obj)) {\r\n            var r1 = [];\r\n            for (var i1 = 0; i1 < obj.length; i1++) {\r\n                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));\r\n            }\r\n            return r1;\r\n        }\r\n        if (Types.isObject(obj)) {\r\n            if (encounteredObjects.indexOf(obj) >= 0) {\r\n                throw new Error('Cannot clone recursive data-structure');\r\n            }\r\n            encounteredObjects.push(obj);\r\n            var r2 = {};\r\n            for (var i2 in obj) {\r\n                if (hasOwnProperty.call(obj, i2)) {\r\n                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);\r\n                }\r\n            }\r\n            encounteredObjects.pop();\r\n            return r2;\r\n        }\r\n        return obj;\r\n    }\r\n    // DON'T USE THESE FUNCTION UNLESS YOU KNOW HOW CHROME\r\n    // WORKS... WE HAVE SEEN VERY WEIRD BEHAVIOUR WITH CHROME >= 37\r\n    ///**\r\n    // * Recursively call Object.freeze on object and any properties that are objects.\r\n    // */\r\n    //export function deepFreeze(obj:any):void {\r\n    //\tObject.freeze(obj);\r\n    //\tObject.keys(obj).forEach((key) => {\r\n    //\t\tif(!(typeof obj[key] === 'object') || Object.isFrozen(obj[key])) {\r\n    //\t\t\treturn;\r\n    //\t\t}\r\n    //\r\n    //\t\tdeepFreeze(obj[key]);\r\n    //\t});\r\n    //\tif(!Object.isFrozen(obj)) {\r\n    //\t\tconsole.log('too warm');\r\n    //\t}\r\n    //}\r\n    //\r\n    //export function deepSeal(obj:any):void {\r\n    //\tObject.seal(obj);\r\n    //\tObject.keys(obj).forEach((key) => {\r\n    //\t\tif(!(typeof obj[key] === 'object') || Object.isSealed(obj[key])) {\r\n    //\t\t\treturn;\r\n    //\t\t}\r\n    //\r\n    //\t\tdeepSeal(obj[key]);\r\n    //\t});\r\n    //\tif(!Object.isSealed(obj)) {\r\n    //\t\tconsole.log('NOT sealed');\r\n    //\t}\r\n    //}\r\n    /**\r\n     * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\r\n     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\r\n     */\r\n    function mixin(destination, source, overwrite) {\r\n        if (overwrite === void 0) { overwrite = true; }\r\n        if (!Types.isObject(destination)) {\r\n            return source;\r\n        }\r\n        if (Types.isObject(source)) {\r\n            Object.keys(source).forEach(function (key) {\r\n                if (key in destination) {\r\n                    if (overwrite) {\r\n                        if (Types.isObject(destination[key]) && Types.isObject(source[key])) {\r\n                            mixin(destination[key], source[key], overwrite);\r\n                        }\r\n                        else {\r\n                            destination[key] = source[key];\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    destination[key] = source[key];\r\n                }\r\n            });\r\n        }\r\n        return destination;\r\n    }\r\n    exports.mixin = mixin;\r\n    function assign(destination) {\r\n        var sources = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            sources[_i - 1] = arguments[_i];\r\n        }\r\n        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });\r\n        return destination;\r\n    }\r\n    exports.assign = assign;\r\n    function toObject(arr, keyMap, valueMap) {\r\n        if (valueMap === void 0) { valueMap = function (x) { return x; }; }\r\n        return arr.reduce(function (o, d) { return assign(o, (_a = {}, _a[keyMap(d)] = valueMap(d), _a)); var _a; }, Object.create(null));\r\n    }\r\n    exports.toObject = toObject;\r\n    function equals(one, other) {\r\n        if (one === other) {\r\n            return true;\r\n        }\r\n        if (one === null || one === undefined || other === null || other === undefined) {\r\n            return false;\r\n        }\r\n        if (typeof one !== typeof other) {\r\n            return false;\r\n        }\r\n        if (typeof one !== 'object') {\r\n            return false;\r\n        }\r\n        if ((Array.isArray(one)) !== (Array.isArray(other))) {\r\n            return false;\r\n        }\r\n        var i, key;\r\n        if (Array.isArray(one)) {\r\n            if (one.length !== other.length) {\r\n                return false;\r\n            }\r\n            for (i = 0; i < one.length; i++) {\r\n                if (!equals(one[i], other[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var oneKeys = [];\r\n            for (key in one) {\r\n                oneKeys.push(key);\r\n            }\r\n            oneKeys.sort();\r\n            var otherKeys = [];\r\n            for (key in other) {\r\n                otherKeys.push(key);\r\n            }\r\n            otherKeys.sort();\r\n            if (!equals(oneKeys, otherKeys)) {\r\n                return false;\r\n            }\r\n            for (i = 0; i < oneKeys.length; i++) {\r\n                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    exports.equals = equals;\r\n    function ensureProperty(obj, property, defaultValue) {\r\n        if (typeof obj[property] === 'undefined') {\r\n            obj[property] = defaultValue;\r\n        }\r\n    }\r\n    exports.ensureProperty = ensureProperty;\r\n    function arrayToHash(array) {\r\n        var result = {};\r\n        for (var i = 0; i < array.length; ++i) {\r\n            result[array[i]] = true;\r\n        }\r\n        return result;\r\n    }\r\n    exports.arrayToHash = arrayToHash;\r\n    /**\r\n     * Given an array of strings, returns a function which, given a string\r\n     * returns true or false whether the string is in that array.\r\n     */\r\n    function createKeywordMatcher(arr, caseInsensitive) {\r\n        if (caseInsensitive === void 0) { caseInsensitive = false; }\r\n        if (caseInsensitive) {\r\n            arr = arr.map(function (x) { return x.toLowerCase(); });\r\n        }\r\n        var hash = arrayToHash(arr);\r\n        if (caseInsensitive) {\r\n            return function (word) {\r\n                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\r\n            };\r\n        }\r\n        else {\r\n            return function (word) {\r\n                return hash[word] !== undefined && hash.hasOwnProperty(word);\r\n            };\r\n        }\r\n    }\r\n    exports.createKeywordMatcher = createKeywordMatcher;\r\n    /**\r\n     * Started from TypeScript's __extends function to make a type a subclass of a specific class.\r\n     * Modified to work with properties already defined on the derivedClass, since we can't get TS\r\n     * to call this method before the constructor definition.\r\n     */\r\n    function derive(baseClass, derivedClass) {\r\n        for (var prop in baseClass) {\r\n            if (baseClass.hasOwnProperty(prop)) {\r\n                derivedClass[prop] = baseClass[prop];\r\n            }\r\n        }\r\n        derivedClass = derivedClass || function () { };\r\n        var basePrototype = baseClass.prototype;\r\n        var derivedPrototype = derivedClass.prototype;\r\n        derivedClass.prototype = Object.create(basePrototype);\r\n        for (var prop in derivedPrototype) {\r\n            if (derivedPrototype.hasOwnProperty(prop)) {\r\n                // handle getters and setters properly\r\n                Object.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));\r\n            }\r\n        }\r\n        // Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.\r\n        Object.defineProperty(derivedClass.prototype, 'constructor', { value: derivedClass, writable: true, configurable: true, enumerable: true });\r\n    }\r\n    exports.derive = derive;\r\n    /**\r\n     * Calls JSON.Stringify with a replacer to break apart any circular references.\r\n     * This prevents JSON.stringify from throwing the exception\r\n     *  \"Uncaught TypeError: Converting circular structure to JSON\"\r\n     */\r\n    function safeStringify(obj) {\r\n        var seen = [];\r\n        return JSON.stringify(obj, function (key, value) {\r\n            if (Types.isObject(value) || Array.isArray(value)) {\r\n                if (seen.indexOf(value) !== -1) {\r\n                    return '[Circular]';\r\n                }\r\n                else {\r\n                    seen.push(value);\r\n                }\r\n            }\r\n            return value;\r\n        });\r\n    }\r\n    exports.safeStringify = safeStringify;\r\n    function getOrDefault(obj, fn, defaultValue) {\r\n        if (defaultValue === void 0) { defaultValue = null; }\r\n        var result = fn(obj);\r\n        return typeof result === 'undefined' ? defaultValue : result;\r\n    }\r\n    exports.getOrDefault = getOrDefault;\r\n});\r\n\n/// <loc filename=\"Metadata\\base_loc_oam.xml\" format=\"messagebundle\" />\n/*! @minifier_do_not_preserve\n  © Microsoft. All rights reserved.\n\n  This library is supported for use in Windows Store apps only.\n\n  Build: 1.0.9200.20602.win8_ldr.130108-1504\n\n  Version: Microsoft.WinJS.1.0\n*/\n\n/*\n\tNote: Copied out of base.js.\n\tChanges:\n\t\t- we have only kept the first 2554 lines.\n\t\t- we have patched WinJS.xhr to add the hedader X-Requested-With:XMLHttpRequest\n\t\t- we have wrapped the entire code in an if statement to make WinJS re-entrant (if already defined)\n\t\t- we have to define setImmediate if not running in IE 10 since its a IE 10 only function\n\t\t- we have removed some getter syntax\n*/\n\n// MONACO CHANGE: Make WinJS re-entrant (if already defined)\nif (typeof WinJS === 'undefined') {\n\n// MONACO CHANGE: define setImmediate\n(function (global) {\n    if (!global.setImmediate) {\n        if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n            // running in node\n            global.setImmediate = function(callback) {\n                return process.nextTick(callback);\n            };\n        } else {\n            // running in browser\n            global.setImmediate = function(callback) {\n                return setTimeout(callback, 0);\n            };\n        }\n\t}\n\n})(this);\n\n/// <reference path=\"ms-appx://Microsoft.WinJS.1.0/js/base.js\" />\n(function baseInit(global, undefined) {\n    \"use strict\";\n\n    function initializeProperties(target, members) {\n        var keys = Object.keys(members);\n        var properties;\n        var i, len;\n        for (i = 0, len = keys.length; i < len; i++) {\n            var key = keys[i];\n            var enumerable = key.charCodeAt(0) !== /*_*/95;\n            var member = members[key];\n            if (member && typeof member === 'object') {\n                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {\n                    if (member.enumerable === undefined) {\n                        member.enumerable = enumerable;\n                    }\n                    properties = properties || {};\n                    properties[key] = member;\n                    continue;\n                }\n            }\n            if (!enumerable) {\n                properties = properties || {};\n                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true }\n                continue;\n            }\n            target[key] = member;\n        }\n        if (properties) {\n            Object.defineProperties(target, properties);\n        }\n    }\n\n    (function (rootNamespace) {\n\n        // Create the rootNamespace in the global namespace\n        if (!global[rootNamespace]) {\n            global[rootNamespace] = Object.create(Object.prototype);\n        }\n\n        // Cache the rootNamespace we just created in a local variable\n        var _rootNamespace = global[rootNamespace];\n        if (!_rootNamespace.Namespace) {\n            _rootNamespace.Namespace = Object.create(Object.prototype);\n        }\n\n        function defineWithParent(parentNamespace, name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.defineWithParent\">\n            /// <summary locid=\"WinJS.Namespace.defineWithParent\">\n            /// Defines a new namespace with the specified name under the specified parent namespace.\n            /// </summary>\n            /// <param name=\"parentNamespace\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:parentNamespace\">\n            /// The parent namespace.\n            /// </param>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.defineWithParent_p:name\">\n            /// The name of the new namespace.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            var currentNamespace = parentNamespace,\n                namespaceFragments = name.split(\".\");\n\n            for (var i = 0, len = namespaceFragments.length; i < len; i++) {\n                var namespaceName = namespaceFragments[i];\n                if (!currentNamespace[namespaceName]) {\n                    Object.defineProperty(currentNamespace, namespaceName,\n                        { value: {}, writable: false, enumerable: true, configurable: true }\n                    );\n                }\n                currentNamespace = currentNamespace[namespaceName];\n            }\n\n            if (members) {\n                initializeProperties(currentNamespace, members);\n            }\n\n            return currentNamespace;\n        }\n\n        function define(name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.define\">\n            /// <summary locid=\"WinJS.Namespace.define\">\n            /// Defines a new namespace with the specified name.\n            /// </summary>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.define_p:name\">\n            /// The name of the namespace. This could be a dot-separated name for nested namespaces.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.define_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.define_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            return defineWithParent(global, name, members);\n        }\n\n        // Establish members of the \"WinJS.Namespace\" namespace\n        Object.defineProperties(_rootNamespace.Namespace, {\n\n            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },\n\n            define: { value: define, writable: true, enumerable: true, configurable: true }\n\n        });\n\n    })(\"WinJS\");\n\n    (function (WinJS) {\n\n        function define(constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.define\">\n            /// <summary locid=\"WinJS.Class.define\">\n            /// Defines a class using the given constructor and the specified instance members.\n            /// </summary>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.define_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:staticMembers\">\n            /// The set of static fields, properties, and methods made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.define_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            WinJS.Utilities.markSupportedForProcessing(constructor);\n            if (instanceMembers) {\n                initializeProperties(constructor.prototype, instanceMembers);\n            }\n            if (staticMembers) {\n                initializeProperties(constructor, staticMembers);\n            }\n            return constructor;\n        }\n\n        function derive(baseClass, constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.derive\">\n            /// <summary locid=\"WinJS.Class.derive\">\n            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.\n            /// </summary>\n            /// <param name=\"baseClass\" type=\"Function\" locid=\"WinJS.Class.derive_p:baseClass\">\n            /// The class to inherit from.\n            /// </param>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.derive_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:staticMembers\">\n            /// The set of static fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.derive_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            if (baseClass) {\n                constructor = constructor || function () { };\n                var basePrototype = baseClass.prototype;\n                constructor.prototype = Object.create(basePrototype);\n                WinJS.Utilities.markSupportedForProcessing(constructor);\n                Object.defineProperty(constructor.prototype, \"constructor\", { value: constructor, writable: true, configurable: true, enumerable: true });\n                if (instanceMembers) {\n                    initializeProperties(constructor.prototype, instanceMembers);\n                }\n                if (staticMembers) {\n                    initializeProperties(constructor, staticMembers);\n                }\n                return constructor;\n            } else {\n                return define(constructor, instanceMembers, staticMembers);\n            }\n        }\n\n        function mix(constructor) {\n            /// <signature helpKeyword=\"WinJS.Class.mix\">\n            /// <summary locid=\"WinJS.Class.mix\">\n            /// Defines a class using the given constructor and the union of the set of instance members\n            /// specified by all the mixin objects. The mixin parameter list is of variable length.\n            /// </summary>\n            /// <param name=\"constructor\" locid=\"WinJS.Class.mix_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.mix_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            var i, len;\n            for (i = 1, len = arguments.length; i < len; i++) {\n                initializeProperties(constructor.prototype, arguments[i]);\n            }\n            return constructor;\n        }\n\n        // Establish members of \"WinJS.Class\" namespace\n        WinJS.Namespace.define(\"WinJS.Class\", {\n            define: define,\n            derive: derive,\n            mix: mix\n        });\n\n    })(global.WinJS);\n\n})(this);\n\n\n(function baseUtilsInit(global, WinJS) {\n    \"use strict\";\n\n    var hasWinRT = !!global.Windows;\n\n    var strings = {\n\t\t// MONACOCHANGE\n        //get notSupportedForProcessing() { return WinJS.Resources._getWinJSString(\"base/notSupportedForProcessing\").value; }\n\t\tnotSupportedForProcessing: \"Value is not supported within a declarative processing context, if you want it to be supported mark it using WinJS.Utilities.markSupportedForProcessing. The value was: '{0}'\"\n    };\n\n    function nop(v) {\n        return v;\n    }\n\n    function getMemberFiltered(name, root, filter) {\n        return name.split(\".\").reduce(function (currentNamespace, name) {\n            if (currentNamespace) {\n                return filter(currentNamespace[name]);\n            }\n            return null;\n        }, root);\n    }\n\n    // Establish members of \"WinJS.Utilities\" namespace\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        // Used for mocking in tests\n        _setHasWinRT: {\n            value: function (value) {\n                hasWinRT = value;\n            },\n            configurable: false,\n            writable: false,\n            enumerable: false\n        },\n\n        /// <field type=\"Boolean\" locid=\"WinJS.Utilities.hasWinRT\" helpKeyword=\"WinJS.Utilities.hasWinRT\">Determine if WinRT is accessible in this script context.</field>\n        hasWinRT: {\n            get: function () { return hasWinRT; },\n            configurable: false,\n            enumerable: true\n        },\n\n        _getMemberFiltered: getMemberFiltered,\n\n        getMember: function (name, root) {\n            /// <signature helpKeyword=\"WinJS.Utilities.getMember\">\n            /// <summary locid=\"WinJS.Utilities.getMember\">\n            /// Gets the leaf-level type or namespace specified by the name parameter.\n            /// </summary>\n            /// <param name=\"name\" locid=\"WinJS.Utilities.getMember_p:name\">\n            /// The name of the member.\n            /// </param>\n            /// <param name=\"root\" locid=\"WinJS.Utilities.getMember_p:root\">\n            /// The root to start in. Defaults to the global object.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Utilities.getMember_returnValue\">\n            /// The leaf-level type or namespace in the specified parent namespace.\n            /// </returns>\n            /// </signature>\n            if (!name) {\n                return null;\n            }\n            return getMemberFiltered(name, root || global, nop);\n        },\n\n        ready: function (callback, async) {\n            /// <signature helpKeyword=\"WinJS.Utilities.ready\">\n            /// <summary locid=\"WinJS.Utilities.ready\">\n            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired\n            /// for the current page.\n            /// </summary>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Utilities.ready_returnValue\">A promise that completes after DOMContentLoaded has occurred.</returns>\n            /// <param name=\"callback\" optional=\"true\" locid=\"WinJS.Utilities.ready_p:callback\">\n            /// A function that executes after DOMContentLoaded has occurred.\n            /// </param>\n            /// <param name=\"async\" optional=\"true\" locid=\"WinJS.Utilities.ready_p:async\">\n            /// If true, the callback should be executed asynchronously.\n            /// </param>\n            /// </signature>\n            return new WinJS.Promise(function (c, e) {\n                function complete() {\n                    if (callback) {\n                        try {\n                            callback();\n                            c();\n                        }\n                        catch (err) {\n                            e(err);\n                        }\n                    }\n                    else {\n                        c();\n                    }\n                }\n\n                var readyState = WinJS.Utilities.testReadyState;\n                if (!readyState) {\n                    if (global.document) {\n                        readyState = document.readyState;\n                    }\n                    else {\n                        readyState = \"complete\";\n                    }\n                }\n                if (readyState === \"complete\" || (global.document && document.body !== null)) {\n                    if (async) {\n                        global.setImmediate(complete);\n                    }\n                    else {\n                        complete();\n                    }\n                }\n                else {\n                    global.addEventListener(\"DOMContentLoaded\", complete, false);\n                }\n            });\n        },\n\n        /// <field type=\"Boolean\" locid=\"WinJS.Utilities.strictProcessing\" helpKeyword=\"WinJS.Utilities.strictProcessing\">Determines if strict declarative processing is enabled in this script context.</field>\n        strictProcessing: {\n            get: function () { return true; },\n            configurable: false,\n            enumerable: true,\n        },\n\n        markSupportedForProcessing: {\n            value: function (func) {\n                /// <signature helpKeyword=\"WinJS.Utilities.markSupportedForProcessing\">\n                /// <summary locid=\"WinJS.Utilities.markSupportedForProcessing\">\n                /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll\n                /// or WinJS.Binding.processAll.\n                /// </summary>\n                /// <param name=\"func\" type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_p:func\">\n                /// The function to be marked as compatible with declarative processing.\n                /// </param>\n                /// <returns type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_returnValue\">\n                /// The input function.\n                /// </returns>\n                /// </signature>\n                func.supportedForProcessing = true;\n                return func;\n            },\n            configurable: false,\n            writable: false,\n            enumerable: true\n        },\n\n        requireSupportedForProcessing: {\n            value: function (value) {\n                /// <signature helpKeyword=\"WinJS.Utilities.requireSupportedForProcessing\">\n                /// <summary locid=\"WinJS.Utilities.requireSupportedForProcessing\">\n                /// Asserts that the value is compatible with declarative processing, such as WinJS.UI.processAll\n                /// or WinJS.Binding.processAll. If it is not compatible an exception will be thrown.\n                /// </summary>\n                /// <param name=\"value\" type=\"Object\" locid=\"WinJS.Utilities.requireSupportedForProcessing_p:value\">\n                /// The value to be tested for compatibility with declarative processing. If the\n                /// value is a function it must be marked with a property 'supportedForProcessing'\n                /// with a value of true.\n                /// </param>\n                /// <returns type=\"Object\" locid=\"WinJS.Utilities.requireSupportedForProcessing_returnValue\">\n                /// The input value.\n                /// </returns>\n                /// </signature>\n                var supportedForProcessing = true;\n\n                supportedForProcessing = supportedForProcessing && !(value === global);\n                supportedForProcessing = supportedForProcessing && !(value === global.location);\n                supportedForProcessing = supportedForProcessing && !(value instanceof HTMLIFrameElement);\n                supportedForProcessing = supportedForProcessing && !(typeof value === \"function\" && !value.supportedForProcessing);\n\n                switch (global.frames.length) {\n                    case 0:\n                        break;\n\n                    case 1:\n                        supportedForProcessing = supportedForProcessing && !(value === global.frames[0]);\n                        break;\n\n                    default:\n                        for (var i = 0, len = global.frames.length; supportedForProcessing && i < len; i++) {\n                            supportedForProcessing = supportedForProcessing && !(value === global.frames[i]);\n                        }\n                        break;\n                }\n\n                if (supportedForProcessing) {\n                    return value;\n                }\n\n                throw new WinJS.ErrorFromName(\"WinJS.Utilities.requireSupportedForProcessing\", WinJS.Resources._formatString(strings.notSupportedForProcessing, value));\n            },\n            configurable: false,\n            writable: false,\n            enumerable: true\n        },\n\n    });\n\n    WinJS.Namespace.define(\"WinJS\", {\n        validation: false,\n\n        strictProcessing: {\n            value: function () {\n                /// <signature helpKeyword=\"WinJS.strictProcessing\">\n                /// <summary locid=\"WinJS.strictProcessing\">\n                /// Strict processing is always enforced, this method has no effect.\n                /// </summary>\n                /// </signature>\n            },\n            configurable: false,\n            writable: false,\n            enumerable: false\n        },\n    });\n})(this, this.WinJS);\n\n\n(function logInit(WinJS) {\n    \"use strict\";\n\n    var spaceR = /\\s+/g;\n    var typeR = /^(error|warn|info|log)$/;\n\n    function format(message, tag, type) {\n        /// <signature helpKeyword=\"WinJS.Utilities.formatLog\">\n        /// <summary locid=\"WinJS.Utilities.formatLog\">\n        /// Adds tags and type to a logging message.\n        /// </summary>\n        /// <param name=\"message\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:message\">The message to be formatted.</param>\n        /// <param name=\"tag\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:tag\">The tag(s) to be applied to the message. Multiple tags should be separated by spaces.</param>\n        /// <param name=\"type\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:type\">The type of the message.</param>\n        /// <returns type=\"String\" locid=\"WinJS.Utilities.startLog_returnValue\">The formatted message.</returns>\n        /// </signature>\n        var m = message;\n        if (typeof (m) === \"function\") { m = m(); }\n\n        return ((type && typeR.test(type)) ? (\"\") : (type ? (type + \": \") : \"\")) +\n            (tag ? tag.replace(spaceR, \":\") + \": \" : \"\") +\n            m;\n    }\n    function defAction(message, tag, type) {\n        var m = WinJS.Utilities.formatLog(message, tag, type);\n        console[(type && typeR.test(type)) ? type : \"log\"](m);\n    }\n    function escape(s) {\n        // \\s (whitespace) is used as separator, so don't escape it\n        return s.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n    }\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        startLog: function (options) {\n            /// <signature helpKeyword=\"WinJS.Utilities.startLog\">\n            /// <summary locid=\"WinJS.Utilities.startLog\">\n            /// Configures a logger that writes messages containing the specified tags from WinJS.log to console.log.\n            /// </summary>\n            /// <param name=\"options\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:options\">The tags for messages to log. Multiple tags should be separated by spaces.</param>\n            /// </signature>\n            /// <signature>\n            /// <summary locid=\"WinJS.Utilities.startLog2\">\n            /// Configure a logger to write WinJS.log output.\n            /// </summary>\n            /// <param name=\"options\" type=\"Object\" locid=\"WinJS.Utilities.startLog_p:options2\">\n            /// May contain .type, .tags, .excludeTags and .action properties.\n            /// - .type is a required tag.\n            /// - .excludeTags is a space-separated list of tags, any of which will result in a message not being logged.\n            /// - .tags is a space-separated list of tags, any of which will result in a message being logged.\n            /// - .action is a function that, if present, will be called with the log message, tags and type. The default is to log to the console.\n            /// </param>\n            /// </signature>\n            options = options || {};\n            if (typeof options === \"string\") {\n                options = { tags: options };\n            }\n            var el = options.type && new RegExp(\"^(\" + escape(options.type).replace(spaceR, \" \").split(\" \").join(\"|\") + \")$\");\n            var not = options.excludeTags && new RegExp(\"(^|\\\\s)(\" + escape(options.excludeTags).replace(spaceR, \" \").split(\" \").join(\"|\") + \")(\\\\s|$)\", \"i\");\n            var has = options.tags && new RegExp(\"(^|\\\\s)(\" + escape(options.tags).replace(spaceR, \" \").split(\" \").join(\"|\") + \")(\\\\s|$)\", \"i\");\n            var action = options.action || defAction;\n\n            if (!el && !not && !has && !WinJS.log) {\n                WinJS.log = action;\n                return;\n            }\n\n            var result = function (message, tag, type) {\n                if (!((el && !el.test(type))          // if the expected log level is not satisfied\n                    || (not && not.test(tag))         // if any of the excluded categories exist\n                    || (has && !has.test(tag)))) {    // if at least one of the included categories doesn't exist\n                        action(message, tag, type);\n                    }\n\n                result.next && result.next(message, tag, type);\n            };\n            result.next = WinJS.log;\n            WinJS.log = result;\n        },\n        stopLog: function () {\n            /// <signature helpKeyword=\"WinJS.Utilities.stopLog\">\n            /// <summary locid=\"WinJS.Utilities.stopLog\">\n            /// Removes the previously set up logger.\n            /// </summary>\n            /// </signature>\n            delete WinJS.log;\n        },\n        formatLog: format\n    });\n})(this.WinJS);\n\n(function eventsInit(WinJS, undefined) {\n    \"use strict\";\n\n\n    function createEventProperty(name) {\n        var eventPropStateName = \"_on\" + name + \"state\";\n\n        return {\n            get: function () {\n                var state = this[eventPropStateName];\n                return state && state.userHandler;\n            },\n            set: function (handler) {\n                var state = this[eventPropStateName];\n                if (handler) {\n                    if (!state) {\n                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };\n                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });\n                        this.addEventListener(name, state.wrapper, false);\n                    }\n                    state.userHandler = handler;\n                } else if (state) {\n                    this.removeEventListener(name, state.wrapper, false);\n                    this[eventPropStateName] = null;\n                }\n            },\n            enumerable: true\n        }\n    }\n\n    function createEventProperties(events) {\n        /// <signature helpKeyword=\"WinJS.Utilities.createEventProperties\">\n        /// <summary locid=\"WinJS.Utilities.createEventProperties\">\n        /// Creates an object that has one property for each name passed to the function.\n        /// </summary>\n        /// <param name=\"events\" locid=\"WinJS.Utilities.createEventProperties_p:events\">\n        /// A variable list of property names.\n        /// </param>\n        /// <returns type=\"Object\" locid=\"WinJS.Utilities.createEventProperties_returnValue\">\n        /// The object with the specified properties. The names of the properties are prefixed with 'on'.\n        /// </returns>\n        /// </signature>\n        var props = {};\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            var name = arguments[i];\n            props[\"on\" + name] = createEventProperty(name);\n        }\n        return props;\n    }\n\n    var EventMixinEvent = WinJS.Class.define(\n        function EventMixinEvent_ctor(type, detail, target) {\n            this.detail = detail;\n            this.target = target;\n            this.timeStamp = Date.now();\n            this.type = type;\n        },\n        {\n            bubbles: { value: false, writable: false },\n            cancelable: { value: false, writable: false },\n            currentTarget: {\n                get: function () { return this.target; }\n            },\n            defaultPrevented: {\n                get: function () { return this._preventDefaultCalled; }\n            },\n            trusted: { value: false, writable: false },\n            eventPhase: { value: 0, writable: false },\n            target: null,\n            timeStamp: null,\n            type: null,\n\n            preventDefault: function () {\n                this._preventDefaultCalled = true;\n            },\n            stopImmediatePropagation: function () {\n                this._stopImmediatePropagationCalled = true;\n            },\n            stopPropagation: function () {\n            }\n        }, {\n            supportedForProcessing: false,\n        }\n    );\n\n    var eventMixin = {\n        _listeners: null,\n\n        addEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// Adds an event listener to the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:listener\">\n            /// The listener to invoke when the event gets raised.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:useCapture\">\n            /// if true initiates capture, otherwise false.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            this._listeners = this._listeners || {};\n            var eventListeners = (this._listeners[type] = this._listeners[type] || []);\n            for (var i = 0, len = eventListeners.length; i < len; i++) {\n                var l = eventListeners[i];\n                if (l.useCapture === useCapture && l.listener === listener) {\n                    return;\n                }\n            }\n            eventListeners.push({ listener: listener, useCapture: useCapture });\n        },\n        dispatchEvent: function (type, details) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// Raises an event of the specified type and with the specified additional properties.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"details\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:details\">\n            /// The set of additional properties to be attached to the event object when the event is raised.\n            /// </param>\n            /// <returns type=\"Boolean\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_returnValue\">\n            /// true if preventDefault was called on the event.\n            /// </returns>\n            /// </signature>\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                var eventValue = new EventMixinEvent(type, details, this);\n                // Need to copy the array to protect against people unregistering while we are dispatching\n                listeners = listeners.slice(0, listeners.length);\n                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {\n                    listeners[i].listener(eventValue);\n                }\n                return eventValue.defaultPrevented || false;\n            }\n            return false;\n        },\n        removeEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// Removes an event listener from the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:listener\">\n            /// The listener to remove.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:useCapture\">\n            /// Specifies whether to initiate capture.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                for (var i = 0, len = listeners.length; i < len; i++) {\n                    var l = listeners[i];\n                    if (l.listener === listener && l.useCapture === useCapture) {\n                        listeners.splice(i, 1);\n                        if (listeners.length === 0) {\n                            delete this._listeners[type];\n                        }\n                        // Only want to remove one element for each call to removeEventListener\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        _createEventProperty: createEventProperty,\n        createEventProperties: createEventProperties,\n        eventMixin: eventMixin\n    });\n\n})(this.WinJS);\n\n\n(function resourcesInit(global, WinJS, undefined) {\n    \"use strict\";\n\n    var resourceMap;\n    var mrtEventHook = false;\n    var contextChangedET = \"contextchanged\";\n\n    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /* empty */ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);\n    var listeners = new ListenerType();\n\n    var strings = {\n\t\t// MONACO CHANGE\n        //get malformedFormatStringInput() { return WinJS.Resources._getWinJSString(\"base/malformedFormatStringInput\").value; },\n\t\tmalformedFormatStringInput: \"Malformed, did you mean to escape your '{0}'?\"\n    };\n\n    WinJS.Namespace.define(\"WinJS.Resources\", {\n        addEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Resources.addEventListener\">\n            /// <summary locid=\"WinJS.Resources.addEventListener\">\n            /// Registers an event handler for the specified event.\n            /// </summary>\n            /// <param name=\"type\" type=\"String\" locid=\"WinJS.Resources.addEventListener_p:type\">\n            /// The name of the event to handle.\n            /// </param>\n            /// <param name=\"listener\" type=\"Function\" locid=\"WinJS.Resources.addEventListener_p:listener\">\n            /// The listener to invoke when the event gets raised.\n            /// </param>\n            /// <param name=\"useCapture\" type=\"Boolean\" locid=\"WinJS.Resources.addEventListener_p:useCapture\">\n            /// Set to true to register the event handler for the capturing phase; set to false to register for the bubbling phase.\n            /// </param>\n            /// </signature>\n            if (WinJS.Utilities.hasWinRT && !mrtEventHook) {\n                if (type === contextChangedET) {\n                    try {\n                        Windows.ApplicationModel.Resources.Core.ResourceManager.current.defaultContext.qualifierValues.addEventListener(\"mapchanged\", function (e) {\n                            WinJS.Resources.dispatchEvent(contextChangedET, { qualifier: e.key, changed: e.target[e.key] });\n                        }, false);\n\n                        mrtEventHook = true;\n                    } catch (e) {\n                    }\n                }\n            }\n            listeners.addEventListener(type, listener, useCapture);\n        },\n        removeEventListener: listeners.removeEventListener.bind(listeners),\n        dispatchEvent: listeners.dispatchEvent.bind(listeners),\n\n        _formatString: function (string) {\n            var args = arguments;\n            if (args.length > 1) {\n                string = string.replace(/({{)|(}})|{(\\d+)}|({)|(})/g, function (unused, left, right, index, illegalLeft, illegalRight) {\n                    if (illegalLeft || illegalRight) { throw WinJS.Resources._formatString(strings.malformedFormatStringInput, illegalLeft || illegalRight); }\n                    return (left && \"{\") || (right && \"}\") || args[(index|0) + 1];\n                });\n            }\n            return string;\n        },\n\n        _getStringWinRT: function (resourceId) {\n            if (!resourceMap) {\n                var mainResourceMap = Windows.ApplicationModel.Resources.Core.ResourceManager.current.mainResourceMap;\n                try {\n                    resourceMap = mainResourceMap.getSubtree('Resources');\n                }\n                catch (e) {\n                }\n                if (!resourceMap) {\n                    resourceMap = mainResourceMap;\n                }\n            }\n\n            var stringValue;\n            var langValue;\n            var resCandidate;\n            try {\n                resCandidate = resourceMap.getValue(resourceId);\n                if (resCandidate) {\n                    stringValue = resCandidate.valueAsString;\n                    if (stringValue === undefined) {\n                        stringValue = resCandidate.toString();\n                    }\n                }\n            }\n            catch (e) {}\n\n            if (!stringValue) {\n                return { value: resourceId, empty: true };\n            }\n\n            try {\n                langValue = resCandidate.getQualifierValue(\"Language\");\n            }\n            catch (e) {\n                return { value: stringValue };\n            }\n\n            return { value: stringValue, lang: langValue };\n        },\n\n        _getStringJS: function (resourceId) {\n            var str = global.strings && global.strings[resourceId];\n            if (typeof str === \"string\") {\n                str = { value: str };\n            }\n            return str || { value: resourceId, empty: true };\n        }\n    });\n\n    Object.defineProperties(WinJS.Resources, WinJS.Utilities.createEventProperties(contextChangedET));\n\n    var getStringImpl;\n\n    WinJS.Resources.getString = function (resourceId) {\n        /// <signature helpKeyword=\"WinJS.Resources.getString\">\n        /// <summary locid=\"WinJS.Resources.getString\">\n        /// Retrieves the resource string that has the specified resource id.\n        /// </summary>\n        /// <param name=\"resourceId\" type=\"Number\" locid=\"WinJS.Resources.getString._p:resourceId\">\n        /// The resource id of the string to retrieve.\n        /// </param>\n        /// <returns type=\"Object\" locid=\"WinJS.Resources.getString_returnValue\">\n        /// An object that can contain these properties:\n        ///\n        /// value:\n        /// The value of the requested string. This property is always present.\n        ///\n        /// empty:\n        /// A value that specifies whether the requested string wasn't found.\n        /// If its true, the string wasn't found. If its false or undefined,\n        /// the requested string was found.\n        ///\n        /// lang:\n        /// The language of the string, if specified. This property is only present\n        /// for multi-language resources.\n        ///\n        /// </returns>\n        /// </signature>\n        getStringImpl =\n            getStringImpl ||\n                (WinJS.Utilities.hasWinRT\n                    ? WinJS.Resources._getStringWinRT\n                    : WinJS.Resources._getStringJS);\n\n        return getStringImpl(resourceId);\n    };\n\n\n})(this, this.WinJS);\n\n\n(function promiseInit(global, WinJS, undefined) {\n    \"use strict\";\n\n    global.Debug && (global.Debug.setNonUserCodeExceptions = true);\n\n    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);\n    var promiseEventListeners = new ListenerType();\n    // make sure there is a listeners collection so that we can do a more trivial check below\n    promiseEventListeners._listeners = {};\n    var errorET = \"error\";\n    var canceledName = \"Canceled\";\n    var tagWithStack = false;\n    var tag = {\n        promise:            0x01,\n        thenPromise:        0x02,\n        errorPromise:       0x04,\n        exceptionPromise:   0x08,\n        completePromise:    0x10,\n    };\n    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;\n\n    //\n    // Global error counter, for each error which enters the system we increment this once and then\n    // the error number travels with the error as it traverses the tree of potential handlers.\n    //\n    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises\n    // which are in error will get tagged with a ._errorId field. This tagged field is the\n    // contract by which nested promises with errors will be identified as chaining for the\n    // purposes of the callonerror semantics. If a nested promise in error is encountered without\n    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and\n    // a new error id will be minted.\n    //\n    var error_number = 1;\n\n    //\n    // The state machine has a interesting hiccup in it with regards to notification, in order\n    // to flatten out notification and avoid recursion for synchronous completion we have an\n    // explicit set of *_notify states which are responsible for notifying their entire tree\n    // of children. They can do this because they know that immediate children are always\n    // ThenPromise instances and we can therefore reach into their state to access the\n    // _listeners collection.\n    //\n    // So, what happens is that a Promise will be fulfilled through the _completed or _error\n    // messages at which point it will enter a *_notify state and be responsible for to move\n    // its children into an (as appropriate) success or error state and also notify that child's\n    // listeners of the state transition, until leaf notes are reached.\n    //\n\n    var state_created,              // -> working\n        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting\n        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled\n        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling\n        state_canceled,             // -> error | error_notify | success | success_notify | canceling\n        state_canceling,            // -> error_notify\n        state_success_notify,       // -> success\n        state_success,              // -> .\n        state_error_notify,         // -> error\n        state_error;                // -> .\n\n    // Noop function, used in the various states to indicate that they don't support a given\n    // message. Named with the somewhat cute name '_' because it reads really well in the states.\n\n    function _() { }\n\n    // Initial state\n    //\n    state_created = {\n        name: \"created\",\n        enter: function (promise) {\n            promise._setState(state_working);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Ready state, waiting for a message (completed/error/progress), able to be canceled\n    //\n    state_working = {\n        name: \"working\",\n        enter: _,\n        cancel: function (promise) {\n            promise._setState(state_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting state, if a promise is completed with a value which is itself a promise\n    // (has a then() method) it signs up to be informed when that child promise is\n    // fulfilled at which point it will be fulfilled with that value.\n    //\n    state_waiting = {\n        name: \"waiting\",\n        enter: function (promise) {\n            var waitedUpon = promise._value;\n            var error = function (value) {\n                if (waitedUpon._errorId) {\n                    promise._chainedError(value, waitedUpon);\n                } else {\n                    // Because this is an interop boundary we want to indicate that this\n                    //  error has been handled by the promise infrastructure before we\n                    //  begin a new handling chain.\n                    //\n                    callonerror(promise, value, detailsForHandledError, waitedUpon, error);\n                    promise._error(value);\n                }\n            };\n            error.handlesOnError = true;\n            waitedUpon.then(\n                promise._completed.bind(promise),\n                error,\n                promise._progress.bind(promise)\n            );\n        },\n        cancel: function (promise) {\n            promise._setState(state_waiting_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting canceled state, when a promise has been in a waiting state and receives a\n    // request to cancel its pending work it will forward that request to the child promise\n    // and then waits to be informed of the result. This promise moves itself into the\n    // canceling state but understands that the child promise may instead push it to a\n    // different state.\n    //\n    state_waiting_canceled = {\n        name: \"waiting_canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. Triggering a cancel on the promise\n            // that we are waiting upon may result in a different state transition\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            var waitedUpon = promise._value;\n            if (waitedUpon.cancel) {\n                waitedUpon.cancel();\n            }\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceled state, moves to the canceling state and then tells the promise to do\n    // whatever it might need to do on cancelation.\n    //\n    state_canceled = {\n        name: \"canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. The _cancelAction may change the state\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            promise._cancelAction();\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceling state, commits to the promise moving to an error state with an error\n    // object whose 'name' and 'message' properties contain the string \"Canceled\"\n    //\n    state_canceling = {\n        name: \"canceling\",\n        enter: function (promise) {\n            var error = new Error(canceledName);\n            error.name = error.message;\n            promise._value = error;\n            promise._setState(state_error_notify);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success notify state, moves a promise to the success state and notifies all children\n    //\n    state_success_notify = {\n        name: \"complete_notify\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.pop();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_success);\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success state, moves a promise to the success state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_success = {\n        name: \"success\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error notify state, moves a promise to the error state and notifies all children\n    //\n    state_error_notify = {\n        name: \"error_notify\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.pop();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_error);\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error state, moves a promise to the error state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_error = {\n        name: \"error\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    //\n    // The statemachine implementation follows a very particular pattern, the states are specified\n    // as static stateless bags of functions which are then indirected through the state machine\n    // instance (a Promise). As such all of the functions on each state have the promise instance\n    // passed to them explicitly as a parameter and the Promise instance members do a little\n    // dance where they indirect through the state and insert themselves in the argument list.\n    //\n    // We could instead call directly through the promise states however then every caller\n    // would have to remember to do things like pumping the state machine to catch state transitions.\n    //\n\n    var PromiseStateMachine = WinJS.Class.define(null, {\n        _listeners: null,\n        _nextState: null,\n        _state: null,\n        _value: null,\n\n        cancel: function () {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n            /// already been fulfilled and cancellation is supported, the promise enters\n            /// the error state with a value of Error(\"Canceled\").\n            /// </summary>\n            /// </signature>\n            this._state.cancel(this);\n            this._run();\n        },\n        done: function Promise_done(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            ///\n            /// After the handlers have finished executing, this function throws any error that would have been returned\n            /// from then() as a promise in the error state.\n            /// </summary>\n            /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The fulfilled value is passed as the single argument. If the value is null,\n            /// the fulfilled value is returned. The value returned\n            /// from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while executing the function, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function is the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n            /// the function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// </signature>\n            this._state.done(this, onComplete, onError, onProgress);\n        },\n        then: function Promise_then(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            /// </summary>\n            /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The value is passed as the single argument. If the value is null, the value is returned.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while this function is being executed, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n            /// The function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n            /// The promise whose value is the result of executing the complete or\n            /// error function.\n            /// </returns>\n            /// </signature>\n            return this._state.then(this, onComplete, onError, onProgress);\n        },\n\n        _chainedError: function (value, context) {\n            var result = this._state._error(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _completed: function (value) {\n            var result = this._state._completed(this, value);\n            this._run();\n            return result;\n        },\n        _error: function (value) {\n            var result = this._state._error(this, value, detailsForError);\n            this._run();\n            return result;\n        },\n        _progress: function (value) {\n            this._state._progress(this, value);\n        },\n        _setState: function (state) {\n            this._nextState = state;\n        },\n        _setCompleteValue: function (value) {\n            this._state._setCompleteValue(this, value);\n            this._run();\n        },\n        _setChainedErrorValue: function (value, context) {\n            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _setExceptionValue: function (value) {\n            var result = this._state._setErrorValue(this, value, detailsForException);\n            this._run();\n            return result;\n        },\n        _run: function () {\n            while (this._nextState) {\n                this._state = this._nextState;\n                this._nextState = null;\n                this._state.enter(this);\n            }\n        }\n    }, {\n        supportedForProcessing: false\n    });\n\n    //\n    // Implementations of shared state machine code.\n    //\n\n    function completed(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success_notify;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function createErrorDetails(exception, error, promise, id, parent, handler) {\n        return {\n            exception: exception,\n            error: error,\n            promise: promise,\n            handler: handler,\n            id: id,\n            parent: parent\n        };\n    }\n    function detailsForHandledError(promise, errorValue, context, handler) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context,\n            handler\n        );\n    }\n    function detailsForChainedError(promise, errorValue, context) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        setErrorInfo(promise, errorId, exception);\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context\n        );\n    }\n    function detailsForError(promise, errorValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId);\n        return createErrorDetails(\n            null,\n            errorValue,\n            promise,\n            errorId\n        );\n    }\n    function detailsForException(promise, exceptionValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId, true);\n        return createErrorDetails(\n            exceptionValue,\n            null,\n            promise,\n            errorId\n        );\n    }\n    function done(promise, onComplete, onError, onProgress) {\n        pushListener(promise, { c: onComplete, e: onError, p: onProgress });\n    }\n    function error(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error_notify);\n    }\n    function notifySuccess(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onComplete = listener.c;\n            var target = listener.promise;\n            if (target) {\n                try {\n                    target._setCompleteValue(onComplete ? onComplete(value) : value);\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                CompletePromise.prototype.done.call(promise, onComplete);\n            }\n        }\n    }\n    function notifyError(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onError = listener.e;\n            var target = listener.promise;\n            if (target) {\n                try {\n                    if (onError) {\n                        if (!onError.handlesOnError) {\n                            callonerror(target, value, detailsForHandledError, promise, onError);\n                        }\n                        target._setCompleteValue(onError(value))\n                    } else {\n                        target._setChainedErrorValue(value, promise);\n                    }\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                ErrorPromise.prototype.done.call(promise, null, onError);\n            }\n        }\n    }\n    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {\n        if (promiseEventListeners._listeners[errorET]) {\n            if (value instanceof Error && value.message === canceledName) {\n                return;\n            }\n            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));\n        }\n    }\n    function progress(promise, value) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            var i, len;\n            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n                var listener = len === 1 ? listeners : listeners[i];\n                var onProgress = listener.p;\n                if (onProgress) {\n                    try { onProgress(value); } catch (ex) { }\n                }\n                if (!(listener.c || listener.e) && listener.promise) {\n                    listener.promise._progress(value);\n                }\n            }\n        }\n    }\n    function pushListener(promise, listener) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            // We may have either a single listener (which will never be wrapped in an array)\n            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener\n            // we may have to wrap the single listener before adding the second.\n            listeners = Array.isArray(listeners) ? listeners : [listeners];\n            listeners.push(listener);\n        } else {\n            listeners = listener;\n        }\n        promise._listeners = listeners;\n    }\n    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves\n    // a promise directly to the success/error state without starting another notification pass (because one\n    // is already ongoing).\n    function setErrorInfo(promise, errorId, isException) {\n        promise._isException = isException || false;\n        promise._errorId = errorId;\n    }\n    function setErrorValue(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error);\n    }\n    function setCompleteValue(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function then(promise, onComplete, onError, onProgress) {\n        var result = new ThenPromise(promise);\n        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress });\n        return result;\n    }\n\n    //\n    // Internal implementation detail promise, ThenPromise is created when a promise needs\n    // to be returned from a then() method.\n    //\n    var ThenPromise = WinJS.Class.derive(PromiseStateMachine,\n        function (creator) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._creator = creator;\n            this._setState(state_created);\n            this._run();\n        }, {\n            _creator: null,\n\n            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },\n            _cleanupAction: function () { this._creator = null; }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Slim promise implementations for already completed promises, these are created\n    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap\n    // and WinJS.Promise.wrapError.\n    //\n\n    var ErrorPromise = WinJS.Class.define(\n        function ErrorPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForError);\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function ErrorPromise_done(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                var value = this._value;\n                if (onError) {\n                    try {\n                        if (!onError.handlesOnError) {\n                            callonerror(null, value, detailsForHandledError, this, onError);\n                        }\n                        var result = onError(value);\n                        if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                            // If a promise is returned we need to wait on it.\n                            result.done();\n                        }\n                        return;\n                    } catch (ex) {\n                        value = ex;\n                    }\n                }\n                if (value instanceof Error && value.message === canceledName) {\n                    // suppress cancel\n                    return;\n                }\n                // force the exception to be thrown asyncronously to avoid any try/catch blocks\n                //\n                setImmediate(function () {\n                    throw value;\n                });\n            },\n            then: function ErrorPromise_then(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n\n                // If the promise is already in a error state and no error handler is provided\n                // we optimize by simply returning the promise instead of creating a new one.\n                //\n                if (!onError) { return this; }\n                var result;\n                var value = this._value;\n                try {\n                    if (!onError.handlesOnError) {\n                        callonerror(null, value, detailsForHandledError, this, onError);\n                    }\n                    result = new CompletePromise(onError(value));\n                } catch (ex) {\n                    // If the value throw from the error handler is the same as the value\n                    // provided to the error handler then there is no need for a new promise.\n                    //\n                    if (ex === value) {\n                        result = this;\n                    } else {\n                        result = new ExceptionPromise(ex);\n                    }\n                }\n                return result;\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var ExceptionPromise = WinJS.Class.derive(ErrorPromise,\n        function ExceptionPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForException);\n        }, {\n            /* empty */\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var CompletePromise = WinJS.Class.define(\n        function CompletePromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                var result = new ThenPromise(null);\n                result._setCompleteValue(value);\n                return result;\n            }\n            this._value = value;\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function CompletePromise_done(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                if (!onComplete) { return; }\n                try {\n                    var result = onComplete(this._value);\n                    if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                        result.done();\n                    }\n                } catch (ex) {\n                    // force the exception to be thrown asynchronously to avoid any try/catch blocks\n                    setImmediate(function () {\n                        throw ex;\n                    });\n                }\n            },\n            then: function CompletePromise_then(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n                try {\n                    // If the value returned from the completion handler is the same as the value\n                    // provided to the completion handler then there is no need for a new promise.\n                    //\n                    var newValue = onComplete ? onComplete(this._value) : this._value;\n                    return newValue === this._value ? this : new CompletePromise(newValue);\n                } catch (ex) {\n                    return new ExceptionPromise(ex);\n                }\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Promise is the user-creatable WinJS.Promise object.\n    //\n\n    function timeout(timeoutMS) {\n        var id;\n        return new WinJS.Promise(\n            function (c) {\n                if (timeoutMS) {\n                    id = setTimeout(c, timeoutMS);\n                } else {\n                    setImmediate(c);\n                }\n            },\n            function () {\n                if (id) {\n                    clearTimeout(id);\n                }\n            }\n        );\n    }\n\n    function timeoutWithPromise(timeout, promise) {\n        var cancelPromise = function () { promise.cancel(); }\n        var cancelTimeout = function () { timeout.cancel(); }\n        timeout.then(cancelPromise);\n        promise.then(cancelTimeout, cancelTimeout);\n        return promise;\n    }\n\n    var staticCanceledPromise;\n\n    var Promise = WinJS.Class.derive(PromiseStateMachine,\n        function Promise_ctor(init, oncancel) {\n            /// <signature helpKeyword=\"WinJS.Promise\">\n            /// <summary locid=\"WinJS.Promise\">\n            /// A promise provides a mechanism to schedule work to be done on a value that\n            /// has not yet been computed. It is a convenient abstraction for managing\n            /// interactions with asynchronous APIs.\n            /// </summary>\n            /// <param name=\"init\" type=\"Function\" locid=\"WinJS.Promise_p:init\">\n            /// The function that is called during construction of the  promise. The function\n            /// is given three arguments (complete, error, progress). Inside this function\n            /// you should add event listeners for the notifications supported by this value.\n            /// </param>\n            /// <param name=\"oncancel\" optional=\"true\" locid=\"WinJS.Promise_p:oncancel\">\n            /// The function to call if a consumer of this promise wants\n            /// to cancel its undone work. Promises are not required to\n            /// support cancellation.\n            /// </param>\n            /// </signature>\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._oncancel = oncancel;\n            this._setState(state_created);\n            this._run();\n\n            try {\n                var complete = this._completed.bind(this);\n                var error = this._error.bind(this);\n                var progress = this._progress.bind(this);\n                init(complete, error, progress);\n            } catch (ex) {\n                this._setExceptionValue(ex);\n            }\n        }, {\n            _oncancel: null,\n\n            _cancelAction: function () {\n\t\t\t\ttry {\n            \t\tif (this._oncancel) {\n\t\t\t\t\t\tthis._oncancel();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Promise did not implement oncancel');\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\t// Access fields to get them created\n\t\t\t\t\tvar msg = ex.message;\n\t\t\t\t\tvar stack = ex.stack;\n\t\t\t\t\tpromiseEventListeners.dispatchEvent('error', ex);\n\t\t\t\t}\n            },\n            _cleanupAction: function () { this._oncancel = null; }\n        }, {\n\n            addEventListener: function Promise_addEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.addEventListener\">\n                /// <summary locid=\"WinJS.Promise.addEventListener\">\n                /// Adds an event listener to the control.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.addEventListener_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"listener\" locid=\"WinJS.Promise.addEventListener_p:listener\">\n                /// The listener to invoke when the event is raised.\n                /// </param>\n                /// <param name=\"capture\" locid=\"WinJS.Promise.addEventListener_p:capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.addEventListener(eventType, listener, capture);\n            },\n            any: function Promise_any(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.any\">\n                /// <summary locid=\"WinJS.Promise.any\">\n                /// Returns a promise that is fulfilled when one of the input promises\n                /// has been fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Array\" locid=\"WinJS.Promise.any_p:values\">\n                /// An array that contains promise objects or objects whose property\n                /// values include promise objects.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.any_returnValue\">\n                /// A promise that on fulfillment yields the value of the input (complete or error).\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error, progress) {\n                        var keys = Object.keys(values);\n                        var errors = Array.isArray(values) ? [] : {};\n                        if (keys.length === 0) {\n                            complete();\n                        }\n                        var canceled = 0;\n                        keys.forEach(function (key) {\n                            Promise.as(values[key]).then(\n                                function () { complete({ key: key, value: values[key] }); },\n                                function (e) {\n                                    if (e instanceof Error && e.name === canceledName) {\n                                        if ((++canceled) === keys.length) {\n                                            complete(WinJS.Promise.cancel);\n                                        }\n                                        return;\n                                    }\n                                    error({ key: key, value: values[key] });\n                                }\n                            );\n                        });\n                    },\n                    function () {\n                        var keys = Object.keys(values);\n                        keys.forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            as: function Promise_as(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.as\">\n                /// <summary locid=\"WinJS.Promise.as\">\n                /// Returns a promise. If the object is already a promise it is returned;\n                /// otherwise the object is wrapped in a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.as_p:value\">\n                /// The value to be treated as a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.as_returnValue\">\n                /// A promise.\n                /// </returns>\n                /// </signature>\n                if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                    return value;\n                }\n                return new CompletePromise(value);\n            },\n            /// <field type=\"WinJS.Promise\" helpKeyword=\"WinJS.Promise.cancel\" locid=\"WinJS.Promise.cancel\">\n            /// Canceled promise value, can be returned from a promise completion handler\n            /// to indicate cancelation of the promise chain.\n            /// </field>\n            cancel: {\n                get: function () {\n                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new WinJS.ErrorFromName(canceledName)));\n                }\n            },\n            dispatchEvent: function Promise_dispatchEvent(eventType, details) {\n                /// <signature helpKeyword=\"WinJS.Promise.dispatchEvent\">\n                /// <summary locid=\"WinJS.Promise.dispatchEvent\">\n                /// Raises an event of the specified type and properties.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.dispatchEvent_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"details\" locid=\"WinJS.Promise.dispatchEvent_p:details\">\n                /// The set of additional properties to be attached to the event object.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.dispatchEvent_returnValue\">\n                /// Specifies whether preventDefault was called on the event.\n                /// </returns>\n                /// </signature>\n                return promiseEventListeners.dispatchEvent(eventType, details);\n            },\n            is: function Promise_is(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.is\">\n                /// <summary locid=\"WinJS.Promise.is\">\n                /// Determines whether a value fulfills the promise contract.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.is_p:value\">\n                /// A value that may be a promise.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.is_returnValue\">\n                /// true if the specified value is a promise, otherwise false.\n                /// </returns>\n                /// </signature>\n                return value && typeof value === \"object\" && typeof value.then === \"function\";\n            },\n            join: function Promise_join(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.join\">\n                /// <summary locid=\"WinJS.Promise.join\">\n                /// Creates a promise that is fulfilled when all the values are fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Object\" locid=\"WinJS.Promise.join_p:values\">\n                /// An object whose fields contain values, some of which may be promises.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.join_returnValue\">\n                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where\n                /// each field value is the fulfilled value of a promise.\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error, progress) {\n                        var keys = Object.keys(values);\n                        var errors = Array.isArray(values) ? [] : {};\n                        var results = Array.isArray(values) ? [] : {};\n                        var undefineds = 0;\n                        var pending = keys.length;\n                        var argDone = function (key) {\n                            if ((--pending) === 0) {\n                                var errorCount = Object.keys(errors).length;\n                                if (errorCount === 0) {\n                                    complete(results);\n                                } else {\n                                    var canceledCount = 0;\n                                    keys.forEach(function (key) {\n                                        var e = errors[key];\n                                        if (e instanceof Error && e.name === canceledName) {\n                                            canceledCount++;\n                                        }\n                                    });\n                                    if (canceledCount === errorCount) {\n                                        complete(WinJS.Promise.cancel);\n                                    } else {\n                                        error(errors);\n                                    }\n                                }\n                            } else {\n                                progress({ Key: key, Done: true });\n                            }\n                        };\n                        keys.forEach(function (key) {\n                            var value = values[key];\n                            if (value === undefined) {\n                                undefineds++;\n                            } else {\n                                Promise.then(value,\n                                    function (value) { results[key] = value; argDone(key); },\n                                    function (value) { errors[key] = value; argDone(key); }\n                                );\n                            }\n                        });\n                        pending -= undefineds;\n                        if (pending === 0) {\n                            complete(results);\n                            return;\n                        }\n                    },\n                    function () {\n                        Object.keys(values).forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.removeEventListener\">\n                /// <summary locid=\"WinJS.Promise.removeEventListener\">\n                /// Removes an event listener from the control.\n                /// </summary>\n                /// <param name='eventType' locid=\"WinJS.Promise.removeEventListener_eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name='listener' locid=\"WinJS.Promise.removeEventListener_listener\">\n                /// The listener to remove.\n                /// </param>\n                /// <param name='capture' locid=\"WinJS.Promise.removeEventListener_capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.removeEventListener(eventType, listener, capture);\n            },\n            supportedForProcessing: false,\n            then: function Promise_then(value, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.then\">\n                /// <summary locid=\"WinJS.Promise.then\">\n                /// A static version of the promise instance method then().\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.then_p:value\">\n                /// the value to be treated as a promise.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.then_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If it is null, the promise simply\n                /// returns the value. The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.then_returnValue\">\n                /// A promise whose value is the result of executing the provided complete function.\n                /// </returns>\n                /// </signature>\n                return Promise.as(value).then(onComplete, onError, onProgress);\n            },\n            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.thenEach\">\n                /// <summary locid=\"WinJS.Promise.thenEach\">\n                /// Performs an operation on all the input promises and returns a promise\n                /// that has the shape of the input and contains the result of the operation\n                /// that has been performed on each input.\n                /// </summary>\n                /// <param name=\"values\" locid=\"WinJS.Promise.thenEach_p:values\">\n                /// A set of values (which could be either an array or an object) of which some or all are promises.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.thenEach_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If the value is null, the promise returns the value.\n                /// The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.thenEach_returnValue\">\n                /// A promise that is the result of calling Promise.join on the values parameter.\n                /// </returns>\n                /// </signature>\n                var result = Array.isArray(values) ? [] : {};\n                Object.keys(values).forEach(function (key) {\n                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);\n                });\n                return Promise.join(result);\n            },\n            timeout: function Promise_timeout(time, promise) {\n                /// <signature helpKeyword=\"WinJS.Promise.timeout\">\n                /// <summary locid=\"WinJS.Promise.timeout\">\n                /// Creates a promise that is fulfilled after a timeout.\n                /// </summary>\n                /// <param name=\"timeout\" type=\"Number\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:timeout\">\n                /// The timeout period in milliseconds. If this value is zero or not specified\n                /// setImmediate is called, otherwise setTimeout is called.\n                /// </param>\n                /// <param name=\"promise\" type=\"Promise\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:promise\">\n                /// A promise that will be canceled if it doesn't complete before the\n                /// timeout has expired.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.timeout_returnValue\">\n                /// A promise that is completed asynchronously after the specified timeout.\n                /// </returns>\n                /// </signature>\n                var to = timeout(time);\n                return promise ? timeoutWithPromise(to, promise) : to;\n            },\n            wrap: function Promise_wrap(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrap\">\n                /// <summary locid=\"WinJS.Promise.wrap\">\n                /// Wraps a non-promise value in a promise. You can use this function if you need\n                /// to pass a value to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.wrap_p:value\">\n                /// Some non-promise value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrap_returnValue\">\n                /// A promise that is successfully fulfilled with the specified value\n                /// </returns>\n                /// </signature>\n                return new CompletePromise(value);\n            },\n            wrapError: function Promise_wrapError(error) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrapError\">\n                /// <summary locid=\"WinJS.Promise.wrapError\">\n                /// Wraps a non-promise error value in a promise. You can use this function if you need\n                /// to pass an error to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"error\" locid=\"WinJS.Promise.wrapError_p:error\">\n                /// A non-promise error value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrapError_returnValue\">\n                /// A promise that is in an error state with the specified value.\n                /// </returns>\n                /// </signature>\n                return new ErrorPromise(error);\n            },\n\n            _veryExpensiveTagWithStack: {\n                get: function () { return tagWithStack; },\n                set: function (value) { tagWithStack = value; }\n            },\n            _veryExpensiveTagWithStack_tag: tag,\n            _getStack: function () {\n                if (Debug.debuggerEnabled) {\n                    try { throw new Error(); } catch (e) { return e.stack; }\n                }\n            },\n\n        }\n    );\n    Object.defineProperties(Promise, WinJS.Utilities.createEventProperties(errorET));\n\n    var SignalPromise = WinJS.Class.derive(PromiseStateMachine,\n        function (cancel) {\n            this._oncancel = cancel;\n            this._setState(state_created);\n            this._run();\n        }, {\n            _cancelAction: function () { this._oncancel && this._oncancel(); },\n            _cleanupAction: function () { this._oncancel = null; }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var Signal = WinJS.Class.define(\n        function Signal_ctor(oncancel) {\n            this._promise = new SignalPromise(oncancel);\n        }, {\n            promise: {\n                get: function () { return this._promise; }\n            },\n\n            cancel: function Signal_cancel() {\n                this._promise.cancel();\n            },\n            complete: function Signal_complete(value) {\n                this._promise._completed(value);\n            },\n            error: function Signal_error(value) {\n                this._promise._error(value);\n            },\n            progress: function Signal_progress(value) {\n                this._promise._progress(value);\n            }\n        }, {\n            supportedForProcessing: false,\n        }\n    );\n\n    // Publish WinJS.Promise\n    //\n    WinJS.Namespace.define(\"WinJS\", {\n        Promise: Promise,\n        _Signal: Signal\n    });\n\n}(this, this.WinJS));\n\n(function errorsInit(global, WinJS) {\n    \"use strict\";\n\n\n    WinJS.Namespace.define(\"WinJS\", {\n        // ErrorFromName establishes a simple pattern for returning error codes.\n        //\n        ErrorFromName: WinJS.Class.derive(Error, function (name, message) {\n            /// <signature helpKeyword=\"WinJS.ErrorFromName\">\n            /// <summary locid=\"WinJS.ErrorFromName\">\n            /// Creates an Error object with the specified name and message properties.\n            /// </summary>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.ErrorFromName_p:name\">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>\n            /// <param name=\"message\" type=\"String\" optional=\"true\" locid=\"WinJS.ErrorFromName_p:message\">The message for this error. The message is meant to be consumed by humans and should be localized.</param>\n            /// <returns type=\"Error\" locid=\"WinJS.ErrorFromName_returnValue\">Error instance with .name and .message properties populated</returns>\n            /// </signature>\n            this.name = name;\n            this.message = message || name;\n        }, {\n            /* empty */\n        }, {\n            supportedForProcessing: false,\n        })\n    });\n\n})(this, this.WinJS);\n\n\n(function xhrInit(WinJS) {\n    \"use strict\";\n\n\n    WinJS.Namespace.define(\"WinJS\", {\n        xhr: function (options) {\n            /// <signature helpKeyword=\"WinJS.xhr\">\n            /// <summary locid=\"WinJS.xhr\">\n            /// Wraps calls to XMLHttpRequest in a promise.\n            /// </summary>\n            /// <param name=\"options\" type=\"Object\" locid=\"WinJS.xhr_p:options\">\n            /// The options that are applied to the XMLHttpRequest object. They are: type,\n            /// url, user, password, headers, responseType, data, and customRequestInitializer.\n            /// </param>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.xhr_returnValue\">\n            /// A promise that returns the XMLHttpRequest object when it completes.\n            /// </returns>\n            /// </signature>\n            var req;\n            return new WinJS.Promise(\n                function (c, e, p) {\n                    /// <returns value=\"c(new XMLHttpRequest())\" locid=\"WinJS.xhr.constructor._returnValue\" />\n                    req = new XMLHttpRequest();\n                    req.onreadystatechange = function () {\n                        if (req._canceled) { return; }\n\n                        if (req.readyState === 4) {\n\t\t\t\t\t\t\t// MONACO CHANGE: Handle 1223: http://bugs.jquery.com/ticket/1450\n                            if ((req.status >= 200 && req.status < 300) || req.status === 1223) {\n                                c(req);\n                            } else {\n                                e(req);\n                            }\n                            req.onreadystatechange = function () { };\n                        } else {\n                            p(req);\n                        }\n                    };\n\n                    req.open(\n                        options.type || \"GET\",\n                        options.url,\n                        // Promise based XHR does not support sync.\n                        //\n                        true,\n                        options.user,\n                        options.password\n                    );\n                    req.responseType = options.responseType || \"\";\n\n                    Object.keys(options.headers || {}).forEach(function (k) {\n                        req.setRequestHeader(k, options.headers[k]);\n                    });\n\n                    if (options.customRequestInitializer) {\n                        options.customRequestInitializer(req);\n                    }\n\n                    req.send(options.data);\n                },\n                function () {\n                    req._canceled = true;\n                    req.abort();\n                }\n            );\n        }\n    });\n\n})(this.WinJS);\n\n\n(function safeHTMLInit(global, WinJS, undefined) {\n    \"use strict\";\n\n\n    var setInnerHTML,\n        setInnerHTMLUnsafe,\n        setOuterHTML,\n        setOuterHTMLUnsafe,\n        insertAdjacentHTML,\n        insertAdjacentHTMLUnsafe;\n\n    var strings = {\n\t\t// MONACO CHANGE\n        //get nonStaticHTML() { return WinJS.Resources._getWinJSString(\"base/nonStaticHTML\").value; },\n\t\tnonStaticHTML: \"Unable to add dynamic content. A script attempted to inject dynamic content, or elements previously modified dynamically, that might be unsafe. For example, using the innerHTML property or the document.write method to add a script element will generate this exception. If the content is safe and from a trusted source, use a method to explicitly manipulate elements and attributes, such as createElement, or use setInnerHTMLUnsafe (or other unsafe method).\"\n    };\n\n    setInnerHTML = setInnerHTMLUnsafe = function (element, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTML\">\n        /// <summary locid=\"WinJS.Utilities.setInnerHTML\">\n        /// Sets the innerHTML property of the specified element to the specified text.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setInnerHTML_p:element\">\n        /// The element on which the innerHTML property is to be set.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setInnerHTML_p:text\">\n        /// The value to be set to the innerHTML property.\n        /// </param>\n        /// </signature>\n        element.innerHTML = text;\n    };\n    setOuterHTML = setOuterHTMLUnsafe = function (element, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTML\">\n        /// <summary locid=\"WinJS.Utilities.setOuterHTML\">\n        /// Sets the outerHTML property of the specified element to the specified text.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setOuterHTML_p:element\">\n        /// The element on which the outerHTML property is to be set.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setOuterHTML_p:text\">\n        /// The value to be set to the outerHTML property.\n        /// </param>\n        /// </signature>\n        element.outerHTML = text;\n    };\n    insertAdjacentHTML = insertAdjacentHTMLUnsafe = function (element, position, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTML\">\n        /// <summary locid=\"WinJS.Utilities.insertAdjacentHTML\">\n        /// Calls insertAdjacentHTML on the specified element.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:element\">\n        /// The element on which insertAdjacentHTML is to be called.\n        /// </param>\n        /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:position\">\n        /// The position relative to the element at which to insert the HTML.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:text\">\n        /// The value to be provided to insertAdjacentHTML.\n        /// </param>\n        /// </signature>\n        element.insertAdjacentHTML(position, text);\n    };\n\n    var msApp = global.MSApp;\n    if (msApp) {\n        setInnerHTMLUnsafe = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.setInnerHTMLUnsafe\">\n            /// Sets the innerHTML property of the specified element to the specified text.\n            /// </summary>\n            /// <param name='element' type='HTMLElement' locid=\"WinJS.Utilities.setInnerHTMLUnsafe_p:element\">\n            /// The element on which the innerHTML property is to be set.\n            /// </param>\n            /// <param name='text' type=\"String\" locid=\"WinJS.Utilities.setInnerHTMLUnsafe_p:text\">\n            /// The value to be set to the innerHTML property.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.innerHTML = text;\n            });\n        };\n        setOuterHTMLUnsafe = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.setOuterHTMLUnsafe\">\n            /// Sets the outerHTML property of the specified element to the specified text\n            /// in the context of msWWA.execUnsafeLocalFunction.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setOuterHTMLUnsafe_p:element\">\n            /// The element on which the outerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setOuterHTMLUnsafe_p:text\">\n            /// The value to be set to the outerHTML property.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.outerHTML = text;\n            });\n        };\n        insertAdjacentHTMLUnsafe = function (element, position, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe\">\n            /// Calls insertAdjacentHTML on the specified element in the context\n            /// of msWWA.execUnsafeLocalFunction.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:element\">\n            /// The element on which insertAdjacentHTML is to be called.\n            /// </param>\n            /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:position\">\n            /// The position relative to the element at which to insert the HTML.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:text\">\n            /// Value to be provided to insertAdjacentHTML.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.insertAdjacentHTML(position, text);\n            });\n        };\n    }\n    else if (global.msIsStaticHTML) {\n        var check = function (str) {\n            if (!global.msIsStaticHTML(str)) {\n                throw new WinJS.ErrorFromName(\"WinJS.Utitilies.NonStaticHTML\", strings.nonStaticHTML);\n            }\n        }\n        // If we ever get isStaticHTML we can attempt to recreate the behavior we have in the local\n        // compartment, in the mean-time all we can do is sanitize the input.\n        //\n        setInnerHTML = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML\">\n            /// Sets the innerHTML property of a element to the specified text\n            /// if it passes a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:element\">\n            /// The element on which the innerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:text\">\n            /// The value to be set to the innerHTML property.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.innerHTML = text;\n        };\n        setOuterHTML = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML\">\n            /// Sets the outerHTML property of a element to the specified text\n            /// if it passes a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:element\">\n            /// The element on which the outerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:text\">\n            /// The value to be set to the outerHTML property.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.outerHTML = text;\n        };\n        insertAdjacentHTML = function (element, position, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML\">\n            /// Calls insertAdjacentHTML on the element if it passes\n            /// a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:element\">\n            /// The element on which insertAdjacentHTML is to be called.\n            /// </param>\n            /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:position\">\n            /// The position relative to the element at which to insert the HTML.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:text\">\n            /// The value to be provided to insertAdjacentHTML.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.insertAdjacentHTML(position, text);\n        };\n    }\n\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        setInnerHTML: setInnerHTML,\n        setInnerHTMLUnsafe: setInnerHTMLUnsafe,\n        setOuterHTML: setOuterHTML,\n        setOuterHTMLUnsafe: setOuterHTMLUnsafe,\n        insertAdjacentHTML: insertAdjacentHTML,\n        insertAdjacentHTMLUnsafe: insertAdjacentHTMLUnsafe\n    });\n\n}(this, this.WinJS));\n\n\n\n// MONACO CHANGE\n} // if (typeof WinJS === 'undefined')\n\n(function(global) {\n\n    if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {\n        define(\"vs/base/common/winjs.base.raw\", global.WinJS);\n    } else {\n        module.exports = global.WinJS;\n    }\n\n})(this);\ndefine(\"vs/nls!vs/base/common/errors\",['vs/nls', 'vs/nls!vs/base/common/worker/simpleWorker'], function(nls, data) { return nls.create(\"vs/base/common/errors\", data); });\ndefine(\"vs/base/common/errors\", [\"require\", \"exports\", 'vs/nls!vs/base/common/errors', 'vs/base/common/objects', 'vs/base/common/platform', 'vs/base/common/types', 'vs/base/common/arrays', 'vs/base/common/strings'], function (require, exports, nls, objects, platform, types, arrays, strings) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.\r\n    var ErrorHandler = (function () {\r\n        function ErrorHandler() {\r\n            this.listeners = [];\r\n            this.unexpectedErrorHandler = function (e) {\r\n                platform.setTimeout(function () {\r\n                    if (e.stack) {\r\n                        throw new Error(e.message + '\\n\\n' + e.stack);\r\n                    }\r\n                    throw e;\r\n                }, 0);\r\n            };\r\n        }\r\n        ErrorHandler.prototype.addListener = function (listener) {\r\n            var _this = this;\r\n            this.listeners.push(listener);\r\n            return function () {\r\n                _this._removeListener(listener);\r\n            };\r\n        };\r\n        ErrorHandler.prototype.emit = function (e) {\r\n            this.listeners.forEach(function (listener) {\r\n                listener(e);\r\n            });\r\n        };\r\n        ErrorHandler.prototype._removeListener = function (listener) {\r\n            this.listeners.splice(this.listeners.indexOf(listener), 1);\r\n        };\r\n        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {\r\n            this.unexpectedErrorHandler = newUnexpectedErrorHandler;\r\n        };\r\n        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {\r\n            return this.unexpectedErrorHandler;\r\n        };\r\n        ErrorHandler.prototype.onUnexpectedError = function (e) {\r\n            this.unexpectedErrorHandler(e);\r\n            this.emit(e);\r\n        };\r\n        return ErrorHandler;\r\n    }());\r\n    exports.ErrorHandler = ErrorHandler;\r\n    exports.errorHandler = new ErrorHandler();\r\n    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {\r\n        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\r\n    }\r\n    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;\r\n    function onUnexpectedError(e) {\r\n        // ignore errors from cancelled promises\r\n        if (!isPromiseCanceledError(e)) {\r\n            exports.errorHandler.onUnexpectedError(e);\r\n        }\r\n    }\r\n    exports.onUnexpectedError = onUnexpectedError;\r\n    function onUnexpectedPromiseError(promise) {\r\n        return promise.then(null, onUnexpectedError);\r\n    }\r\n    exports.onUnexpectedPromiseError = onUnexpectedPromiseError;\r\n    function transformErrorForSerialization(error) {\r\n        if (error instanceof Error) {\r\n            var name_1 = error.name, message = error.message;\r\n            var stack = error.stacktrace || error.stack;\r\n            return {\r\n                $isError: true,\r\n                name: name_1,\r\n                message: message,\r\n                stack: stack\r\n            };\r\n        }\r\n        // return as is\r\n        return error;\r\n    }\r\n    exports.transformErrorForSerialization = transformErrorForSerialization;\r\n    /**\r\n     * The base class for all connection errors originating from XHR requests.\r\n     */\r\n    var ConnectionError = (function () {\r\n        function ConnectionError(arg) {\r\n            this.status = arg.status;\r\n            this.statusText = arg.statusText;\r\n            this.name = 'ConnectionError';\r\n            try {\r\n                this.responseText = arg.responseText;\r\n            }\r\n            catch (e) {\r\n                this.responseText = '';\r\n            }\r\n            this.errorMessage = null;\r\n            this.errorCode = null;\r\n            this.errorObject = null;\r\n            if (this.responseText) {\r\n                try {\r\n                    var errorObj = JSON.parse(this.responseText);\r\n                    this.errorMessage = errorObj.message;\r\n                    this.errorCode = errorObj.code;\r\n                    this.errorObject = errorObj;\r\n                }\r\n                catch (error) {\r\n                }\r\n            }\r\n        }\r\n        Object.defineProperty(ConnectionError.prototype, \"message\", {\r\n            get: function () {\r\n                return this.connectionErrorToMessage(this, false);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(ConnectionError.prototype, \"verboseMessage\", {\r\n            get: function () {\r\n                return this.connectionErrorToMessage(this, true);\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        ConnectionError.prototype.connectionErrorDetailsToMessage = function (error, verbose) {\r\n            var errorCode = error.errorCode;\r\n            var errorMessage = error.errorMessage;\r\n            if (errorCode !== null && errorMessage !== null) {\r\n                return nls.localize(0, null, strings.rtrim(errorMessage, '.'), errorCode);\r\n\r\n\r\n\r\n\r\n\r\n\r\n            }\r\n            if (errorMessage !== null) {\r\n                return errorMessage;\r\n            }\r\n            if (verbose && error.responseText !== null) {\r\n                return error.responseText;\r\n            }\r\n            return null;\r\n        };\r\n        ConnectionError.prototype.connectionErrorToMessage = function (error, verbose) {\r\n            var details = this.connectionErrorDetailsToMessage(error, verbose);\r\n            // Status Code based Error\r\n            if (error.status === 401) {\r\n                if (details !== null) {\r\n                    return nls.localize(1, null, details);\r\n\r\n\r\n\r\n\r\n\r\n                }\r\n                return nls.localize(2, null);\r\n            }\r\n            // Return error details if present\r\n            if (details) {\r\n                return details;\r\n            }\r\n            // Fallback to HTTP Status and Code\r\n            if (error.status > 0 && error.statusText !== null) {\r\n                if (verbose && error.responseText !== null && error.responseText.length > 0) {\r\n                    return nls.localize(3, null, error.statusText, error.status, error.responseText);\r\n                }\r\n                return nls.localize(4, null, error.statusText, error.status);\r\n            }\r\n            // Finally its an Unknown Connection Error\r\n            if (verbose && error.responseText !== null && error.responseText.length > 0) {\r\n                return nls.localize(5, null, error.responseText);\r\n            }\r\n            return nls.localize(6, null);\r\n        };\r\n        return ConnectionError;\r\n    }());\r\n    exports.ConnectionError = ConnectionError;\r\n    // Bug: Can not subclass a JS Type. Do it manually (as done in WinJS.Class.derive)\r\n    objects.derive(Error, ConnectionError);\r\n    function xhrToErrorMessage(xhr, verbose) {\r\n        var ce = new ConnectionError(xhr);\r\n        if (verbose) {\r\n            return ce.verboseMessage;\r\n        }\r\n        else {\r\n            return ce.message;\r\n        }\r\n    }\r\n    function exceptionToErrorMessage(exception, verbose) {\r\n        if (exception.message) {\r\n            if (verbose && (exception.stack || exception.stacktrace)) {\r\n                return nls.localize(7, null, detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);\r\n            }\r\n            return detectSystemErrorMessage(exception);\r\n        }\r\n        return nls.localize(8, null);\r\n    }\r\n    function detectSystemErrorMessage(exception) {\r\n        // See https://nodejs.org/api/errors.html#errors_class_system_error\r\n        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\r\n            return nls.localize(9, null, exception.message);\r\n        }\r\n        return exception.message;\r\n    }\r\n    /**\r\n     * Tries to generate a human readable error message out of the error. If the verbose parameter\r\n     * is set to true, the error message will include stacktrace details if provided.\r\n     * @returns A string containing the error message.\r\n     */\r\n    function toErrorMessage(error, verbose) {\r\n        if (error === void 0) { error = null; }\r\n        if (verbose === void 0) { verbose = false; }\r\n        if (!error) {\r\n            return nls.localize(10, null);\r\n        }\r\n        if (Array.isArray(error)) {\r\n            var errors = arrays.coalesce(error);\r\n            var msg = toErrorMessage(errors[0], verbose);\r\n            if (errors.length > 1) {\r\n                return nls.localize(11, null, msg, errors.length);\r\n            }\r\n            return msg;\r\n        }\r\n        if (types.isString(error)) {\r\n            return error;\r\n        }\r\n        if (!types.isUndefinedOrNull(error.status)) {\r\n            return xhrToErrorMessage(error, verbose);\r\n        }\r\n        if (error.detail) {\r\n            var detail = error.detail;\r\n            if (detail.error) {\r\n                if (detail.error && !types.isUndefinedOrNull(detail.error.status)) {\r\n                    return xhrToErrorMessage(detail.error, verbose);\r\n                }\r\n                if (types.isArray(detail.error)) {\r\n                    for (var i = 0; i < detail.error.length; i++) {\r\n                        if (detail.error[i] && !types.isUndefinedOrNull(detail.error[i].status)) {\r\n                            return xhrToErrorMessage(detail.error[i], verbose);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return exceptionToErrorMessage(detail.error, verbose);\r\n                }\r\n            }\r\n            if (detail.exception) {\r\n                if (!types.isUndefinedOrNull(detail.exception.status)) {\r\n                    return xhrToErrorMessage(detail.exception, verbose);\r\n                }\r\n                return exceptionToErrorMessage(detail.exception, verbose);\r\n            }\r\n        }\r\n        if (error.stack) {\r\n            return exceptionToErrorMessage(error, verbose);\r\n        }\r\n        if (error.message) {\r\n            return error.message;\r\n        }\r\n        return nls.localize(12, null);\r\n    }\r\n    exports.toErrorMessage = toErrorMessage;\r\n    var canceledName = 'Canceled';\r\n    /**\r\n     * Checks if the given error is a promise in canceled state\r\n     */\r\n    function isPromiseCanceledError(error) {\r\n        return error instanceof Error && error.name === canceledName && error.message === canceledName;\r\n    }\r\n    exports.isPromiseCanceledError = isPromiseCanceledError;\r\n    /**\r\n     * Returns an error that signals cancellation.\r\n     */\r\n    function canceled() {\r\n        var error = new Error(canceledName);\r\n        error.name = error.message;\r\n        return error;\r\n    }\r\n    exports.canceled = canceled;\r\n    /**\r\n     * Returns an error that signals something is not implemented.\r\n     */\r\n    function notImplemented() {\r\n        return new Error(nls.localize(13, null));\r\n    }\r\n    exports.notImplemented = notImplemented;\r\n    function illegalArgument(name) {\r\n        if (name) {\r\n            return new Error(nls.localize(14, null, name));\r\n        }\r\n        else {\r\n            return new Error(nls.localize(15, null));\r\n        }\r\n    }\r\n    exports.illegalArgument = illegalArgument;\r\n    function illegalState(name) {\r\n        if (name) {\r\n            return new Error(nls.localize(16, null, name));\r\n        }\r\n        else {\r\n            return new Error(nls.localize(17, null));\r\n        }\r\n    }\r\n    exports.illegalState = illegalState;\r\n    function readonly(name) {\r\n        return name\r\n            ? new Error(\"readonly property '\" + name + \" cannot be changed'\")\r\n            : new Error('readonly property cannot be changed');\r\n    }\r\n    exports.readonly = readonly;\r\n    function loaderError(err) {\r\n        if (platform.isWeb) {\r\n            return new Error(nls.localize(18, null));\r\n        }\r\n        return new Error(nls.localize(19, null, JSON.stringify(err)));\r\n    }\r\n    exports.loaderError = loaderError;\r\n    function create(message, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var result = new Error(message);\r\n        if (types.isNumber(options.severity)) {\r\n            result.severity = options.severity;\r\n        }\r\n        if (options.actions) {\r\n            result.actions = options.actions;\r\n        }\r\n        return result;\r\n    }\r\n    exports.create = create;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndefine(\"vs/base/common/winjs.base\", ['./winjs.base.raw', 'vs/base/common/errors'], function (raw, __Errors__) {\n\t'use strict';\n\n\tvar winjs = raw;\n\n\tvar outstandingPromiseErrors = {};\n\tfunction promiseErrorHandler(e) {\n\n\t\t//\n\t\t// e.detail looks like: { exception, error, promise, handler, id, parent }\n\t\t//\n\t\tvar details = e.detail;\n\t\tvar id = details.id;\n\n\t\t// If the error has a parent promise then this is not the origination of the\n\t\t//  error so we check if it has a handler, and if so we mark that the error\n\t\t//  was handled by removing it from outstandingPromiseErrors\n\t\t//\n\t\tif (details.parent) {\n\t\t\tif (details.handler && outstandingPromiseErrors) {\n\t\t\t\tdelete outstandingPromiseErrors[id];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Indicate that this error was originated and needs to be handled\n\t\toutstandingPromiseErrors[id] = details;\n\n\t\t// The first time the queue fills up this iteration, schedule a timeout to\n\t\t// check if any errors are still unhandled.\n\t\tif (Object.keys(outstandingPromiseErrors).length === 1) {\n\t\t\tsetTimeout(function () {\n\t\t\t\tvar errors = outstandingPromiseErrors;\n\t\t\t\toutstandingPromiseErrors = {};\n\t\t\t\tObject.keys(errors).forEach(function (errorId) {\n\t\t\t\t\tvar error = errors[errorId];\n\t\t\t\t\tif(error.exception) {\n\t\t\t\t\t\t__Errors__.onUnexpectedError(error.exception);\n\t\t\t\t\t} else if(error.error) {\n\t\t\t\t\t\t__Errors__.onUnexpectedError(error.error);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(\"WARNING: Promise with no error callback:\" + error.id);\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t\tif(error.exception) {\n\t\t\t\t\t\tconsole.log(error.exception.stack);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\twinjs.Promise.addEventListener(\"error\", promiseErrorHandler);\n\n\n\tfunction decoratePromise(promise, completeCallback, errorCallback) {\n\t\tvar pc, pe, pp;\n\n\t\tvar resultPromise = new winjs.Promise(\n\t\t\tfunction (c, e, p) {\n\t\t\t\tpc = c;\n\t\t\t\tpe = e;\n\t\t\t\tpp = p;\n\t\t\t}, function () {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t);\n\n\t\tpromise.then(function (r) {\n\t\t\tif (completeCallback) {\n\t\t\t\tcompleteCallback(r);\n\t\t\t}\n\t\t\tpc(r);\n\t\t}, function (e) {\n\t\t\tif (errorCallback) {\n\t\t\t\terrorCallback(e);\n\t\t\t}\n\t\t\tpe(e);\n\t\t}, pp);\n\n\t\treturn resultPromise;\n\t}\n\n\treturn {\n\t\tdecoratePromise: decoratePromise,\n\t\tClass: winjs.Class,\n\t\txhr: winjs.xhr,\n\t\tPromise: winjs.Promise,\n\t\tTPromise: winjs.Promise,\n\t\tPPromise: winjs.Promise,\n\t\tUtilities: winjs.Utilities\n\t};\n});\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/base/common/worker/simpleWorker\", [\"require\", \"exports\", 'vs/base/common/errors', 'vs/base/common/lifecycle', 'vs/base/common/winjs.base'], function (require, exports, errors_1, lifecycle_1, winjs_base_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var INITIALIZE = '$initialize';\r\n    var SimpleWorkerProtocol = (function () {\r\n        function SimpleWorkerProtocol(handler) {\r\n            this._workerId = -1;\r\n            this._handler = handler;\r\n            this._lastSentReq = 0;\r\n            this._pendingReplies = Object.create(null);\r\n        }\r\n        SimpleWorkerProtocol.prototype.setWorkerId = function (workerId) {\r\n            this._workerId = workerId;\r\n        };\r\n        SimpleWorkerProtocol.prototype.sendMessage = function (method, args) {\r\n            var req = String(++this._lastSentReq);\r\n            var reply = {\r\n                c: null,\r\n                e: null\r\n            };\r\n            var result = new winjs_base_1.TPromise(function (c, e, p) {\r\n                reply.c = c;\r\n                reply.e = e;\r\n            }, function () {\r\n                // Cancel not supported\r\n            });\r\n            this._pendingReplies[req] = reply;\r\n            this._send({\r\n                vsWorker: this._workerId,\r\n                req: req,\r\n                method: method,\r\n                args: args\r\n            });\r\n            return result;\r\n        };\r\n        SimpleWorkerProtocol.prototype.handleMessage = function (serializedMessage) {\r\n            var message;\r\n            try {\r\n                message = JSON.parse(serializedMessage);\r\n            }\r\n            catch (e) {\r\n            }\r\n            if (!message.vsWorker) {\r\n                return;\r\n            }\r\n            if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\r\n                return;\r\n            }\r\n            this._handleMessage(message);\r\n        };\r\n        SimpleWorkerProtocol.prototype._handleMessage = function (msg) {\r\n            var _this = this;\r\n            if (msg.seq) {\r\n                var replyMessage = msg;\r\n                if (!this._pendingReplies[replyMessage.seq]) {\r\n                    console.warn('Got reply to unknown seq');\r\n                    return;\r\n                }\r\n                var reply = this._pendingReplies[replyMessage.seq];\r\n                delete this._pendingReplies[replyMessage.seq];\r\n                if (replyMessage.err) {\r\n                    var err = replyMessage.err;\r\n                    if (replyMessage.err.$isError) {\r\n                        err = new Error();\r\n                        err.name = replyMessage.err.name;\r\n                        err.message = replyMessage.err.message;\r\n                        err.stack = replyMessage.err.stack;\r\n                    }\r\n                    reply.e(err);\r\n                    return;\r\n                }\r\n                reply.c(replyMessage.res);\r\n                return;\r\n            }\r\n            var requestMessage = msg;\r\n            var req = requestMessage.req;\r\n            var result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\r\n            result.then(function (r) {\r\n                _this._send({\r\n                    vsWorker: _this._workerId,\r\n                    seq: req,\r\n                    res: r,\r\n                    err: undefined\r\n                });\r\n            }, function (e) {\r\n                _this._send({\r\n                    vsWorker: _this._workerId,\r\n                    seq: req,\r\n                    res: undefined,\r\n                    err: errors_1.transformErrorForSerialization(e)\r\n                });\r\n            });\r\n        };\r\n        SimpleWorkerProtocol.prototype._send = function (msg) {\r\n            var strMsg = JSON.stringify(msg);\r\n            // console.log('SENDING: ' + strMsg);\r\n            this._handler.sendMessage(strMsg);\r\n        };\r\n        return SimpleWorkerProtocol;\r\n    }());\r\n    /**\r\n     * Main thread side\r\n     */\r\n    var SimpleWorkerClient = (function (_super) {\r\n        __extends(SimpleWorkerClient, _super);\r\n        function SimpleWorkerClient(workerFactory, moduleId, ctor) {\r\n            var _this = this;\r\n            _super.call(this);\r\n            this._lastRequestTimestamp = -1;\r\n            this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', function (msg) {\r\n                _this._protocol.handleMessage(msg);\r\n            }));\r\n            this._protocol = new SimpleWorkerProtocol({\r\n                sendMessage: function (msg) {\r\n                    _this._worker.postMessage(msg);\r\n                },\r\n                handleMessage: function (method, args) {\r\n                    // Intentionally not supporting worker -> main requests\r\n                    return winjs_base_1.TPromise.as(null);\r\n                }\r\n            });\r\n            this._protocol.setWorkerId(this._worker.getId());\r\n            // Gather loader configuration\r\n            var loaderConfiguration = null;\r\n            var globalRequire = window.require;\r\n            if (typeof globalRequire.getConfig === 'function') {\r\n                // Get the configuration from the Monaco AMD Loader\r\n                loaderConfiguration = globalRequire.getConfig();\r\n            }\r\n            else if (typeof window.requirejs !== 'undefined') {\r\n                // Get the configuration from requirejs\r\n                loaderConfiguration = window.requirejs.s.contexts._.config;\r\n            }\r\n            var lazyProxyFulfill = null;\r\n            var lazyProxyReject = null;\r\n            this._lazyProxy = new winjs_base_1.TPromise(function (c, e, p) {\r\n                lazyProxyFulfill = c;\r\n                lazyProxyReject = e;\r\n            }, function () { });\r\n            // Send initialize message\r\n            this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\r\n                this._worker.getId(),\r\n                moduleId,\r\n                loaderConfiguration\r\n            ]);\r\n            this._onModuleLoaded.then(function (availableMethods) {\r\n                var proxy = {};\r\n                for (var i = 0; i < availableMethods.length; i++) {\r\n                    proxy[availableMethods[i]] = createProxyMethod(availableMethods[i], proxyMethodRequest);\r\n                }\r\n                lazyProxyFulfill(proxy);\r\n            }, function (e) {\r\n                lazyProxyReject(e);\r\n                _this._onError('Worker failed to load ' + moduleId, e);\r\n            });\r\n            // Create proxy to loaded code\r\n            var proxyMethodRequest = function (method, args) {\r\n                return _this._request(method, args);\r\n            };\r\n            var createProxyMethod = function (method, proxyMethodRequest) {\r\n                return function () {\r\n                    var args = Array.prototype.slice.call(arguments, 0);\r\n                    return proxyMethodRequest(method, args);\r\n                };\r\n            };\r\n            this._proxy = {};\r\n            if (ctor) {\r\n                // console.warn('deprecated');\r\n                for (var prop in ctor.prototype) {\r\n                    if (ctor.prototype.hasOwnProperty(prop)) {\r\n                        if (typeof ctor.prototype[prop] === 'function') {\r\n                            this._proxy[prop] = createProxyMethod(prop, proxyMethodRequest);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        SimpleWorkerClient.prototype.get = function () {\r\n            return this._proxy;\r\n        };\r\n        SimpleWorkerClient.prototype.getProxyObject = function () {\r\n            return this._lazyProxy;\r\n        };\r\n        SimpleWorkerClient.prototype.getLastRequestTimestamp = function () {\r\n            return this._lastRequestTimestamp;\r\n        };\r\n        SimpleWorkerClient.prototype._request = function (method, args) {\r\n            var _this = this;\r\n            return new winjs_base_1.TPromise(function (c, e, p) {\r\n                _this._onModuleLoaded.then(function () {\r\n                    _this._lastRequestTimestamp = Date.now();\r\n                    _this._protocol.sendMessage(method, args).then(c, e);\r\n                }, e);\r\n            }, function () {\r\n                // Cancel intentionally not supported\r\n            });\r\n        };\r\n        SimpleWorkerClient.prototype._onError = function (message, error) {\r\n            console.error(message);\r\n            console.info(error);\r\n        };\r\n        return SimpleWorkerClient;\r\n    }(lifecycle_1.Disposable));\r\n    exports.SimpleWorkerClient = SimpleWorkerClient;\r\n    /**\r\n     * Worker side\r\n     */\r\n    var SimpleWorkerServer = (function () {\r\n        function SimpleWorkerServer(postSerializedMessage) {\r\n            var _this = this;\r\n            this._protocol = new SimpleWorkerProtocol({\r\n                sendMessage: function (msg) {\r\n                    postSerializedMessage(msg);\r\n                },\r\n                handleMessage: function (method, args) { return _this._handleMessage(method, args); }\r\n            });\r\n        }\r\n        SimpleWorkerServer.prototype.onmessage = function (msg) {\r\n            this._protocol.handleMessage(msg);\r\n        };\r\n        SimpleWorkerServer.prototype._handleMessage = function (method, args) {\r\n            if (method === INITIALIZE) {\r\n                return this.initialize(args[0], args[1], args[2]);\r\n            }\r\n            if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\r\n                return winjs_base_1.TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));\r\n            }\r\n            try {\r\n                return winjs_base_1.TPromise.as(this._requestHandler[method].apply(this._requestHandler, args));\r\n            }\r\n            catch (e) {\r\n                return winjs_base_1.TPromise.wrapError(e);\r\n            }\r\n        };\r\n        SimpleWorkerServer.prototype.initialize = function (workerId, moduleId, loaderConfig) {\r\n            var _this = this;\r\n            this._protocol.setWorkerId(workerId);\r\n            // TODO@Alex: share this code with workerServer\r\n            if (loaderConfig) {\r\n                // Remove 'baseUrl', handling it is beyond scope for now\r\n                if (typeof loaderConfig.baseUrl !== 'undefined') {\r\n                    delete loaderConfig['baseUrl'];\r\n                }\r\n                if (typeof loaderConfig.paths !== 'undefined') {\r\n                    if (typeof loaderConfig.paths.vs !== 'undefined') {\r\n                        delete loaderConfig.paths['vs'];\r\n                    }\r\n                }\r\n                var nlsConfig_1 = loaderConfig['vs/nls'];\r\n                // We need to have pseudo translation\r\n                if (nlsConfig_1 && nlsConfig_1.pseudo) {\r\n                    require(['vs/nls'], function (nlsPlugin) {\r\n                        nlsPlugin.setPseudoTranslation(nlsConfig_1.pseudo);\r\n                    });\r\n                }\r\n                // Since this is in a web worker, enable catching errors\r\n                loaderConfig.catchError = true;\r\n                self.require.config(loaderConfig);\r\n            }\r\n            var cc;\r\n            var ee;\r\n            var r = new winjs_base_1.TPromise(function (c, e, p) {\r\n                cc = c;\r\n                ee = e;\r\n            });\r\n            require([moduleId], function () {\r\n                var result = [];\r\n                for (var _i = 0; _i < arguments.length; _i++) {\r\n                    result[_i - 0] = arguments[_i];\r\n                }\r\n                var handlerModule = result[0];\r\n                _this._requestHandler = handlerModule.create();\r\n                var methods = [];\r\n                for (var prop in _this._requestHandler) {\r\n                    if (typeof _this._requestHandler[prop] === 'function') {\r\n                        methods.push(prop);\r\n                    }\r\n                }\r\n                cc(methods);\r\n            }, ee);\r\n            return r;\r\n        };\r\n        return SimpleWorkerServer;\r\n    }());\r\n    exports.SimpleWorkerServer = SimpleWorkerServer;\r\n    /**\r\n     * Called on the worker side\r\n     */\r\n    function create(postMessage) {\r\n        return new SimpleWorkerServer(postMessage);\r\n    }\r\n    exports.create = create;\r\n});\r\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default ist zero).\n */\nexport function tail<T>(array: T[], n: number = 0): T {\n\treturn array[array.length - (1 + n)];\n}\n\n/**\n * Iterates the provided array and allows to remove\n * elements while iterating.\n */\nexport function forEach<T>(array: T[], callback: (element: T, remove: Function) => void): void {\n\tfor (var i = 0, len = array.length; i < len; i++) {\n\t\tcallback(array[i], function() {\n\t\t\tarray.splice(i, 1);\n\t\t\ti--; len--;\n\t\t});\n\t}\n}\n\nexport function equals<T>(one: T[], other: T[], itemEquals: (a: T, b: T) => boolean): boolean {\n\tif (one.length !== other.length) {\n\t\treturn false;\n\t}\n\n\tfor (var i = 0, len = one.length; i < len; i++) {\n\t\tif (!itemEquals(one[i], other[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nexport function binarySearch<T>(array: T[], key: T, comparator: (op1: T, op2: T) => number): number {\n\tlet low = 0,\n\t\thigh = array.length - 1;\n\n\twhile (low <= high) {\n\t\tlet mid = ((low + high) / 2) | 0;\n\t\tlet comp = comparator(array[mid], key);\n\t\tif (comp < 0) {\n\t\t\tlow = mid + 1;\n\t\t} else if (comp > 0) {\n\t\t\thigh = mid - 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn -(low + 1);\n}\n\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirst<T>(array: T[], p: (x: T) => boolean): number {\n\tlet low = 0, high = array.length;\n\tif (high === 0) {\n\t\treturn 0; // no children\n\t}\n\twhile (low < high) {\n\t\tlet mid = Math.floor((low + high) / 2);\n\t\tif (p(array[mid])) {\n\t\t\thigh = mid;\n\t\t} else {\n\t\t\tlow = mid + 1;\n\t\t}\n\t}\n\treturn low;\n}\n\nexport function merge<T>(arrays: T[][], hashFn?: (element: T) => string): T[] {\n\tconst result = new Array<T>();\n\tif (!hashFn) {\n\t\tfor (let i = 0, len = arrays.length; i < len; i++) {\n\t\t\tresult.push.apply(result, arrays[i]);\n\t\t}\n\t} else {\n\t\tconst map: { [k: string]: boolean } = {};\n\t\tfor (let i = 0; i < arrays.length; i++) {\n\t\t\tfor (let j = 0; j < arrays[i].length; j++) {\n\t\t\t\tlet element = arrays[i][j],\n\t\t\t\t\thash = hashFn(element);\n\n\t\t\t\tif (!map.hasOwnProperty(hash)) {\n\t\t\t\t\tmap[hash] = true;\n\t\t\t\t\tresult.push(element);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * @returns a new array with all undefined or null values removed. The original array is not modified at all.\n */\nexport function coalesce<T>(array: T[]): T[] {\n\tif (!array) {\n\t\treturn array;\n\t}\n\n\treturn array.filter(e => !!e);\n}\n\n/**\n * @returns true if the given item is contained in the array.\n */\nexport function contains<T>(array: T[], item: T): boolean {\n\treturn array.indexOf(item) >= 0;\n}\n\n/**\n * Swaps the elements in the array for the provided positions.\n */\nexport function swap(array: any[], pos1: number, pos2: number): void {\n\tconst element1 = array[pos1];\n\tconst element2 = array[pos2];\n\n\tarray[pos1] = element2;\n\tarray[pos2] = element1;\n}\n\n/**\n * Moves the element in the array for the provided positions.\n */\nexport function move(array: any[], from: number, to: number): void {\n\tarray.splice(to, 0, array.splice(from, 1)[0]);\n}\n\n/**\n * @returns {{false}} if the provided object is an array\n * \tand not empty.\n */\nexport function isFalsyOrEmpty(obj: any): boolean {\n\treturn !Array.isArray(obj) || (<Array<any>>obj).length === 0;\n}\n\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equalness by returning a unique string for each.\n */\nexport function distinct<T>(array: T[], keyFn?: (t: T) => string): T[] {\n\tif (!keyFn) {\n\t\treturn array.filter((element, position) => {\n\t\t\treturn array.indexOf(element) === position;\n\t\t});\n\t}\n\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\treturn array.filter((elem) => {\n\t\tconst key = keyFn(elem);\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\n\t\treturn true;\n\t});\n}\n\nexport function uniqueFilter<T>(keyFn: (t: T) => string): (t: T) => boolean {\n\tconst seen: { [key: string]: boolean; } = Object.create(null);\n\n\treturn element => {\n\t\tconst key = keyFn(element);\n\n\t\tif (seen[key]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tseen[key] = true;\n\t\treturn true;\n\t};\n}\n\nexport function firstIndex<T>(array: T[], fn: (item: T) => boolean): number {\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst element = array[i];\n\n\t\tif (fn(element)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nexport function first<T>(array: T[], fn: (item: T) => boolean, notFoundValue: T = null): T {\n\tconst index = firstIndex(array, fn);\n\treturn index < 0 ? notFoundValue : array[index];\n}\n\nexport function commonPrefixLength<T>(one: T[], other: T[], equals: (a: T, b: T) => boolean = (a, b) => a === b): number {\n\tlet result = 0;\n\n\tfor (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {\n\t\tresult++;\n\t}\n\n\treturn result;\n}\n\nexport function flatten<T>(arr: T[][]): T[] {\n\treturn arr.reduce((r, v) => r.concat(v), []);\n}\n\nexport function fill<T>(num: number, valueFn: () => T, arr: T[] = []): T[] {\n\tfor (let i = 0; i < num; i++) {\n\t\tarr[i] = valueFn();\n\t}\n\n\treturn arr;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nexport interface Key {\n\ttoString():string;\n}\n\nexport interface Entry<K, T> {\n\tnext?: Entry<K, T>;\n\tprev?: Entry<K, T>;\n\tkey: K;\n\tvalue: T;\n}\n\n/**\n * A simple map to store value by a key object. Key can be any object that has toString() function to get\n * string value of the key.\n */\nexport class SimpleMap<K extends Key, T> {\n\n\tprotected map: { [key: string]: Entry<K, T> };\n\tprotected _size: number;\n\n\tconstructor() {\n\t\tthis.map = Object.create(null);\n\t\tthis._size = 0;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\n\tpublic get(k: K): T {\n\t\tconst value = this.peek(k);\n\n\t\treturn value ? value : null;\n\t}\n\n\tpublic keys(): K[] {\n\t\tvar keys: K[] = [];\n\t\tfor (let key in this.map) {\n\t\t\tkeys.push(this.map[key].key);\n\t\t}\n\t\treturn keys;\n\t}\n\n\tpublic entries(): Entry<K, T>[] {\n\t\tvar entries: Entry<K, T>[] = [];\n\t\tfor (let key in this.map) {\n\t\t\tentries.push(this.map[key]);\n\t\t}\n\t\treturn entries;\n\t}\n\n\tpublic set(k: K, t: T): boolean {\n\t\tif (this.get(k)) {\n\t\t\treturn false; // already present!\n\t\t}\n\n\t\tthis.push(k, t);\n\n\t\treturn true;\n\t}\n\n\tpublic delete(k: K): T {\n\t\tlet value:T= this.get(k);\n\t\tif (value) {\n\t\t\tthis.pop(k);\n\t\t\treturn value;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic has(k: K): boolean {\n\t\treturn !!this.get(k);\n\t}\n\n\tpublic clear(): void {\n\t\tthis.map = Object.create(null);\n\t\tthis._size = 0;\n\t}\n\n\tprotected push(key: K, value: T): void {\n\t\tconst entry: Entry<K, T> = { key, value };\n\t\tthis.map[key.toString()] = entry;\n\t\tthis._size++;\n\t}\n\n\tprotected pop(k: K): void {\n\t\tdelete this.map[k.toString()];\n\t\tthis._size--;\n\t}\n\n\tprotected peek(k: K): T {\n\t\tconst entry= this.map[k.toString()];\n\t\treturn entry ? entry.value : null;\n\t}\n}\n\n/**\n * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,\n * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,\n * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).\n */\nexport class LinkedMap<T> {\n\tprotected map: { [key: string]: Entry<string, T> };\n\tprivate head: Entry<string, T>;\n\tprivate tail: Entry<string, T>;\n\tprivate _size: number;\n\tprivate ratio: number;\n\n\tconstructor(private limit = Number.MAX_VALUE, ratio = 1) {\n\t\tthis.map = Object.create(null);\n\t\tthis._size = 0;\n\t\tthis.ratio = limit * ratio;\n\t}\n\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\n\tpublic set(key: string, value: T): boolean {\n\t\tif (this.map[key]) {\n\t\t\treturn false; // already present!\n\t\t}\n\n\t\tconst entry: Entry<string, T> = { key, value };\n\t\tthis.push(entry);\n\n\t\tif (this._size > this.limit) {\n\t\t\tthis.trim();\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic get(key: string): T {\n\t\tconst entry = this.map[key];\n\n\t\treturn entry ? entry.value : null;\n\t}\n\n\tpublic delete(key: string): T {\n\t\tconst entry = this.map[key];\n\n\t\tif (entry) {\n\t\t\tthis.map[key] = void 0;\n\t\t\tthis._size--;\n\n\t\t\tif (entry.next) {\n\t\t\t\tentry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]\n\t\t\t} else {\n\t\t\t\tthis.head = entry.prev; // [A]-[x] = [A]\n\t\t\t}\n\n\t\t\tif (entry.prev) {\n\t\t\t\tentry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]\n\t\t\t} else {\n\t\t\t\tthis.tail = entry.next; // [x]-[A] = [A]\n\t\t\t}\n\n\t\t\treturn entry.value;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic has(key: string): boolean {\n\t\treturn !!this.map[key];\n\t}\n\n\tpublic clear(): void {\n\t\tthis.map = Object.create(null);\n\t\tthis._size = 0;\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\t}\n\n\tprotected push(entry: Entry<string, T>): void {\n\t\tif (this.head) {\n\t\t\t// [A]-[B] = [A]-[B]->[X]\n\t\t\tentry.prev = this.head;\n\t\t\tthis.head.next = entry;\n\t\t}\n\n\t\tif (!this.tail) {\n\t\t\tthis.tail = entry;\n\t\t}\n\n\t\tthis.head = entry;\n\n\t\tthis.map[entry.key] = entry;\n\t\tthis._size++;\n\t}\n\n\tprivate trim(): void {\n\t\tif (this.tail) {\n\n\t\t\t// Remove all elements until ratio is reached\n\t\t\tif (this.ratio < this.limit) {\n\t\t\t\tlet index = 0;\n\t\t\t\tlet current = this.tail;\n\t\t\t\twhile (current.next) {\n\n\t\t\t\t\t// Remove the entry\n\t\t\t\t\tthis.map[current.key] = void 0;\n\t\t\t\t\tthis._size--;\n\n\t\t\t\t\t// if we reached the element that overflows our ratio condition\n\t\t\t\t\t// make its next element the new tail of the Map and adjust the size\n\t\t\t\t\tif (index === this.ratio) {\n\t\t\t\t\t\tthis.tail = current.next;\n\t\t\t\t\t\tthis.tail.prev = null;\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Move on\n\t\t\t\t\tcurrent = current.next;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Just remove the tail element\n\t\t\telse {\n\t\t\t\tthis.map[this.tail.key] = void 0;\n\t\t\t\tthis._size--;\n\n\t\t\t\t// [x]-[B] = [B]\n\t\t\t\tthis.tail = this.tail.next;\n\t\t\t\tthis.tail.prev = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * A subclass of Map<T> that makes an entry the MRU entry as soon\n * as it is being accessed. In combination with the limit for the\n * maximum number of elements in the cache, it helps to remove those\n * entries from the cache that are LRU.\n */\nexport class LRUCache<T> extends LinkedMap<T> {\n\n\tconstructor(limit: number) {\n\t\tsuper(limit);\n\t}\n\n\tpublic get(key: string): T {\n\n\t\t// Upon access of an entry, make it the head of\n\t\t// the linked map so that it is the MRU element\n\t\tconst entry = this.map[key];\n\t\tif (entry) {\n\t\t\tthis.delete(key);\n\t\t\tthis.push(entry);\n\n\t\t\treturn entry.value;\n\t\t}\n\n\n\t\treturn null;\n\t}\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n// --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---\n\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isRootUser = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isQunit = false;\nlet _locale = undefined;\nlet _language = undefined;\n\ninterface NLSConfig {\n\tlocale: string;\n\tavailableLanguages: { [key: string]: string; };\n}\n\ninterface INodeProcess {\n\tplatform: string;\n\tenv: { [key: string]: string; };\n\tgetuid(): number;\n}\ndeclare let process: INodeProcess;\ndeclare let global: any;\n\ninterface INavigator {\n\tuserAgent: string;\n\tlanguage: string;\n}\ndeclare let navigator: INavigator;\ndeclare let self: any;\n\nexport const LANGUAGE_DEFAULT = 'en';\n\n// OS detection\nif (typeof process === 'object') {\n\t_isWindows = (process.platform === 'win32');\n\t_isMacintosh = (process.platform === 'darwin');\n\t_isLinux = (process.platform === 'linux');\n\t_isRootUser = !_isWindows && (process.getuid() === 0);\n\tlet vscode_nls_config = process.env['VSCODE_NLS_CONFIG'];\n\tif (vscode_nls_config) {\n\t\ttry {\n\t\t\tlet nlsConfig:NLSConfig = JSON.parse(vscode_nls_config);\n\t\t\tlet resolved = nlsConfig.availableLanguages['*'];\n\t\t\t_locale = nlsConfig.locale;\n\t\t\t// VSCode's default language is 'en'\n\t\t\t_language = resolved ? resolved : LANGUAGE_DEFAULT;\n\t\t} catch (e) {\n\t\t}\n\t}\n\t_isNative = true;\n} else if (typeof navigator === 'object') {\n\tlet userAgent = navigator.userAgent;\n\t_isWindows = userAgent.indexOf('Windows') >= 0;\n\t_isMacintosh = userAgent.indexOf('Macintosh') >= 0;\n\t_isLinux = userAgent.indexOf('Linux') >= 0;\n\t_isWeb = true;\n\t_locale = navigator.language;\n\t_language = _locale;\n\t_isQunit = !!(<any>self).QUnit;\n}\n\nexport enum Platform {\n\tWeb,\n\tMac,\n\tLinux,\n\tWindows\n}\n\nexport let _platform:Platform = Platform.Web;\nif (_isNative) {\n\tif (_isMacintosh) {\n\t\t_platform = Platform.Mac;\n\t} else if (_isWindows) {\n\t\t_platform = Platform.Windows;\n\t} else if (_isLinux) {\n\t\t_platform = Platform.Linux;\n\t}\n}\n\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isRootUser = _isRootUser;\nexport const isNative = _isNative;\nexport const isWeb = _isWeb;\nexport const isQunit = _isQunit;\nexport const platform = _platform;\n\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n\n/**\n * The OS locale or the locale specified by --locale. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese). The UI is not necessarily shown in the provided locale.\n */\nexport const locale = _locale;\n\nexport interface TimeoutToken {\n}\n\nexport interface IntervalToken {\n}\n\ninterface IGlobals {\n\tWorker?: any;\n\tsetTimeout(callback: (...args: any[]) => void, delay: number, ...args: any[]): TimeoutToken;\n\tclearTimeout(token: TimeoutToken): void;\n\n\tsetInterval(callback: (...args: any[]) => void, delay: number, ...args: any[]): IntervalToken;\n\tclearInterval(token: IntervalToken);\n}\n\nconst _globals = <IGlobals> (typeof self === 'object' ? self : global);\nexport const globals: any = _globals;\n\nexport function hasWebWorkerSupport(): boolean {\n\treturn typeof _globals.Worker !== 'undefined';\n}\nexport const setTimeout = _globals.setTimeout.bind(_globals);\nexport const clearTimeout = _globals.clearTimeout.bind(_globals);\n\nexport const setInterval = _globals.setInterval.bind(_globals);\nexport const clearInterval = _globals.clearInterval.bind(_globals);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {LinkedMap} from 'vs/base/common/map';\n\n/**\n * The empty string.\n */\nexport const empty = '';\n\n/**\n * @returns the provided number with the given number of preceding zeros.\n */\nexport function pad(n: number, l: number, char: string = '0'): string {\n\tlet str = '' + n;\n\tlet r = [str];\n\n\tfor (let i = str.length; i < l; i++) {\n\t\tr.push(char);\n\t}\n\n\treturn r.reverse().join('');\n}\n\nconst _formatRegexp = /{(\\d+)}/g;\n\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value: string, ...args: any[]): string {\n\tif (args.length === 0) {\n\t\treturn value;\n\t}\n\treturn value.replace(_formatRegexp, function(match, group) {\n\t\tlet idx = parseInt(group, 10);\n\t\treturn isNaN(idx) || idx < 0 || idx >= args.length ?\n\t\t\tmatch :\n\t\t\targs[idx];\n\t});\n}\n\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html: string): string {\n\treturn html.replace(/[<|>|&]/g, function(match) {\n\t\tswitch (match) {\n\t\t\tcase '<': return '&lt;';\n\t\t\tcase '>': return '&gt;';\n\t\t\tcase '&': return '&amp;';\n\t\t\tdefault: return match;\n\t\t}\n\t});\n}\n\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value: string): string {\n\treturn value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n}\n\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack: string, needle: string = ' '): string {\n\tlet trimmed = ltrim(haystack, needle);\n\treturn rtrim(trimmed, needle);\n}\n\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack?: string, needle?: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tlet needleLen = needle.length;\n\tif (needleLen === 0 || haystack.length === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = 0,\n\t\tidx = -1;\n\n\twhile ((idx = haystack.indexOf(needle, offset)) === offset) {\n\t\toffset = offset + needleLen;\n\t}\n\treturn haystack.substring(offset);\n}\n\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack?: string, needle?: string): string {\n\tif (!haystack || !needle) {\n\t\treturn haystack;\n\t}\n\n\tlet needleLen = needle.length,\n\t\thaystackLen = haystack.length;\n\n\tif (needleLen === 0 || haystackLen === 0) {\n\t\treturn haystack;\n\t}\n\n\tlet offset = haystackLen,\n\t\tidx = -1;\n\n\twhile (true) {\n\t\tidx = haystack.lastIndexOf(needle, offset - 1);\n\t\tif (idx === -1 || idx + needleLen !== offset) {\n\t\t\tbreak;\n\t\t}\n\t\tif (idx === 0) {\n\t\t\treturn '';\n\t\t}\n\t\toffset = idx;\n\t}\n\n\treturn haystack.substring(0, offset);\n}\n\nexport function convertSimple2RegExpPattern(pattern: string): string {\n\treturn pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\n\nexport function stripWildcards(pattern: string): string {\n\treturn pattern.replace(/\\*/g, '');\n}\n\n/**\n * Determines if haystack starts with needle.\n */\nexport function startsWith(haystack: string, needle: string): boolean {\n\tif (haystack.length < needle.length) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < needle.length; i++) {\n\t\tif (haystack[i] !== needle[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Determines if haystack ends with needle.\n */\nexport function endsWith(haystack: string, needle: string): boolean {\n\tlet diff = haystack.length - needle.length;\n\tif (diff > 0) {\n\t\treturn haystack.lastIndexOf(needle) === diff;\n\t} else if (diff === 0) {\n\t\treturn haystack === needle;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function createRegExp(searchString: string, isRegex: boolean, matchCase: boolean, wholeWord: boolean, global:boolean): RegExp {\n\tif (searchString === '') {\n\t\tthrow new Error('Cannot create regex from empty string');\n\t}\n\tif (!isRegex) {\n\t\tsearchString = searchString.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&');\n\t}\n\tif (wholeWord) {\n\t\tif (!/\\B/.test(searchString.charAt(0))) {\n\t\t\tsearchString = '\\\\b' + searchString;\n\t\t}\n\t\tif (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n\t\t\tsearchString = searchString + '\\\\b';\n\t\t}\n\t}\n\tlet modifiers = '';\n\tif (global) {\n\t\tmodifiers += 'g';\n\t}\n\tif (!matchCase) {\n\t\tmodifiers += 'i';\n\t}\n\n\treturn new RegExp(searchString, modifiers);\n}\n\n/**\n * Create a regular expression only if it is valid and it doesn't lead to endless loop.\n */\nexport function createSafeRegExp(searchString:string, isRegex:boolean, matchCase:boolean, wholeWord:boolean): RegExp {\n\t\tif (searchString === '') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Try to create a RegExp out of the params\n\t\tvar regex:RegExp = null;\n\t\ttry {\n\t\t\tregex = createRegExp(searchString, isRegex, matchCase, wholeWord, true);\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Guard against endless loop RegExps & wrap around try-catch as very long regexes produce an exception when executed the first time\n\t\ttry {\n\t\t\tif (regExpLeadsToEndlessLoop(regex)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn regex;\n\t}\n\nexport function regExpLeadsToEndlessLoop(regexp: RegExp): boolean {\n\t// Exit early if it's one of these special cases which are meant to match\n\t// against an empty string\n\tif (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {\n\t\treturn false;\n\t}\n\n\t// We check against an empty string. If the regular expression doesn't advance\n\t// (e.g. ends in an endless loop) it will match an empty string.\n\tlet match = regexp.exec('');\n\treturn (match && <any>regexp.lastIndex === 0);\n}\n\n/**\n * The normalize() method returns the Unicode Normalization Form of a given string. The form will be\n * the Normalization Form Canonical Composition.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}\n */\nexport let canNormalize = typeof ((<any>'').normalize) === 'function';\nconst nonAsciiCharactersPattern = /[^\\u0000-\\u0080]/;\nconst normalizedCache = new LinkedMap<string>(10000); // bounded to 10000 elements\nexport function normalizeNFC(str: string): string {\n\tif (!canNormalize || !str) {\n\t\treturn str;\n\t}\n\n\tconst cached = normalizedCache.get(str);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tlet res: string;\n\tif (nonAsciiCharactersPattern.test(str)) {\n\t\tres = (<any>str).normalize('NFC');\n\t} else {\n\t\tres = str;\n\t}\n\n\t// Use the cache for fast lookup\n\tnormalizedCache.set(str, res);\n\n\treturn res;\n}\n\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str: string): number {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str: string): string {\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\tif (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\n\t\t\treturn str.substring(0, i);\n\t\t}\n\t}\n\treturn str;\n}\n\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str: string, startIndex: number = str.length - 1): number {\n\tfor (let i = startIndex; i >= 0; i--) {\n\t\tif (str.charAt(i) !== ' ' && str.charAt(i) !== '\\t') {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\nexport function localeCompare(strA: string, strB: string): number {\n\treturn strA.localeCompare(strB);\n}\n\nfunction isAsciiChar(code: number): boolean {\n\treturn (code >= 97 && code <= 122) || (code >= 65 && code <= 90);\n}\n\nexport function equalsIgnoreCase(a: string, b: string): boolean {\n\n\tlet len1 = a.length,\n\t\tlen2 = b.length;\n\n\tif (len1 !== len2) {\n\t\treturn false;\n\t}\n\n\tfor (let i = 0; i < len1; i++) {\n\n\t\tlet codeA = a.charCodeAt(i),\n\t\t\tcodeB = b.charCodeAt(i);\n\n\t\tif (codeA === codeB) {\n\t\t\tcontinue;\n\n\t\t} else if (isAsciiChar(codeA) && isAsciiChar(codeB)) {\n\t\t\tlet diff = Math.abs(codeA - codeB);\n\t\t\tif (diff !== 0 && diff !== 32) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (String.fromCharCode(codeA).toLocaleLowerCase() !== String.fromCharCode(codeB).toLocaleLowerCase()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a: string, b: string): number {\n\n\tlet i: number,\n\t\tlen = Math.min(a.length, b.length);\n\n\tlet aLastIndex = a.length - 1;\n\tlet bLastIndex = b.length - 1;\n\n\tfor (i = 0; i < len; i++) {\n\t\tif (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n// --- unicode\n// http://en.wikipedia.org/wiki/Surrogate_pair\n// Returns the code point starting at a specified index in a string\n// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character\n// Code points U+10000 to U+10FFFF are represented on two consecutive characters\n//export function getUnicodePoint(str:string, index:number, len:number):number {\n//\tlet chrCode = str.charCodeAt(index);\n//\tif (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {\n//\t\tlet nextChrCode = str.charCodeAt(index + 1);\n//\t\tif (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {\n//\t\t\treturn (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;\n//\t\t}\n//\t}\n//\treturn chrCode;\n//}\n//export function isLeadSurrogate(chr:string) {\n//\tlet chrCode = chr.charCodeAt(0);\n//\treturn ;\n//}\n//\n//export function isTrailSurrogate(chr:string) {\n//\tlet chrCode = chr.charCodeAt(0);\n//\treturn 0xDC00 <= chrCode && chrCode <= 0xDFFF;\n//}\n\nexport function isFullWidthCharacter(charCode:number): boolean {\n\t// Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n\t// http://jrgraphix.net/research/unicode_blocks.php\n\t//          2E80 — 2EFF   CJK Radicals Supplement\n\t//          2F00 — 2FDF   Kangxi Radicals\n\t//          2FF0 — 2FFF   Ideographic Description Characters\n\t//          3000 — 303F   CJK Symbols and Punctuation\n\t//          3040 — 309F   Hiragana\n\t//          30A0 — 30FF   Katakana\n\t//          3100 — 312F   Bopomofo\n\t//          3130 — 318F   Hangul Compatibility Jamo\n\t//          3190 — 319F   Kanbun\n\t//          31A0 — 31BF   Bopomofo Extended\n\t//          31F0 — 31FF   Katakana Phonetic Extensions\n\t//          3200 — 32FF   Enclosed CJK Letters and Months\n\t//          3300 — 33FF   CJK Compatibility\n\t//          3400 — 4DBF   CJK Unified Ideographs Extension A\n\t//          4DC0 — 4DFF   Yijing Hexagram Symbols\n\t//          4E00 — 9FFF   CJK Unified Ideographs\n\t//          A000 — A48F   Yi Syllables\n\t//          A490 — A4CF   Yi Radicals\n\t//          AC00 — D7AF   Hangul Syllables\n\t// [IGNORE] D800 — DB7F   High Surrogates\n\t// [IGNORE] DB80 — DBFF   High Private Use Surrogates\n\t// [IGNORE] DC00 — DFFF   Low Surrogates\n\t// [IGNORE] E000 — F8FF   Private Use Area\n\t//          F900 — FAFF   CJK Compatibility Ideographs\n\t// [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms\n\t// [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A\n\t// [IGNORE] FE00 — FE0F   Variation Selectors\n\t// [IGNORE] FE20 — FE2F   Combining Half Marks\n\t// [IGNORE] FE30 — FE4F   CJK Compatibility Forms\n\t// [IGNORE] FE50 — FE6F   Small Form Variants\n\t// [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B\n\t//          FF00 — FFEF   Halfwidth and Fullwidth Forms\n\t//               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n\t//               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n\t// [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n\t// [IGNORE] FFF0 — FFFF   Specials\n\tcharCode = +charCode; // @perf\n\treturn (\n\t\t(charCode >= 0x2E80 && charCode <= 0xD7AF)\n\t\t|| (charCode >= 0xF900 && charCode <= 0xFAFF)\n\t\t|| (charCode >= 0xFF01 && charCode <= 0xFF5E)\n\t);\n}\n\n/**\n * Computes the difference score for two strings. More similar strings have a higher score.\n * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.\n * Strings that have a large length difference will get a bad default score 0.\n * Complexity - both time and space O(first.length * second.length)\n * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n *\n * @param first a string\n * @param second a string\n */\nexport function difference(first: string, second: string, maxLenDelta: number = 4): number {\n\tlet lengthDifference = Math.abs(first.length - second.length);\n\t// We only compute score if length of the currentWord and length of entry.name are similar.\n\tif (lengthDifference > maxLenDelta) {\n\t\treturn 0;\n\t}\n\t// Initialize LCS (largest common subsequence) matrix.\n\tlet LCS: number[][] = [];\n\tlet zeroArray: number[] = [];\n\tlet i: number, j: number;\n\tfor (i = 0; i < second.length + 1; ++i) {\n\t\tzeroArray.push(0);\n\t}\n\tfor (i = 0; i < first.length + 1; ++i) {\n\t\tLCS.push(zeroArray);\n\t}\n\tfor (i = 1; i < first.length + 1; ++i) {\n\t\tfor (j = 1; j < second.length + 1; ++j) {\n\t\t\tif (first[i - 1] === second[j - 1]) {\n\t\t\t\tLCS[i][j] = LCS[i - 1][j - 1] + 1;\n\t\t\t} else {\n\t\t\t\tLCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn LCS[first.length][second.length] - Math.sqrt(lengthDifference);\n}\n\n/**\n * Returns an array in which every entry is the offset of a\n * line. There is always one entry which is zero.\n */\nexport function computeLineStarts(text: string): number[] {\n\tlet regexp = /\\r\\n|\\r|\\n/g,\n\t\tret: number[] = [0],\n\t\tmatch: RegExpExecArray;\n\twhile ((match = regexp.exec(text))) {\n\t\tret.push(regexp.lastIndex);\n\t}\n\treturn ret;\n}\n\n/**\n * Given a string and a max length returns a shorted version. Shorting\n * happens at favorable positions - such as whitespace or punctuation characters.\n */\nexport function lcut(text: string, n: number): string {\n\n\tif (text.length < n) {\n\t\treturn text;\n\t}\n\n\tlet segments = text.split(/\\b/),\n\t\tcount = 0;\n\n\tfor (let i = segments.length - 1; i >= 0; i--) {\n\t\tcount += segments[i].length;\n\n\t\tif (count > n) {\n\t\t\tsegments.splice(0, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn segments.join(empty).replace(/^\\s/, empty);\n}\n\n// Escape codes\n// http://en.wikipedia.org/wiki/ANSI_escape_code\nconst EL = /\\x1B\\x5B[12]?K/g; // Erase in line\nconst LF = /\\xA/g; // line feed\nconst COLOR_START = /\\x1b\\[\\d+m/g; // Color\nconst COLOR_END = /\\x1b\\[0?m/g; // Color\n\nexport function removeAnsiEscapeCodes(str: string): string {\n\tif (str) {\n\t\tstr = str.replace(EL, '');\n\t\tstr = str.replace(LF, '\\n');\n\t\tstr = str.replace(COLOR_START, '');\n\t\tstr = str.replace(COLOR_END, '');\n\t}\n\n\treturn str;\n}\n\n// -- UTF-8 BOM\n\nconst __utf8_bom = 65279;\n\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(__utf8_bom);\n\nexport function startsWithUTF8BOM(str: string): boolean {\n\treturn (str && str.length > 0 && str.charCodeAt(0) === __utf8_bom);\n}\n\n/**\n * Appends two strings. If the appended result is longer than maxLength,\n * trims the start of the result and replaces it with '...'.\n */\nexport function appendWithLimit(first: string, second: string, maxLength: number): string {\n\tconst newLength = first.length + second.length;\n\tif (newLength > maxLength) {\n\t\tfirst = '...' + first.substr(newLength - maxLength);\n\t}\n\tif (second.length > maxLength) {\n\t\tfirst += second.substr(second.length - maxLength);\n\t} else {\n\t\tfirst += second;\n\t}\n\n\treturn first;\n}\n\n\nexport function safeBtoa(str: string): string {\n\treturn btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values\n}\n\nexport function repeat(s:string, count: number): string {\n\tvar result = '';\n\tfor (var i = 0; i < count; i++) {\n\t\tresult += s;\n\t}\n\treturn result;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {TPromise} from 'vs/base/common/winjs.base';\n\nconst _typeof = {\n\tnumber: 'number',\n\tstring: 'string',\n\tundefined: 'undefined',\n\tobject: 'object',\n\tfunction: 'function'\n};\n\n/**\n * @returns whether the provided parameter is a JavaScript Array or not.\n */\nexport function isArray(array: any): array is any[] {\n\tif (Array.isArray) {\n\t\treturn Array.isArray(array);\n\t}\n\n\tif (array && typeof (array.length) === _typeof.number && array.constructor === Array) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nexport function isString(str: any): str is string {\n\tif (typeof (str) === _typeof.string|| str instanceof String) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.\n */\nexport function isStringArray(value: any): value is string[] {\n\treturn isArray(value) && (<any[]>value).every(elem => isString(elem));\n}\n\n/**\n *\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nexport function isObject(obj: any): obj is any {\n\treturn typeof obj === _typeof.object\n\t\t&& obj !== null\n\t\t&& !Array.isArray(obj)\n\t\t&& !(obj instanceof RegExp)\n\t\t&& !(obj instanceof Date);\n}\n\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nexport function isNumber(obj: any): obj is number {\n\tif ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nexport function isBoolean(obj: any): obj is boolean {\n\treturn obj === true || obj === false;\n}\n\n/**\n * @returns whether the provided parameter is undefined.\n */\nexport function isUndefined(obj: any): boolean {\n\treturn typeof (obj) === _typeof.undefined;\n}\n\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nexport function isUndefinedOrNull(obj: any): boolean {\n\treturn isUndefined(obj) || obj === null;\n}\n\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @returns whether the provided parameter is an empty JavaScript Object or not.\n */\nexport function isEmptyObject(obj: any): obj is any {\n\tif (!isObject(obj)) {\n\t\treturn false;\n\t}\n\n\tfor (let key in obj) {\n\t\tif (hasOwnProperty.call(obj, key)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nexport function isFunction(obj: any): obj is Function {\n\treturn typeof obj === _typeof.function;\n}\n\n/**\n * @returns whether the provided parameters is are JavaScript Function or not.\n */\nexport function areFunctions(...objects: any[]): boolean {\n\treturn objects && objects.length > 0 && objects.every(isFunction);\n}\n\nexport type TypeConstraint = string | Function;\n\nexport function validateConstraints(args: any[], constraints: TypeConstraint[]): void {\n\tconst len = Math.min(args.length, constraints.length);\n\tfor (let i = 0; i < len; i++) {\n\t\tvalidateConstraint(args[i], constraints[i]);\n\t}\n}\n\nexport function validateConstraint(arg: any, constraint: TypeConstraint): void {\n\n\tif (isString(constraint)) {\n\t\tif (typeof arg !== constraint) {\n\t\t\tthrow new Error(`argument does not match constraint: typeof ${constraint}`);\n\t\t}\n\t} else if (isFunction(constraint)) {\n\t\tif (arg instanceof constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (arg && arg.constructor === constraint) {\n\t\t\treturn;\n\t\t}\n\t\tif (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n\t\t\treturn;\n\t\t}\n\t\tthrow new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n\t}\n}\n\n/**\n * Creates a new object of the provided class and will call the constructor with\n * any additional argument supplied.\n */\nexport function create(ctor: Function, ...args: any[]): any {\n\tlet obj = Object.create(ctor.prototype);\n\tctor.apply(obj, args);\n\n\treturn obj;\n}\n\nexport interface IFunction0<T> {\n\t(): T;\n}\nexport interface IFunction1<A1, T> {\n\t(a1: A1): T;\n}\nexport interface IFunction2<A1, A2, T> {\n\t(a1: A1, a2: A2): T;\n}\nexport interface IFunction3<A1, A2, A3, T> {\n\t(a1: A1, a2: A2, a3: A3): T;\n}\nexport interface IFunction4<A1, A2, A3, A4, T> {\n\t(a1: A1, a2: A2, a3: A3, a4: A4): T;\n}\nexport interface IFunction5<A1, A2, A3, A4, A5, T> {\n\t(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5): T;\n}\nexport interface IFunction6<A1, A2, A3, A4, A5, A6, T> {\n\t(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6): T;\n}\nexport interface IFunction7<A1, A2, A3, A4, A5, A6, A7, T> {\n\t(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7): T;\n}\nexport interface IFunction8<A1, A2, A3, A4, A5, A6, A7, A8, T> {\n\t(a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8): T;\n}\n\nexport interface IAction0 extends IFunction0<void> { }\nexport interface IAction1<A1> extends IFunction1<A1, void> { }\nexport interface IAction2<A1, A2> extends IFunction2<A1, A2, void> { }\nexport interface IAction3<A1, A2, A3> extends IFunction3<A1, A2, A3, void> { }\nexport interface IAction4<A1, A2, A3, A4> extends IFunction4<A1, A2, A3, A4, void> { }\nexport interface IAction5<A1, A2, A3, A4, A5> extends IFunction5<A1, A2, A3, A4, A5, void> { }\nexport interface IAction6<A1, A2, A3, A4, A5, A6> extends IFunction6<A1, A2, A3, A4, A5, A6, void> { }\nexport interface IAction7<A1, A2, A3, A4, A5, A6, A7> extends IFunction7<A1, A2, A3, A4, A5, A6, A7, void> { }\nexport interface IAction8<A1, A2, A3, A4, A5, A6, A7, A8> extends IFunction8<A1, A2, A3, A4, A5, A6, A7, A8, void> { }\n\nexport interface IAsyncFunction0<T> extends IFunction0<TPromise<T>> { }\nexport interface IAsyncFunction1<A1, T> extends IFunction1<A1, TPromise<T>> { }\nexport interface IAsyncFunction2<A1, A2, T> extends IFunction2<A1, A2, TPromise<T>> { }\nexport interface IAsyncFunction3<A1, A2, A3, T> extends IFunction3<A1, A2, A3, TPromise<T>> { }\nexport interface IAsyncFunction4<A1, A2, A3, A4, T> extends IFunction4<A1, A2, A3, A4, TPromise<T>> { }\nexport interface IAsyncFunction5<A1, A2, A3, A4, A5, T> extends IFunction5<A1, A2, A3, A4, A5, TPromise<T>> { }\nexport interface IAsyncFunction6<A1, A2, A3, A4, A5, A6, T> extends IFunction6<A1, A2, A3, A4, A5, A6, TPromise<T>> { }\nexport interface IAsyncFunction7<A1, A2, A3, A4, A5, A6, A7, T> extends IFunction7<A1, A2, A3, A4, A5, A6, A7, TPromise<T>> { }\nexport interface IAsyncFunction8<A1, A2, A3, A4, A5, A6, A7, A8, T> extends IFunction8<A1, A2, A3, A4, A5, A6, A7, A8, TPromise<T>> { }\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { isArray } from './types';\n\nexport const empty: IDisposable = Object.freeze({\n\tdispose() { }\n});\n\nexport interface IDisposable {\n\tdispose(): void;\n}\n\nexport function dispose<T extends IDisposable>(...disposables: T[]): T;\nexport function dispose<T extends IDisposable>(disposables: T[]): T[];\nexport function dispose<T extends IDisposable>(...disposables: T[]): T[] {\n\tconst first = disposables[0];\n\n\tif (isArray(first)) {\n\t\tdisposables = first as any as T[];\n\t}\n\n\tdisposables.forEach(d => d && d.dispose());\n\treturn [];\n}\n\nexport function combinedDisposable(disposables: IDisposable[]): IDisposable;\nexport function combinedDisposable(...disposables: IDisposable[]): IDisposable;\nexport function combinedDisposable(disposables: any): IDisposable {\n\treturn { dispose: () => dispose(disposables) };\n}\n\nexport function toDisposable(...fns: (() => void)[]): IDisposable {\n\treturn combinedDisposable(fns.map(fn => ({ dispose: fn })));\n}\n\nexport abstract class Disposable implements IDisposable {\n\n\tprivate _toDispose: IDisposable[];\n\n\tconstructor() {\n\t\tthis._toDispose = [];\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._toDispose = dispose(this._toDispose);\n\t}\n\n\tprotected _register<T extends IDisposable>(t:T): T {\n\t\tthis._toDispose.push(t);\n\t\treturn t;\n\t}\n}\n\nexport class Disposables extends Disposable {\n\n\tpublic add<T extends IDisposable>(e: T): T;\n\tpublic add(...elements: IDisposable[]): void;\n\tpublic add<T extends IDisposable>(arg: T | T[]): T {\n\t\tif (!Array.isArray(arg)) {\n\t\t\treturn this._register(arg);\n\t\t} else {\n\t\t\tfor (let element of arg) {\n\t\t\t\treturn this._register(element);\n\t\t\t}\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as Types from 'vs/base/common/types';\n\nexport function clone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tif (obj instanceof RegExp) {\n\t\treturn obj;\n\t}\n\tvar result = (Array.isArray(obj)) ? <any>[] : <any>{};\n\tObject.keys(obj).forEach((key) => {\n\t\tif (obj[key] && typeof obj[key] === 'object') {\n\t\t\tresult[key] = clone(obj[key]);\n\t\t} else {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nexport function deepClone<T>(obj: T): T {\n\tif (!obj || typeof obj !== 'object') {\n\t\treturn obj;\n\t}\n\tvar result = (Array.isArray(obj)) ? <any>[] : <any>{};\n\tObject.getOwnPropertyNames(obj).forEach((key) => {\n\t\tif (obj[key] && typeof obj[key] === 'object') {\n\t\t\tresult[key] = deepClone(obj[key]);\n\t\t} else {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t});\n\treturn result;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nexport function cloneAndChange(obj: any, changer: (orig: any) => any): any {\n\treturn _cloneAndChange(obj, changer, []);\n}\n\nfunction _cloneAndChange(obj: any, changer: (orig: any) => any, encounteredObjects: any[]): any {\n\tif (Types.isUndefinedOrNull(obj)) {\n\t\treturn obj;\n\t}\n\n\tvar changed = changer(obj);\n\tif (typeof changed !== 'undefined') {\n\t\treturn changed;\n\t}\n\n\tif (Types.isArray(obj)) {\n\t\tvar r1: any[] = [];\n\t\tfor (var i1 = 0; i1 < obj.length; i1++) {\n\t\t\tr1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));\n\t\t}\n\t\treturn r1;\n\t}\n\n\tif (Types.isObject(obj)) {\n\t\tif (encounteredObjects.indexOf(obj) >= 0) {\n\t\t\tthrow new Error('Cannot clone recursive data-structure');\n\t\t}\n\t\tencounteredObjects.push(obj);\n\t\tvar r2 = {};\n\t\tfor (var i2 in obj) {\n\t\t\tif (hasOwnProperty.call(obj, i2)) {\n\t\t\t\tr2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);\n\t\t\t}\n\t\t}\n\t\tencounteredObjects.pop();\n\t\treturn r2;\n\t}\n\n\treturn obj;\n}\n\n// DON'T USE THESE FUNCTION UNLESS YOU KNOW HOW CHROME\n// WORKS... WE HAVE SEEN VERY WEIRD BEHAVIOUR WITH CHROME >= 37\n\n///**\n// * Recursively call Object.freeze on object and any properties that are objects.\n// */\n//export function deepFreeze(obj:any):void {\n//\tObject.freeze(obj);\n//\tObject.keys(obj).forEach((key) => {\n//\t\tif(!(typeof obj[key] === 'object') || Object.isFrozen(obj[key])) {\n//\t\t\treturn;\n//\t\t}\n//\n//\t\tdeepFreeze(obj[key]);\n//\t});\n//\tif(!Object.isFrozen(obj)) {\n//\t\tconsole.log('too warm');\n//\t}\n//}\n//\n//export function deepSeal(obj:any):void {\n//\tObject.seal(obj);\n//\tObject.keys(obj).forEach((key) => {\n//\t\tif(!(typeof obj[key] === 'object') || Object.isSealed(obj[key])) {\n//\t\t\treturn;\n//\t\t}\n//\n//\t\tdeepSeal(obj[key]);\n//\t});\n//\tif(!Object.isSealed(obj)) {\n//\t\tconsole.log('NOT sealed');\n//\t}\n//}\n\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nexport function mixin(destination: any, source: any, overwrite: boolean = true): any {\n\tif (!Types.isObject(destination)) {\n\t\treturn source;\n\t}\n\n\tif (Types.isObject(source)) {\n\t\tObject.keys(source).forEach((key) => {\n\t\t\tif (key in destination) {\n\t\t\t\tif (overwrite) {\n\t\t\t\t\tif (Types.isObject(destination[key]) && Types.isObject(source[key])) {\n\t\t\t\t\t\tmixin(destination[key], source[key], overwrite);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdestination[key] = source[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t});\n\t}\n\treturn destination;\n}\n\nexport function assign(destination: any, ...sources: any[]): any {\n\tsources.forEach(source => Object.keys(source).forEach((key) => destination[key] = source[key]));\n\treturn destination;\n}\n\nexport function toObject<T,R>(arr: T[], keyMap: (T) => string, valueMap: (T) => R = x => x): { [key: string]: R } {\n\treturn arr.reduce((o, d) => assign(o, { [keyMap(d)]: valueMap(d) }), Object.create(null));\n}\n\nexport function equals(one: any, other: any): boolean {\n\tif (one === other) {\n\t\treturn true;\n\t}\n\tif (one === null || one === undefined || other === null || other === undefined) {\n\t\treturn false;\n\t}\n\tif (typeof one !== typeof other) {\n\t\treturn false;\n\t}\n\tif (typeof one !== 'object') {\n\t\treturn false;\n\t}\n\tif ((Array.isArray(one)) !== (Array.isArray(other))) {\n\t\treturn false;\n\t}\n\n\tvar i: number,\n\t\tkey: string;\n\n\tif (Array.isArray(one)) {\n\t\tif (one.length !== other.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < one.length; i++) {\n\t\t\tif (!equals(one[i], other[i])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar oneKeys:string[] = [];\n\n\t\tfor (key in one) {\n\t\t\toneKeys.push(key);\n\t\t}\n\t\toneKeys.sort();\n\t\tvar otherKeys:string[] = [];\n\t\tfor (key in other) {\n\t\t\totherKeys.push(key);\n\t\t}\n\t\totherKeys.sort();\n\t\tif (!equals(oneKeys, otherKeys)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < oneKeys.length; i++) {\n\t\t\tif (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nexport function ensureProperty(obj: any, property: string, defaultValue: any) {\n\tif (typeof obj[property] === 'undefined') {\n\t\tobj[property] = defaultValue;\n\t}\n}\n\nexport function arrayToHash(array: any[]) {\n\tvar result: any = {};\n\tfor (var i = 0; i < array.length; ++i) {\n\t\tresult[array[i]] = true;\n\t}\n\treturn result;\n}\n\n/**\n * Given an array of strings, returns a function which, given a string\n * returns true or false whether the string is in that array.\n */\nexport function createKeywordMatcher(arr: string[], caseInsensitive: boolean = false): (str: string) => boolean {\n\tif (caseInsensitive) {\n\t\tarr = arr.map(function (x) { return x.toLowerCase(); });\n\t}\n\tvar hash = arrayToHash(arr);\n\tif (caseInsensitive) {\n\t\treturn function (word) {\n\t\t\treturn hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());\n\t\t};\n\t} else {\n\t\treturn function (word) {\n\t\t\treturn hash[word] !== undefined && hash.hasOwnProperty(word);\n\t\t};\n\t}\n}\n\n/**\n * Started from TypeScript's __extends function to make a type a subclass of a specific class.\n * Modified to work with properties already defined on the derivedClass, since we can't get TS\n * to call this method before the constructor definition.\n */\nexport function derive(baseClass: any, derivedClass: any): void {\n\n\tfor (var prop in baseClass) {\n\t\tif (baseClass.hasOwnProperty(prop)) {\n\t\t\tderivedClass[prop] = baseClass[prop];\n\t\t}\n\t}\n\n\tderivedClass = derivedClass || function () { };\n\tvar basePrototype = baseClass.prototype;\n\tvar derivedPrototype = derivedClass.prototype;\n\tderivedClass.prototype = Object.create(basePrototype);\n\n\tfor (var prop in derivedPrototype) {\n\t\tif (derivedPrototype.hasOwnProperty(prop)) {\n\t\t\t// handle getters and setters properly\n\t\t\tObject.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));\n\t\t}\n\t}\n\n\t// Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.\n\tObject.defineProperty(derivedClass.prototype, 'constructor', <any>{ value: derivedClass, writable: true, configurable: true, enumerable: true });\n}\n\n/**\n * Calls JSON.Stringify with a replacer to break apart any circular references.\n * This prevents JSON.stringify from throwing the exception\n *  \"Uncaught TypeError: Converting circular structure to JSON\"\n */\nexport function safeStringify(obj: any): string {\n\tvar seen: any[] = [];\n\treturn JSON.stringify(obj, (key, value) => {\n\n\t\tif (Types.isObject(value) || Array.isArray(value)) {\n\t\t\tif (seen.indexOf(value) !== -1) {\n\t\t\t\treturn '[Circular]';\n\t\t\t} else {\n\t\t\t\tseen.push(value);\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t});\n}\n\nexport function getOrDefault<T,R>(obj: T, fn: (obj: T) => R, defaultValue: R = null): R {\n\tconst result = fn(obj);\n\treturn typeof result === 'undefined' ? defaultValue : result;\n}","/// <loc filename=\"Metadata\\base_loc_oam.xml\" format=\"messagebundle\" />\n/*! @minifier_do_not_preserve\n  © Microsoft. All rights reserved.\n\n  This library is supported for use in Windows Store apps only.\n\n  Build: 1.0.9200.20602.win8_ldr.130108-1504\n\n  Version: Microsoft.WinJS.1.0\n*/\n\n/*\n\tNote: Copied out of base.js.\n\tChanges:\n\t\t- we have only kept the first 2554 lines.\n\t\t- we have patched WinJS.xhr to add the hedader X-Requested-With:XMLHttpRequest\n\t\t- we have wrapped the entire code in an if statement to make WinJS re-entrant (if already defined)\n\t\t- we have to define setImmediate if not running in IE 10 since its a IE 10 only function\n\t\t- we have removed some getter syntax\n*/\n\n// MONACO CHANGE: Make WinJS re-entrant (if already defined)\nif (typeof WinJS === 'undefined') {\n\n// MONACO CHANGE: define setImmediate\n(function (global) {\n    if (!global.setImmediate) {\n        if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {\n            // running in node\n            global.setImmediate = function(callback) {\n                return process.nextTick(callback);\n            };\n        } else {\n            // running in browser\n            global.setImmediate = function(callback) {\n                return setTimeout(callback, 0);\n            };\n        }\n\t}\n\n})(this);\n\n/// <reference path=\"ms-appx://Microsoft.WinJS.1.0/js/base.js\" />\n(function baseInit(global, undefined) {\n    \"use strict\";\n\n    function initializeProperties(target, members) {\n        var keys = Object.keys(members);\n        var properties;\n        var i, len;\n        for (i = 0, len = keys.length; i < len; i++) {\n            var key = keys[i];\n            var enumerable = key.charCodeAt(0) !== /*_*/95;\n            var member = members[key];\n            if (member && typeof member === 'object') {\n                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {\n                    if (member.enumerable === undefined) {\n                        member.enumerable = enumerable;\n                    }\n                    properties = properties || {};\n                    properties[key] = member;\n                    continue;\n                }\n            }\n            if (!enumerable) {\n                properties = properties || {};\n                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true }\n                continue;\n            }\n            target[key] = member;\n        }\n        if (properties) {\n            Object.defineProperties(target, properties);\n        }\n    }\n\n    (function (rootNamespace) {\n\n        // Create the rootNamespace in the global namespace\n        if (!global[rootNamespace]) {\n            global[rootNamespace] = Object.create(Object.prototype);\n        }\n\n        // Cache the rootNamespace we just created in a local variable\n        var _rootNamespace = global[rootNamespace];\n        if (!_rootNamespace.Namespace) {\n            _rootNamespace.Namespace = Object.create(Object.prototype);\n        }\n\n        function defineWithParent(parentNamespace, name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.defineWithParent\">\n            /// <summary locid=\"WinJS.Namespace.defineWithParent\">\n            /// Defines a new namespace with the specified name under the specified parent namespace.\n            /// </summary>\n            /// <param name=\"parentNamespace\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:parentNamespace\">\n            /// The parent namespace.\n            /// </param>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.defineWithParent_p:name\">\n            /// The name of the new namespace.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.defineWithParent_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            var currentNamespace = parentNamespace,\n                namespaceFragments = name.split(\".\");\n\n            for (var i = 0, len = namespaceFragments.length; i < len; i++) {\n                var namespaceName = namespaceFragments[i];\n                if (!currentNamespace[namespaceName]) {\n                    Object.defineProperty(currentNamespace, namespaceName,\n                        { value: {}, writable: false, enumerable: true, configurable: true }\n                    );\n                }\n                currentNamespace = currentNamespace[namespaceName];\n            }\n\n            if (members) {\n                initializeProperties(currentNamespace, members);\n            }\n\n            return currentNamespace;\n        }\n\n        function define(name, members) {\n            /// <signature helpKeyword=\"WinJS.Namespace.define\">\n            /// <summary locid=\"WinJS.Namespace.define\">\n            /// Defines a new namespace with the specified name.\n            /// </summary>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.Namespace.define_p:name\">\n            /// The name of the namespace. This could be a dot-separated name for nested namespaces.\n            /// </param>\n            /// <param name=\"members\" type=\"Object\" locid=\"WinJS.Namespace.define_p:members\">\n            /// The members of the new namespace.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Namespace.define_returnValue\">\n            /// The newly-defined namespace.\n            /// </returns>\n            /// </signature>\n            return defineWithParent(global, name, members);\n        }\n\n        // Establish members of the \"WinJS.Namespace\" namespace\n        Object.defineProperties(_rootNamespace.Namespace, {\n\n            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },\n\n            define: { value: define, writable: true, enumerable: true, configurable: true }\n\n        });\n\n    })(\"WinJS\");\n\n    (function (WinJS) {\n\n        function define(constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.define\">\n            /// <summary locid=\"WinJS.Class.define\">\n            /// Defines a class using the given constructor and the specified instance members.\n            /// </summary>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.define_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.define_p:staticMembers\">\n            /// The set of static fields, properties, and methods made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.define_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            WinJS.Utilities.markSupportedForProcessing(constructor);\n            if (instanceMembers) {\n                initializeProperties(constructor.prototype, instanceMembers);\n            }\n            if (staticMembers) {\n                initializeProperties(constructor, staticMembers);\n            }\n            return constructor;\n        }\n\n        function derive(baseClass, constructor, instanceMembers, staticMembers) {\n            /// <signature helpKeyword=\"WinJS.Class.derive\">\n            /// <summary locid=\"WinJS.Class.derive\">\n            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.\n            /// </summary>\n            /// <param name=\"baseClass\" type=\"Function\" locid=\"WinJS.Class.derive_p:baseClass\">\n            /// The class to inherit from.\n            /// </param>\n            /// <param name=\"constructor\" type=\"Function\" locid=\"WinJS.Class.derive_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <param name=\"instanceMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:instanceMembers\">\n            /// The set of instance fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <param name=\"staticMembers\" type=\"Object\" locid=\"WinJS.Class.derive_p:staticMembers\">\n            /// The set of static fields, properties, and methods to be made available on the class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.derive_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            if (baseClass) {\n                constructor = constructor || function () { };\n                var basePrototype = baseClass.prototype;\n                constructor.prototype = Object.create(basePrototype);\n                WinJS.Utilities.markSupportedForProcessing(constructor);\n                Object.defineProperty(constructor.prototype, \"constructor\", { value: constructor, writable: true, configurable: true, enumerable: true });\n                if (instanceMembers) {\n                    initializeProperties(constructor.prototype, instanceMembers);\n                }\n                if (staticMembers) {\n                    initializeProperties(constructor, staticMembers);\n                }\n                return constructor;\n            } else {\n                return define(constructor, instanceMembers, staticMembers);\n            }\n        }\n\n        function mix(constructor) {\n            /// <signature helpKeyword=\"WinJS.Class.mix\">\n            /// <summary locid=\"WinJS.Class.mix\">\n            /// Defines a class using the given constructor and the union of the set of instance members\n            /// specified by all the mixin objects. The mixin parameter list is of variable length.\n            /// </summary>\n            /// <param name=\"constructor\" locid=\"WinJS.Class.mix_p:constructor\">\n            /// A constructor function that is used to instantiate this class.\n            /// </param>\n            /// <returns type=\"Function\" locid=\"WinJS.Class.mix_returnValue\">\n            /// The newly-defined class.\n            /// </returns>\n            /// </signature>\n            constructor = constructor || function () { };\n            var i, len;\n            for (i = 1, len = arguments.length; i < len; i++) {\n                initializeProperties(constructor.prototype, arguments[i]);\n            }\n            return constructor;\n        }\n\n        // Establish members of \"WinJS.Class\" namespace\n        WinJS.Namespace.define(\"WinJS.Class\", {\n            define: define,\n            derive: derive,\n            mix: mix\n        });\n\n    })(global.WinJS);\n\n})(this);\n\n\n(function baseUtilsInit(global, WinJS) {\n    \"use strict\";\n\n    var hasWinRT = !!global.Windows;\n\n    var strings = {\n\t\t// MONACOCHANGE\n        //get notSupportedForProcessing() { return WinJS.Resources._getWinJSString(\"base/notSupportedForProcessing\").value; }\n\t\tnotSupportedForProcessing: \"Value is not supported within a declarative processing context, if you want it to be supported mark it using WinJS.Utilities.markSupportedForProcessing. The value was: '{0}'\"\n    };\n\n    function nop(v) {\n        return v;\n    }\n\n    function getMemberFiltered(name, root, filter) {\n        return name.split(\".\").reduce(function (currentNamespace, name) {\n            if (currentNamespace) {\n                return filter(currentNamespace[name]);\n            }\n            return null;\n        }, root);\n    }\n\n    // Establish members of \"WinJS.Utilities\" namespace\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        // Used for mocking in tests\n        _setHasWinRT: {\n            value: function (value) {\n                hasWinRT = value;\n            },\n            configurable: false,\n            writable: false,\n            enumerable: false\n        },\n\n        /// <field type=\"Boolean\" locid=\"WinJS.Utilities.hasWinRT\" helpKeyword=\"WinJS.Utilities.hasWinRT\">Determine if WinRT is accessible in this script context.</field>\n        hasWinRT: {\n            get: function () { return hasWinRT; },\n            configurable: false,\n            enumerable: true\n        },\n\n        _getMemberFiltered: getMemberFiltered,\n\n        getMember: function (name, root) {\n            /// <signature helpKeyword=\"WinJS.Utilities.getMember\">\n            /// <summary locid=\"WinJS.Utilities.getMember\">\n            /// Gets the leaf-level type or namespace specified by the name parameter.\n            /// </summary>\n            /// <param name=\"name\" locid=\"WinJS.Utilities.getMember_p:name\">\n            /// The name of the member.\n            /// </param>\n            /// <param name=\"root\" locid=\"WinJS.Utilities.getMember_p:root\">\n            /// The root to start in. Defaults to the global object.\n            /// </param>\n            /// <returns type=\"Object\" locid=\"WinJS.Utilities.getMember_returnValue\">\n            /// The leaf-level type or namespace in the specified parent namespace.\n            /// </returns>\n            /// </signature>\n            if (!name) {\n                return null;\n            }\n            return getMemberFiltered(name, root || global, nop);\n        },\n\n        ready: function (callback, async) {\n            /// <signature helpKeyword=\"WinJS.Utilities.ready\">\n            /// <summary locid=\"WinJS.Utilities.ready\">\n            /// Ensures that the specified function executes only after the DOMContentLoaded event has fired\n            /// for the current page.\n            /// </summary>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Utilities.ready_returnValue\">A promise that completes after DOMContentLoaded has occurred.</returns>\n            /// <param name=\"callback\" optional=\"true\" locid=\"WinJS.Utilities.ready_p:callback\">\n            /// A function that executes after DOMContentLoaded has occurred.\n            /// </param>\n            /// <param name=\"async\" optional=\"true\" locid=\"WinJS.Utilities.ready_p:async\">\n            /// If true, the callback should be executed asynchronously.\n            /// </param>\n            /// </signature>\n            return new WinJS.Promise(function (c, e) {\n                function complete() {\n                    if (callback) {\n                        try {\n                            callback();\n                            c();\n                        }\n                        catch (err) {\n                            e(err);\n                        }\n                    }\n                    else {\n                        c();\n                    }\n                }\n\n                var readyState = WinJS.Utilities.testReadyState;\n                if (!readyState) {\n                    if (global.document) {\n                        readyState = document.readyState;\n                    }\n                    else {\n                        readyState = \"complete\";\n                    }\n                }\n                if (readyState === \"complete\" || (global.document && document.body !== null)) {\n                    if (async) {\n                        global.setImmediate(complete);\n                    }\n                    else {\n                        complete();\n                    }\n                }\n                else {\n                    global.addEventListener(\"DOMContentLoaded\", complete, false);\n                }\n            });\n        },\n\n        /// <field type=\"Boolean\" locid=\"WinJS.Utilities.strictProcessing\" helpKeyword=\"WinJS.Utilities.strictProcessing\">Determines if strict declarative processing is enabled in this script context.</field>\n        strictProcessing: {\n            get: function () { return true; },\n            configurable: false,\n            enumerable: true,\n        },\n\n        markSupportedForProcessing: {\n            value: function (func) {\n                /// <signature helpKeyword=\"WinJS.Utilities.markSupportedForProcessing\">\n                /// <summary locid=\"WinJS.Utilities.markSupportedForProcessing\">\n                /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll\n                /// or WinJS.Binding.processAll.\n                /// </summary>\n                /// <param name=\"func\" type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_p:func\">\n                /// The function to be marked as compatible with declarative processing.\n                /// </param>\n                /// <returns type=\"Function\" locid=\"WinJS.Utilities.markSupportedForProcessing_returnValue\">\n                /// The input function.\n                /// </returns>\n                /// </signature>\n                func.supportedForProcessing = true;\n                return func;\n            },\n            configurable: false,\n            writable: false,\n            enumerable: true\n        },\n\n        requireSupportedForProcessing: {\n            value: function (value) {\n                /// <signature helpKeyword=\"WinJS.Utilities.requireSupportedForProcessing\">\n                /// <summary locid=\"WinJS.Utilities.requireSupportedForProcessing\">\n                /// Asserts that the value is compatible with declarative processing, such as WinJS.UI.processAll\n                /// or WinJS.Binding.processAll. If it is not compatible an exception will be thrown.\n                /// </summary>\n                /// <param name=\"value\" type=\"Object\" locid=\"WinJS.Utilities.requireSupportedForProcessing_p:value\">\n                /// The value to be tested for compatibility with declarative processing. If the\n                /// value is a function it must be marked with a property 'supportedForProcessing'\n                /// with a value of true.\n                /// </param>\n                /// <returns type=\"Object\" locid=\"WinJS.Utilities.requireSupportedForProcessing_returnValue\">\n                /// The input value.\n                /// </returns>\n                /// </signature>\n                var supportedForProcessing = true;\n\n                supportedForProcessing = supportedForProcessing && !(value === global);\n                supportedForProcessing = supportedForProcessing && !(value === global.location);\n                supportedForProcessing = supportedForProcessing && !(value instanceof HTMLIFrameElement);\n                supportedForProcessing = supportedForProcessing && !(typeof value === \"function\" && !value.supportedForProcessing);\n\n                switch (global.frames.length) {\n                    case 0:\n                        break;\n\n                    case 1:\n                        supportedForProcessing = supportedForProcessing && !(value === global.frames[0]);\n                        break;\n\n                    default:\n                        for (var i = 0, len = global.frames.length; supportedForProcessing && i < len; i++) {\n                            supportedForProcessing = supportedForProcessing && !(value === global.frames[i]);\n                        }\n                        break;\n                }\n\n                if (supportedForProcessing) {\n                    return value;\n                }\n\n                throw new WinJS.ErrorFromName(\"WinJS.Utilities.requireSupportedForProcessing\", WinJS.Resources._formatString(strings.notSupportedForProcessing, value));\n            },\n            configurable: false,\n            writable: false,\n            enumerable: true\n        },\n\n    });\n\n    WinJS.Namespace.define(\"WinJS\", {\n        validation: false,\n\n        strictProcessing: {\n            value: function () {\n                /// <signature helpKeyword=\"WinJS.strictProcessing\">\n                /// <summary locid=\"WinJS.strictProcessing\">\n                /// Strict processing is always enforced, this method has no effect.\n                /// </summary>\n                /// </signature>\n            },\n            configurable: false,\n            writable: false,\n            enumerable: false\n        },\n    });\n})(this, this.WinJS);\n\n\n(function logInit(WinJS) {\n    \"use strict\";\n\n    var spaceR = /\\s+/g;\n    var typeR = /^(error|warn|info|log)$/;\n\n    function format(message, tag, type) {\n        /// <signature helpKeyword=\"WinJS.Utilities.formatLog\">\n        /// <summary locid=\"WinJS.Utilities.formatLog\">\n        /// Adds tags and type to a logging message.\n        /// </summary>\n        /// <param name=\"message\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:message\">The message to be formatted.</param>\n        /// <param name=\"tag\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:tag\">The tag(s) to be applied to the message. Multiple tags should be separated by spaces.</param>\n        /// <param name=\"type\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:type\">The type of the message.</param>\n        /// <returns type=\"String\" locid=\"WinJS.Utilities.startLog_returnValue\">The formatted message.</returns>\n        /// </signature>\n        var m = message;\n        if (typeof (m) === \"function\") { m = m(); }\n\n        return ((type && typeR.test(type)) ? (\"\") : (type ? (type + \": \") : \"\")) +\n            (tag ? tag.replace(spaceR, \":\") + \": \" : \"\") +\n            m;\n    }\n    function defAction(message, tag, type) {\n        var m = WinJS.Utilities.formatLog(message, tag, type);\n        console[(type && typeR.test(type)) ? type : \"log\"](m);\n    }\n    function escape(s) {\n        // \\s (whitespace) is used as separator, so don't escape it\n        return s.replace(/[-[\\]{}()*+?.,\\\\^$|#]/g, \"\\\\$&\");\n    }\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        startLog: function (options) {\n            /// <signature helpKeyword=\"WinJS.Utilities.startLog\">\n            /// <summary locid=\"WinJS.Utilities.startLog\">\n            /// Configures a logger that writes messages containing the specified tags from WinJS.log to console.log.\n            /// </summary>\n            /// <param name=\"options\" type=\"String\" locid=\"WinJS.Utilities.startLog_p:options\">The tags for messages to log. Multiple tags should be separated by spaces.</param>\n            /// </signature>\n            /// <signature>\n            /// <summary locid=\"WinJS.Utilities.startLog2\">\n            /// Configure a logger to write WinJS.log output.\n            /// </summary>\n            /// <param name=\"options\" type=\"Object\" locid=\"WinJS.Utilities.startLog_p:options2\">\n            /// May contain .type, .tags, .excludeTags and .action properties.\n            /// - .type is a required tag.\n            /// - .excludeTags is a space-separated list of tags, any of which will result in a message not being logged.\n            /// - .tags is a space-separated list of tags, any of which will result in a message being logged.\n            /// - .action is a function that, if present, will be called with the log message, tags and type. The default is to log to the console.\n            /// </param>\n            /// </signature>\n            options = options || {};\n            if (typeof options === \"string\") {\n                options = { tags: options };\n            }\n            var el = options.type && new RegExp(\"^(\" + escape(options.type).replace(spaceR, \" \").split(\" \").join(\"|\") + \")$\");\n            var not = options.excludeTags && new RegExp(\"(^|\\\\s)(\" + escape(options.excludeTags).replace(spaceR, \" \").split(\" \").join(\"|\") + \")(\\\\s|$)\", \"i\");\n            var has = options.tags && new RegExp(\"(^|\\\\s)(\" + escape(options.tags).replace(spaceR, \" \").split(\" \").join(\"|\") + \")(\\\\s|$)\", \"i\");\n            var action = options.action || defAction;\n\n            if (!el && !not && !has && !WinJS.log) {\n                WinJS.log = action;\n                return;\n            }\n\n            var result = function (message, tag, type) {\n                if (!((el && !el.test(type))          // if the expected log level is not satisfied\n                    || (not && not.test(tag))         // if any of the excluded categories exist\n                    || (has && !has.test(tag)))) {    // if at least one of the included categories doesn't exist\n                        action(message, tag, type);\n                    }\n\n                result.next && result.next(message, tag, type);\n            };\n            result.next = WinJS.log;\n            WinJS.log = result;\n        },\n        stopLog: function () {\n            /// <signature helpKeyword=\"WinJS.Utilities.stopLog\">\n            /// <summary locid=\"WinJS.Utilities.stopLog\">\n            /// Removes the previously set up logger.\n            /// </summary>\n            /// </signature>\n            delete WinJS.log;\n        },\n        formatLog: format\n    });\n})(this.WinJS);\n\n(function eventsInit(WinJS, undefined) {\n    \"use strict\";\n\n\n    function createEventProperty(name) {\n        var eventPropStateName = \"_on\" + name + \"state\";\n\n        return {\n            get: function () {\n                var state = this[eventPropStateName];\n                return state && state.userHandler;\n            },\n            set: function (handler) {\n                var state = this[eventPropStateName];\n                if (handler) {\n                    if (!state) {\n                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };\n                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });\n                        this.addEventListener(name, state.wrapper, false);\n                    }\n                    state.userHandler = handler;\n                } else if (state) {\n                    this.removeEventListener(name, state.wrapper, false);\n                    this[eventPropStateName] = null;\n                }\n            },\n            enumerable: true\n        }\n    }\n\n    function createEventProperties(events) {\n        /// <signature helpKeyword=\"WinJS.Utilities.createEventProperties\">\n        /// <summary locid=\"WinJS.Utilities.createEventProperties\">\n        /// Creates an object that has one property for each name passed to the function.\n        /// </summary>\n        /// <param name=\"events\" locid=\"WinJS.Utilities.createEventProperties_p:events\">\n        /// A variable list of property names.\n        /// </param>\n        /// <returns type=\"Object\" locid=\"WinJS.Utilities.createEventProperties_returnValue\">\n        /// The object with the specified properties. The names of the properties are prefixed with 'on'.\n        /// </returns>\n        /// </signature>\n        var props = {};\n        for (var i = 0, len = arguments.length; i < len; i++) {\n            var name = arguments[i];\n            props[\"on\" + name] = createEventProperty(name);\n        }\n        return props;\n    }\n\n    var EventMixinEvent = WinJS.Class.define(\n        function EventMixinEvent_ctor(type, detail, target) {\n            this.detail = detail;\n            this.target = target;\n            this.timeStamp = Date.now();\n            this.type = type;\n        },\n        {\n            bubbles: { value: false, writable: false },\n            cancelable: { value: false, writable: false },\n            currentTarget: {\n                get: function () { return this.target; }\n            },\n            defaultPrevented: {\n                get: function () { return this._preventDefaultCalled; }\n            },\n            trusted: { value: false, writable: false },\n            eventPhase: { value: 0, writable: false },\n            target: null,\n            timeStamp: null,\n            type: null,\n\n            preventDefault: function () {\n                this._preventDefaultCalled = true;\n            },\n            stopImmediatePropagation: function () {\n                this._stopImmediatePropagationCalled = true;\n            },\n            stopPropagation: function () {\n            }\n        }, {\n            supportedForProcessing: false,\n        }\n    );\n\n    var eventMixin = {\n        _listeners: null,\n\n        addEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.addEventListener\">\n            /// Adds an event listener to the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:listener\">\n            /// The listener to invoke when the event gets raised.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.addEventListener_p:useCapture\">\n            /// if true initiates capture, otherwise false.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            this._listeners = this._listeners || {};\n            var eventListeners = (this._listeners[type] = this._listeners[type] || []);\n            for (var i = 0, len = eventListeners.length; i < len; i++) {\n                var l = eventListeners[i];\n                if (l.useCapture === useCapture && l.listener === listener) {\n                    return;\n                }\n            }\n            eventListeners.push({ listener: listener, useCapture: useCapture });\n        },\n        dispatchEvent: function (type, details) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.dispatchEvent\">\n            /// Raises an event of the specified type and with the specified additional properties.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"details\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_p:details\">\n            /// The set of additional properties to be attached to the event object when the event is raised.\n            /// </param>\n            /// <returns type=\"Boolean\" locid=\"WinJS.Utilities.eventMixin.dispatchEvent_returnValue\">\n            /// true if preventDefault was called on the event.\n            /// </returns>\n            /// </signature>\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                var eventValue = new EventMixinEvent(type, details, this);\n                // Need to copy the array to protect against people unregistering while we are dispatching\n                listeners = listeners.slice(0, listeners.length);\n                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {\n                    listeners[i].listener(eventValue);\n                }\n                return eventValue.defaultPrevented || false;\n            }\n            return false;\n        },\n        removeEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// <summary locid=\"WinJS.Utilities.eventMixin.removeEventListener\">\n            /// Removes an event listener from the control.\n            /// </summary>\n            /// <param name=\"type\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:type\">\n            /// The type (name) of the event.\n            /// </param>\n            /// <param name=\"listener\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:listener\">\n            /// The listener to remove.\n            /// </param>\n            /// <param name=\"useCapture\" locid=\"WinJS.Utilities.eventMixin.removeEventListener_p:useCapture\">\n            /// Specifies whether to initiate capture.\n            /// </param>\n            /// </signature>\n            useCapture = useCapture || false;\n            var listeners = this._listeners && this._listeners[type];\n            if (listeners) {\n                for (var i = 0, len = listeners.length; i < len; i++) {\n                    var l = listeners[i];\n                    if (l.listener === listener && l.useCapture === useCapture) {\n                        listeners.splice(i, 1);\n                        if (listeners.length === 0) {\n                            delete this._listeners[type];\n                        }\n                        // Only want to remove one element for each call to removeEventListener\n                        break;\n                    }\n                }\n            }\n        }\n    };\n\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        _createEventProperty: createEventProperty,\n        createEventProperties: createEventProperties,\n        eventMixin: eventMixin\n    });\n\n})(this.WinJS);\n\n\n(function resourcesInit(global, WinJS, undefined) {\n    \"use strict\";\n\n    var resourceMap;\n    var mrtEventHook = false;\n    var contextChangedET = \"contextchanged\";\n\n    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /* empty */ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);\n    var listeners = new ListenerType();\n\n    var strings = {\n\t\t// MONACO CHANGE\n        //get malformedFormatStringInput() { return WinJS.Resources._getWinJSString(\"base/malformedFormatStringInput\").value; },\n\t\tmalformedFormatStringInput: \"Malformed, did you mean to escape your '{0}'?\"\n    };\n\n    WinJS.Namespace.define(\"WinJS.Resources\", {\n        addEventListener: function (type, listener, useCapture) {\n            /// <signature helpKeyword=\"WinJS.Resources.addEventListener\">\n            /// <summary locid=\"WinJS.Resources.addEventListener\">\n            /// Registers an event handler for the specified event.\n            /// </summary>\n            /// <param name=\"type\" type=\"String\" locid=\"WinJS.Resources.addEventListener_p:type\">\n            /// The name of the event to handle.\n            /// </param>\n            /// <param name=\"listener\" type=\"Function\" locid=\"WinJS.Resources.addEventListener_p:listener\">\n            /// The listener to invoke when the event gets raised.\n            /// </param>\n            /// <param name=\"useCapture\" type=\"Boolean\" locid=\"WinJS.Resources.addEventListener_p:useCapture\">\n            /// Set to true to register the event handler for the capturing phase; set to false to register for the bubbling phase.\n            /// </param>\n            /// </signature>\n            if (WinJS.Utilities.hasWinRT && !mrtEventHook) {\n                if (type === contextChangedET) {\n                    try {\n                        Windows.ApplicationModel.Resources.Core.ResourceManager.current.defaultContext.qualifierValues.addEventListener(\"mapchanged\", function (e) {\n                            WinJS.Resources.dispatchEvent(contextChangedET, { qualifier: e.key, changed: e.target[e.key] });\n                        }, false);\n\n                        mrtEventHook = true;\n                    } catch (e) {\n                    }\n                }\n            }\n            listeners.addEventListener(type, listener, useCapture);\n        },\n        removeEventListener: listeners.removeEventListener.bind(listeners),\n        dispatchEvent: listeners.dispatchEvent.bind(listeners),\n\n        _formatString: function (string) {\n            var args = arguments;\n            if (args.length > 1) {\n                string = string.replace(/({{)|(}})|{(\\d+)}|({)|(})/g, function (unused, left, right, index, illegalLeft, illegalRight) {\n                    if (illegalLeft || illegalRight) { throw WinJS.Resources._formatString(strings.malformedFormatStringInput, illegalLeft || illegalRight); }\n                    return (left && \"{\") || (right && \"}\") || args[(index|0) + 1];\n                });\n            }\n            return string;\n        },\n\n        _getStringWinRT: function (resourceId) {\n            if (!resourceMap) {\n                var mainResourceMap = Windows.ApplicationModel.Resources.Core.ResourceManager.current.mainResourceMap;\n                try {\n                    resourceMap = mainResourceMap.getSubtree('Resources');\n                }\n                catch (e) {\n                }\n                if (!resourceMap) {\n                    resourceMap = mainResourceMap;\n                }\n            }\n\n            var stringValue;\n            var langValue;\n            var resCandidate;\n            try {\n                resCandidate = resourceMap.getValue(resourceId);\n                if (resCandidate) {\n                    stringValue = resCandidate.valueAsString;\n                    if (stringValue === undefined) {\n                        stringValue = resCandidate.toString();\n                    }\n                }\n            }\n            catch (e) {}\n\n            if (!stringValue) {\n                return { value: resourceId, empty: true };\n            }\n\n            try {\n                langValue = resCandidate.getQualifierValue(\"Language\");\n            }\n            catch (e) {\n                return { value: stringValue };\n            }\n\n            return { value: stringValue, lang: langValue };\n        },\n\n        _getStringJS: function (resourceId) {\n            var str = global.strings && global.strings[resourceId];\n            if (typeof str === \"string\") {\n                str = { value: str };\n            }\n            return str || { value: resourceId, empty: true };\n        }\n    });\n\n    Object.defineProperties(WinJS.Resources, WinJS.Utilities.createEventProperties(contextChangedET));\n\n    var getStringImpl;\n\n    WinJS.Resources.getString = function (resourceId) {\n        /// <signature helpKeyword=\"WinJS.Resources.getString\">\n        /// <summary locid=\"WinJS.Resources.getString\">\n        /// Retrieves the resource string that has the specified resource id.\n        /// </summary>\n        /// <param name=\"resourceId\" type=\"Number\" locid=\"WinJS.Resources.getString._p:resourceId\">\n        /// The resource id of the string to retrieve.\n        /// </param>\n        /// <returns type=\"Object\" locid=\"WinJS.Resources.getString_returnValue\">\n        /// An object that can contain these properties:\n        ///\n        /// value:\n        /// The value of the requested string. This property is always present.\n        ///\n        /// empty:\n        /// A value that specifies whether the requested string wasn't found.\n        /// If its true, the string wasn't found. If its false or undefined,\n        /// the requested string was found.\n        ///\n        /// lang:\n        /// The language of the string, if specified. This property is only present\n        /// for multi-language resources.\n        ///\n        /// </returns>\n        /// </signature>\n        getStringImpl =\n            getStringImpl ||\n                (WinJS.Utilities.hasWinRT\n                    ? WinJS.Resources._getStringWinRT\n                    : WinJS.Resources._getStringJS);\n\n        return getStringImpl(resourceId);\n    };\n\n\n})(this, this.WinJS);\n\n\n(function promiseInit(global, WinJS, undefined) {\n    \"use strict\";\n\n    global.Debug && (global.Debug.setNonUserCodeExceptions = true);\n\n    var ListenerType = WinJS.Class.mix(WinJS.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), WinJS.Utilities.eventMixin);\n    var promiseEventListeners = new ListenerType();\n    // make sure there is a listeners collection so that we can do a more trivial check below\n    promiseEventListeners._listeners = {};\n    var errorET = \"error\";\n    var canceledName = \"Canceled\";\n    var tagWithStack = false;\n    var tag = {\n        promise:            0x01,\n        thenPromise:        0x02,\n        errorPromise:       0x04,\n        exceptionPromise:   0x08,\n        completePromise:    0x10,\n    };\n    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;\n\n    //\n    // Global error counter, for each error which enters the system we increment this once and then\n    // the error number travels with the error as it traverses the tree of potential handlers.\n    //\n    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises\n    // which are in error will get tagged with a ._errorId field. This tagged field is the\n    // contract by which nested promises with errors will be identified as chaining for the\n    // purposes of the callonerror semantics. If a nested promise in error is encountered without\n    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and\n    // a new error id will be minted.\n    //\n    var error_number = 1;\n\n    //\n    // The state machine has a interesting hiccup in it with regards to notification, in order\n    // to flatten out notification and avoid recursion for synchronous completion we have an\n    // explicit set of *_notify states which are responsible for notifying their entire tree\n    // of children. They can do this because they know that immediate children are always\n    // ThenPromise instances and we can therefore reach into their state to access the\n    // _listeners collection.\n    //\n    // So, what happens is that a Promise will be fulfilled through the _completed or _error\n    // messages at which point it will enter a *_notify state and be responsible for to move\n    // its children into an (as appropriate) success or error state and also notify that child's\n    // listeners of the state transition, until leaf notes are reached.\n    //\n\n    var state_created,              // -> working\n        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting\n        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled\n        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling\n        state_canceled,             // -> error | error_notify | success | success_notify | canceling\n        state_canceling,            // -> error_notify\n        state_success_notify,       // -> success\n        state_success,              // -> .\n        state_error_notify,         // -> error\n        state_error;                // -> .\n\n    // Noop function, used in the various states to indicate that they don't support a given\n    // message. Named with the somewhat cute name '_' because it reads really well in the states.\n\n    function _() { }\n\n    // Initial state\n    //\n    state_created = {\n        name: \"created\",\n        enter: function (promise) {\n            promise._setState(state_working);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Ready state, waiting for a message (completed/error/progress), able to be canceled\n    //\n    state_working = {\n        name: \"working\",\n        enter: _,\n        cancel: function (promise) {\n            promise._setState(state_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting state, if a promise is completed with a value which is itself a promise\n    // (has a then() method) it signs up to be informed when that child promise is\n    // fulfilled at which point it will be fulfilled with that value.\n    //\n    state_waiting = {\n        name: \"waiting\",\n        enter: function (promise) {\n            var waitedUpon = promise._value;\n            var error = function (value) {\n                if (waitedUpon._errorId) {\n                    promise._chainedError(value, waitedUpon);\n                } else {\n                    // Because this is an interop boundary we want to indicate that this\n                    //  error has been handled by the promise infrastructure before we\n                    //  begin a new handling chain.\n                    //\n                    callonerror(promise, value, detailsForHandledError, waitedUpon, error);\n                    promise._error(value);\n                }\n            };\n            error.handlesOnError = true;\n            waitedUpon.then(\n                promise._completed.bind(promise),\n                error,\n                promise._progress.bind(promise)\n            );\n        },\n        cancel: function (promise) {\n            promise._setState(state_waiting_canceled);\n        },\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Waiting canceled state, when a promise has been in a waiting state and receives a\n    // request to cancel its pending work it will forward that request to the child promise\n    // and then waits to be informed of the result. This promise moves itself into the\n    // canceling state but understands that the child promise may instead push it to a\n    // different state.\n    //\n    state_waiting_canceled = {\n        name: \"waiting_canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. Triggering a cancel on the promise\n            // that we are waiting upon may result in a different state transition\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            var waitedUpon = promise._value;\n            if (waitedUpon.cancel) {\n                waitedUpon.cancel();\n            }\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceled state, moves to the canceling state and then tells the promise to do\n    // whatever it might need to do on cancelation.\n    //\n    state_canceled = {\n        name: \"canceled\",\n        enter: function (promise) {\n            // Initiate a transition to canceling. The _cancelAction may change the state\n            // before the state machine pump runs again.\n            promise._setState(state_canceling);\n            promise._cancelAction();\n        },\n        cancel: _,\n        done: done,\n        then: then,\n        _completed: completed,\n        _error: error,\n        _notify: _,\n        _progress: progress,\n        _setCompleteValue: setCompleteValue,\n        _setErrorValue: setErrorValue\n    };\n\n    // Canceling state, commits to the promise moving to an error state with an error\n    // object whose 'name' and 'message' properties contain the string \"Canceled\"\n    //\n    state_canceling = {\n        name: \"canceling\",\n        enter: function (promise) {\n            var error = new Error(canceledName);\n            error.name = error.message;\n            promise._value = error;\n            promise._setState(state_error_notify);\n        },\n        cancel: _,\n        done: _,\n        then: _,\n        _completed: _,\n        _error: _,\n        _notify: _,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success notify state, moves a promise to the success state and notifies all children\n    //\n    state_success_notify = {\n        name: \"complete_notify\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.pop();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_success);\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Success state, moves a promise to the success state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_success = {\n        name: \"success\",\n        enter: function (promise) {\n            promise.done = CompletePromise.prototype.done;\n            promise.then = CompletePromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here */\n        then: null, /*error to get here */\n        _completed: _,\n        _error: _,\n        _notify: notifySuccess,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error notify state, moves a promise to the error state and notifies all children\n    //\n    state_error_notify = {\n        name: \"error_notify\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            if (promise._listeners) {\n                var queue = [promise];\n                var p;\n                while (queue.length) {\n                    p = queue.pop();\n                    p._state._notify(p, queue);\n                }\n            }\n            promise._setState(state_error);\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    // Error state, moves a promise to the error state and does NOT notify any children.\n    // Some upstream promise is owning the notification pass.\n    //\n    state_error = {\n        name: \"error\",\n        enter: function (promise) {\n            promise.done = ErrorPromise.prototype.done;\n            promise.then = ErrorPromise.prototype.then;\n            promise._cleanupAction();\n        },\n        cancel: _,\n        done: null, /*error to get here*/\n        then: null, /*error to get here*/\n        _completed: _,\n        _error: _,\n        _notify: notifyError,\n        _progress: _,\n        _setCompleteValue: _,\n        _setErrorValue: _\n    };\n\n    //\n    // The statemachine implementation follows a very particular pattern, the states are specified\n    // as static stateless bags of functions which are then indirected through the state machine\n    // instance (a Promise). As such all of the functions on each state have the promise instance\n    // passed to them explicitly as a parameter and the Promise instance members do a little\n    // dance where they indirect through the state and insert themselves in the argument list.\n    //\n    // We could instead call directly through the promise states however then every caller\n    // would have to remember to do things like pumping the state machine to catch state transitions.\n    //\n\n    var PromiseStateMachine = WinJS.Class.define(null, {\n        _listeners: null,\n        _nextState: null,\n        _state: null,\n        _value: null,\n\n        cancel: function () {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n            /// already been fulfilled and cancellation is supported, the promise enters\n            /// the error state with a value of Error(\"Canceled\").\n            /// </summary>\n            /// </signature>\n            this._state.cancel(this);\n            this._run();\n        },\n        done: function Promise_done(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            ///\n            /// After the handlers have finished executing, this function throws any error that would have been returned\n            /// from then() as a promise in the error state.\n            /// </summary>\n            /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The fulfilled value is passed as the single argument. If the value is null,\n            /// the fulfilled value is returned. The value returned\n            /// from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while executing the function, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function is the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n            /// the function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// </signature>\n            this._state.done(this, onComplete, onError, onProgress);\n        },\n        then: function Promise_then(onComplete, onError, onProgress) {\n            /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n            /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n            /// Allows you to specify the work to be done on the fulfillment of the promised value,\n            /// the error handling to be performed if the promise fails to fulfill\n            /// a value, and the handling of progress notifications along the way.\n            /// </summary>\n            /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n            /// The function to be called if the promise is fulfilled successfully with a value.\n            /// The value is passed as the single argument. If the value is null, the value is returned.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by\n            /// then(). If an exception is thrown while this function is being executed, the promise returned\n            /// by then() moves into the error state.\n            /// </param>\n            /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n            /// The function to be called if the promise is fulfilled with an error. The error\n            /// is passed as the single argument. If it is null, the error is forwarded.\n            /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n            /// </param>\n            /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n            /// The function to be called if the promise reports progress. Data about the progress\n            /// is passed as the single argument. Promises are not required to support\n            /// progress.\n            /// </param>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n            /// The promise whose value is the result of executing the complete or\n            /// error function.\n            /// </returns>\n            /// </signature>\n            return this._state.then(this, onComplete, onError, onProgress);\n        },\n\n        _chainedError: function (value, context) {\n            var result = this._state._error(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _completed: function (value) {\n            var result = this._state._completed(this, value);\n            this._run();\n            return result;\n        },\n        _error: function (value) {\n            var result = this._state._error(this, value, detailsForError);\n            this._run();\n            return result;\n        },\n        _progress: function (value) {\n            this._state._progress(this, value);\n        },\n        _setState: function (state) {\n            this._nextState = state;\n        },\n        _setCompleteValue: function (value) {\n            this._state._setCompleteValue(this, value);\n            this._run();\n        },\n        _setChainedErrorValue: function (value, context) {\n            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);\n            this._run();\n            return result;\n        },\n        _setExceptionValue: function (value) {\n            var result = this._state._setErrorValue(this, value, detailsForException);\n            this._run();\n            return result;\n        },\n        _run: function () {\n            while (this._nextState) {\n                this._state = this._nextState;\n                this._nextState = null;\n                this._state.enter(this);\n            }\n        }\n    }, {\n        supportedForProcessing: false\n    });\n\n    //\n    // Implementations of shared state machine code.\n    //\n\n    function completed(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success_notify;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function createErrorDetails(exception, error, promise, id, parent, handler) {\n        return {\n            exception: exception,\n            error: error,\n            promise: promise,\n            handler: handler,\n            id: id,\n            parent: parent\n        };\n    }\n    function detailsForHandledError(promise, errorValue, context, handler) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context,\n            handler\n        );\n    }\n    function detailsForChainedError(promise, errorValue, context) {\n        var exception = context._isException;\n        var errorId = context._errorId;\n        setErrorInfo(promise, errorId, exception);\n        return createErrorDetails(\n            exception ? errorValue : null,\n            exception ? null : errorValue,\n            promise,\n            errorId,\n            context\n        );\n    }\n    function detailsForError(promise, errorValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId);\n        return createErrorDetails(\n            null,\n            errorValue,\n            promise,\n            errorId\n        );\n    }\n    function detailsForException(promise, exceptionValue) {\n        var errorId = ++error_number;\n        setErrorInfo(promise, errorId, true);\n        return createErrorDetails(\n            exceptionValue,\n            null,\n            promise,\n            errorId\n        );\n    }\n    function done(promise, onComplete, onError, onProgress) {\n        pushListener(promise, { c: onComplete, e: onError, p: onProgress });\n    }\n    function error(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error_notify);\n    }\n    function notifySuccess(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onComplete = listener.c;\n            var target = listener.promise;\n            if (target) {\n                try {\n                    target._setCompleteValue(onComplete ? onComplete(value) : value);\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                CompletePromise.prototype.done.call(promise, onComplete);\n            }\n        }\n    }\n    function notifyError(promise, queue) {\n        var value = promise._value;\n        var listeners = promise._listeners;\n        if (!listeners) {\n            return;\n        }\n        promise._listeners = null;\n        var i, len;\n        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n            var listener = len === 1 ? listeners : listeners[i];\n            var onError = listener.e;\n            var target = listener.promise;\n            if (target) {\n                try {\n                    if (onError) {\n                        if (!onError.handlesOnError) {\n                            callonerror(target, value, detailsForHandledError, promise, onError);\n                        }\n                        target._setCompleteValue(onError(value))\n                    } else {\n                        target._setChainedErrorValue(value, promise);\n                    }\n                } catch (ex) {\n                    target._setExceptionValue(ex);\n                }\n                if (target._state !== state_waiting && target._listeners) {\n                    queue.push(target);\n                }\n            } else {\n                ErrorPromise.prototype.done.call(promise, null, onError);\n            }\n        }\n    }\n    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {\n        if (promiseEventListeners._listeners[errorET]) {\n            if (value instanceof Error && value.message === canceledName) {\n                return;\n            }\n            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));\n        }\n    }\n    function progress(promise, value) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            var i, len;\n            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {\n                var listener = len === 1 ? listeners : listeners[i];\n                var onProgress = listener.p;\n                if (onProgress) {\n                    try { onProgress(value); } catch (ex) { }\n                }\n                if (!(listener.c || listener.e) && listener.promise) {\n                    listener.promise._progress(value);\n                }\n            }\n        }\n    }\n    function pushListener(promise, listener) {\n        var listeners = promise._listeners;\n        if (listeners) {\n            // We may have either a single listener (which will never be wrapped in an array)\n            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener\n            // we may have to wrap the single listener before adding the second.\n            listeners = Array.isArray(listeners) ? listeners : [listeners];\n            listeners.push(listener);\n        } else {\n            listeners = listener;\n        }\n        promise._listeners = listeners;\n    }\n    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves\n    // a promise directly to the success/error state without starting another notification pass (because one\n    // is already ongoing).\n    function setErrorInfo(promise, errorId, isException) {\n        promise._isException = isException || false;\n        promise._errorId = errorId;\n    }\n    function setErrorValue(promise, value, onerrorDetails, context) {\n        promise._value = value;\n        callonerror(promise, value, onerrorDetails, context);\n        promise._setState(state_error);\n    }\n    function setCompleteValue(promise, value) {\n        var targetState;\n        if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n            targetState = state_waiting;\n        } else {\n            targetState = state_success;\n        }\n        promise._value = value;\n        promise._setState(targetState);\n    }\n    function then(promise, onComplete, onError, onProgress) {\n        var result = new ThenPromise(promise);\n        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress });\n        return result;\n    }\n\n    //\n    // Internal implementation detail promise, ThenPromise is created when a promise needs\n    // to be returned from a then() method.\n    //\n    var ThenPromise = WinJS.Class.derive(PromiseStateMachine,\n        function (creator) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._creator = creator;\n            this._setState(state_created);\n            this._run();\n        }, {\n            _creator: null,\n\n            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },\n            _cleanupAction: function () { this._creator = null; }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Slim promise implementations for already completed promises, these are created\n    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap\n    // and WinJS.Promise.wrapError.\n    //\n\n    var ErrorPromise = WinJS.Class.define(\n        function ErrorPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForError);\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function ErrorPromise_done(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                var value = this._value;\n                if (onError) {\n                    try {\n                        if (!onError.handlesOnError) {\n                            callonerror(null, value, detailsForHandledError, this, onError);\n                        }\n                        var result = onError(value);\n                        if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                            // If a promise is returned we need to wait on it.\n                            result.done();\n                        }\n                        return;\n                    } catch (ex) {\n                        value = ex;\n                    }\n                }\n                if (value instanceof Error && value.message === canceledName) {\n                    // suppress cancel\n                    return;\n                }\n                // force the exception to be thrown asyncronously to avoid any try/catch blocks\n                //\n                setImmediate(function () {\n                    throw value;\n                });\n            },\n            then: function ErrorPromise_then(unused, onError) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n\n                // If the promise is already in a error state and no error handler is provided\n                // we optimize by simply returning the promise instead of creating a new one.\n                //\n                if (!onError) { return this; }\n                var result;\n                var value = this._value;\n                try {\n                    if (!onError.handlesOnError) {\n                        callonerror(null, value, detailsForHandledError, this, onError);\n                    }\n                    result = new CompletePromise(onError(value));\n                } catch (ex) {\n                    // If the value throw from the error handler is the same as the value\n                    // provided to the error handler then there is no need for a new promise.\n                    //\n                    if (ex === value) {\n                        result = this;\n                    } else {\n                        result = new ExceptionPromise(ex);\n                    }\n                }\n                return result;\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var ExceptionPromise = WinJS.Class.derive(ErrorPromise,\n        function ExceptionPromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._value = value;\n            callonerror(this, value, detailsForException);\n        }, {\n            /* empty */\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var CompletePromise = WinJS.Class.define(\n        function CompletePromise_ctor(value) {\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                var result = new ThenPromise(null);\n                result._setCompleteValue(value);\n                return result;\n            }\n            this._value = value;\n        }, {\n            cancel: function () {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.cancel\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.cancel\">\n                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't\n                /// already been fulfilled and cancellation is supported, the promise enters\n                /// the error state with a value of Error(\"Canceled\").\n                /// </summary>\n                /// </signature>\n            },\n            done: function CompletePromise_done(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.done\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.done\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                ///\n                /// After the handlers have finished executing, this function throws any error that would have been returned\n                /// from then() as a promise in the error state.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.done_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The fulfilled value is passed as the single argument. If the value is null,\n                /// the fulfilled value is returned. The value returned\n                /// from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while executing the function, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function is the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.done_p:onProgress\">\n                /// the function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// </signature>\n                if (!onComplete) { return; }\n                try {\n                    var result = onComplete(this._value);\n                    if (result && typeof result === \"object\" && typeof result.done === \"function\") {\n                        result.done();\n                    }\n                } catch (ex) {\n                    // force the exception to be thrown asynchronously to avoid any try/catch blocks\n                    setImmediate(function () {\n                        throw ex;\n                    });\n                }\n            },\n            then: function CompletePromise_then(onComplete) {\n                /// <signature helpKeyword=\"WinJS.PromiseStateMachine.then\">\n                /// <summary locid=\"WinJS.PromiseStateMachine.then\">\n                /// Allows you to specify the work to be done on the fulfillment of the promised value,\n                /// the error handling to be performed if the promise fails to fulfill\n                /// a value, and the handling of progress notifications along the way.\n                /// </summary>\n                /// <param name='onComplete' type='Function' locid=\"WinJS.PromiseStateMachine.then_p:onComplete\">\n                /// The function to be called if the promise is fulfilled successfully with a value.\n                /// The value is passed as the single argument. If the value is null, the value is returned.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by\n                /// then(). If an exception is thrown while this function is being executed, the promise returned\n                /// by then() moves into the error state.\n                /// </param>\n                /// <param name='onError' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onError\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument. If it is null, the error is forwarded.\n                /// The value returned from the function becomes the fulfilled value of the promise returned by then().\n                /// </param>\n                /// <param name='onProgress' type='Function' optional='true' locid=\"WinJS.PromiseStateMachine.then_p:onProgress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.PromiseStateMachine.then_returnValue\">\n                /// The promise whose value is the result of executing the complete or\n                /// error function.\n                /// </returns>\n                /// </signature>\n                try {\n                    // If the value returned from the completion handler is the same as the value\n                    // provided to the completion handler then there is no need for a new promise.\n                    //\n                    var newValue = onComplete ? onComplete(this._value) : this._value;\n                    return newValue === this._value ? this : new CompletePromise(newValue);\n                } catch (ex) {\n                    return new ExceptionPromise(ex);\n                }\n            }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    //\n    // Promise is the user-creatable WinJS.Promise object.\n    //\n\n    function timeout(timeoutMS) {\n        var id;\n        return new WinJS.Promise(\n            function (c) {\n                if (timeoutMS) {\n                    id = setTimeout(c, timeoutMS);\n                } else {\n                    setImmediate(c);\n                }\n            },\n            function () {\n                if (id) {\n                    clearTimeout(id);\n                }\n            }\n        );\n    }\n\n    function timeoutWithPromise(timeout, promise) {\n        var cancelPromise = function () { promise.cancel(); }\n        var cancelTimeout = function () { timeout.cancel(); }\n        timeout.then(cancelPromise);\n        promise.then(cancelTimeout, cancelTimeout);\n        return promise;\n    }\n\n    var staticCanceledPromise;\n\n    var Promise = WinJS.Class.derive(PromiseStateMachine,\n        function Promise_ctor(init, oncancel) {\n            /// <signature helpKeyword=\"WinJS.Promise\">\n            /// <summary locid=\"WinJS.Promise\">\n            /// A promise provides a mechanism to schedule work to be done on a value that\n            /// has not yet been computed. It is a convenient abstraction for managing\n            /// interactions with asynchronous APIs.\n            /// </summary>\n            /// <param name=\"init\" type=\"Function\" locid=\"WinJS.Promise_p:init\">\n            /// The function that is called during construction of the  promise. The function\n            /// is given three arguments (complete, error, progress). Inside this function\n            /// you should add event listeners for the notifications supported by this value.\n            /// </param>\n            /// <param name=\"oncancel\" optional=\"true\" locid=\"WinJS.Promise_p:oncancel\">\n            /// The function to call if a consumer of this promise wants\n            /// to cancel its undone work. Promises are not required to\n            /// support cancellation.\n            /// </param>\n            /// </signature>\n\n            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {\n                this._stack = WinJS.Promise._getStack();\n            }\n\n            this._oncancel = oncancel;\n            this._setState(state_created);\n            this._run();\n\n            try {\n                var complete = this._completed.bind(this);\n                var error = this._error.bind(this);\n                var progress = this._progress.bind(this);\n                init(complete, error, progress);\n            } catch (ex) {\n                this._setExceptionValue(ex);\n            }\n        }, {\n            _oncancel: null,\n\n            _cancelAction: function () {\n\t\t\t\ttry {\n            \t\tif (this._oncancel) {\n\t\t\t\t\t\tthis._oncancel();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Promise did not implement oncancel');\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\t// Access fields to get them created\n\t\t\t\t\tvar msg = ex.message;\n\t\t\t\t\tvar stack = ex.stack;\n\t\t\t\t\tpromiseEventListeners.dispatchEvent('error', ex);\n\t\t\t\t}\n            },\n            _cleanupAction: function () { this._oncancel = null; }\n        }, {\n\n            addEventListener: function Promise_addEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.addEventListener\">\n                /// <summary locid=\"WinJS.Promise.addEventListener\">\n                /// Adds an event listener to the control.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.addEventListener_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"listener\" locid=\"WinJS.Promise.addEventListener_p:listener\">\n                /// The listener to invoke when the event is raised.\n                /// </param>\n                /// <param name=\"capture\" locid=\"WinJS.Promise.addEventListener_p:capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.addEventListener(eventType, listener, capture);\n            },\n            any: function Promise_any(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.any\">\n                /// <summary locid=\"WinJS.Promise.any\">\n                /// Returns a promise that is fulfilled when one of the input promises\n                /// has been fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Array\" locid=\"WinJS.Promise.any_p:values\">\n                /// An array that contains promise objects or objects whose property\n                /// values include promise objects.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.any_returnValue\">\n                /// A promise that on fulfillment yields the value of the input (complete or error).\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error, progress) {\n                        var keys = Object.keys(values);\n                        var errors = Array.isArray(values) ? [] : {};\n                        if (keys.length === 0) {\n                            complete();\n                        }\n                        var canceled = 0;\n                        keys.forEach(function (key) {\n                            Promise.as(values[key]).then(\n                                function () { complete({ key: key, value: values[key] }); },\n                                function (e) {\n                                    if (e instanceof Error && e.name === canceledName) {\n                                        if ((++canceled) === keys.length) {\n                                            complete(WinJS.Promise.cancel);\n                                        }\n                                        return;\n                                    }\n                                    error({ key: key, value: values[key] });\n                                }\n                            );\n                        });\n                    },\n                    function () {\n                        var keys = Object.keys(values);\n                        keys.forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            as: function Promise_as(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.as\">\n                /// <summary locid=\"WinJS.Promise.as\">\n                /// Returns a promise. If the object is already a promise it is returned;\n                /// otherwise the object is wrapped in a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.as_p:value\">\n                /// The value to be treated as a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.as_returnValue\">\n                /// A promise.\n                /// </returns>\n                /// </signature>\n                if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n                    return value;\n                }\n                return new CompletePromise(value);\n            },\n            /// <field type=\"WinJS.Promise\" helpKeyword=\"WinJS.Promise.cancel\" locid=\"WinJS.Promise.cancel\">\n            /// Canceled promise value, can be returned from a promise completion handler\n            /// to indicate cancelation of the promise chain.\n            /// </field>\n            cancel: {\n                get: function () {\n                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new WinJS.ErrorFromName(canceledName)));\n                }\n            },\n            dispatchEvent: function Promise_dispatchEvent(eventType, details) {\n                /// <signature helpKeyword=\"WinJS.Promise.dispatchEvent\">\n                /// <summary locid=\"WinJS.Promise.dispatchEvent\">\n                /// Raises an event of the specified type and properties.\n                /// </summary>\n                /// <param name=\"eventType\" locid=\"WinJS.Promise.dispatchEvent_p:eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name=\"details\" locid=\"WinJS.Promise.dispatchEvent_p:details\">\n                /// The set of additional properties to be attached to the event object.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.dispatchEvent_returnValue\">\n                /// Specifies whether preventDefault was called on the event.\n                /// </returns>\n                /// </signature>\n                return promiseEventListeners.dispatchEvent(eventType, details);\n            },\n            is: function Promise_is(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.is\">\n                /// <summary locid=\"WinJS.Promise.is\">\n                /// Determines whether a value fulfills the promise contract.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.is_p:value\">\n                /// A value that may be a promise.\n                /// </param>\n                /// <returns type=\"Boolean\" locid=\"WinJS.Promise.is_returnValue\">\n                /// true if the specified value is a promise, otherwise false.\n                /// </returns>\n                /// </signature>\n                return value && typeof value === \"object\" && typeof value.then === \"function\";\n            },\n            join: function Promise_join(values) {\n                /// <signature helpKeyword=\"WinJS.Promise.join\">\n                /// <summary locid=\"WinJS.Promise.join\">\n                /// Creates a promise that is fulfilled when all the values are fulfilled.\n                /// </summary>\n                /// <param name=\"values\" type=\"Object\" locid=\"WinJS.Promise.join_p:values\">\n                /// An object whose fields contain values, some of which may be promises.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.join_returnValue\">\n                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where\n                /// each field value is the fulfilled value of a promise.\n                /// </returns>\n                /// </signature>\n                return new Promise(\n                    function (complete, error, progress) {\n                        var keys = Object.keys(values);\n                        var errors = Array.isArray(values) ? [] : {};\n                        var results = Array.isArray(values) ? [] : {};\n                        var undefineds = 0;\n                        var pending = keys.length;\n                        var argDone = function (key) {\n                            if ((--pending) === 0) {\n                                var errorCount = Object.keys(errors).length;\n                                if (errorCount === 0) {\n                                    complete(results);\n                                } else {\n                                    var canceledCount = 0;\n                                    keys.forEach(function (key) {\n                                        var e = errors[key];\n                                        if (e instanceof Error && e.name === canceledName) {\n                                            canceledCount++;\n                                        }\n                                    });\n                                    if (canceledCount === errorCount) {\n                                        complete(WinJS.Promise.cancel);\n                                    } else {\n                                        error(errors);\n                                    }\n                                }\n                            } else {\n                                progress({ Key: key, Done: true });\n                            }\n                        };\n                        keys.forEach(function (key) {\n                            var value = values[key];\n                            if (value === undefined) {\n                                undefineds++;\n                            } else {\n                                Promise.then(value,\n                                    function (value) { results[key] = value; argDone(key); },\n                                    function (value) { errors[key] = value; argDone(key); }\n                                );\n                            }\n                        });\n                        pending -= undefineds;\n                        if (pending === 0) {\n                            complete(results);\n                            return;\n                        }\n                    },\n                    function () {\n                        Object.keys(values).forEach(function (key) {\n                            var promise = Promise.as(values[key]);\n                            if (typeof promise.cancel === \"function\") {\n                                promise.cancel();\n                            }\n                        });\n                    }\n                );\n            },\n            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {\n                /// <signature helpKeyword=\"WinJS.Promise.removeEventListener\">\n                /// <summary locid=\"WinJS.Promise.removeEventListener\">\n                /// Removes an event listener from the control.\n                /// </summary>\n                /// <param name='eventType' locid=\"WinJS.Promise.removeEventListener_eventType\">\n                /// The type (name) of the event.\n                /// </param>\n                /// <param name='listener' locid=\"WinJS.Promise.removeEventListener_listener\">\n                /// The listener to remove.\n                /// </param>\n                /// <param name='capture' locid=\"WinJS.Promise.removeEventListener_capture\">\n                /// Specifies whether or not to initiate capture.\n                /// </param>\n                /// </signature>\n                promiseEventListeners.removeEventListener(eventType, listener, capture);\n            },\n            supportedForProcessing: false,\n            then: function Promise_then(value, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.then\">\n                /// <summary locid=\"WinJS.Promise.then\">\n                /// A static version of the promise instance method then().\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.then_p:value\">\n                /// the value to be treated as a promise.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.then_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If it is null, the promise simply\n                /// returns the value. The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.then_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.then_returnValue\">\n                /// A promise whose value is the result of executing the provided complete function.\n                /// </returns>\n                /// </signature>\n                return Promise.as(value).then(onComplete, onError, onProgress);\n            },\n            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {\n                /// <signature helpKeyword=\"WinJS.Promise.thenEach\">\n                /// <summary locid=\"WinJS.Promise.thenEach\">\n                /// Performs an operation on all the input promises and returns a promise\n                /// that has the shape of the input and contains the result of the operation\n                /// that has been performed on each input.\n                /// </summary>\n                /// <param name=\"values\" locid=\"WinJS.Promise.thenEach_p:values\">\n                /// A set of values (which could be either an array or an object) of which some or all are promises.\n                /// </param>\n                /// <param name=\"onComplete\" type=\"Function\" locid=\"WinJS.Promise.thenEach_p:complete\">\n                /// The function to be called if the promise is fulfilled with a value.\n                /// If the value is null, the promise returns the value.\n                /// The value is passed as the single argument.\n                /// </param>\n                /// <param name=\"onError\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:error\">\n                /// The function to be called if the promise is fulfilled with an error. The error\n                /// is passed as the single argument.\n                /// </param>\n                /// <param name=\"onProgress\" type=\"Function\" optional=\"true\" locid=\"WinJS.Promise.thenEach_p:progress\">\n                /// The function to be called if the promise reports progress. Data about the progress\n                /// is passed as the single argument. Promises are not required to support\n                /// progress.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.thenEach_returnValue\">\n                /// A promise that is the result of calling Promise.join on the values parameter.\n                /// </returns>\n                /// </signature>\n                var result = Array.isArray(values) ? [] : {};\n                Object.keys(values).forEach(function (key) {\n                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);\n                });\n                return Promise.join(result);\n            },\n            timeout: function Promise_timeout(time, promise) {\n                /// <signature helpKeyword=\"WinJS.Promise.timeout\">\n                /// <summary locid=\"WinJS.Promise.timeout\">\n                /// Creates a promise that is fulfilled after a timeout.\n                /// </summary>\n                /// <param name=\"timeout\" type=\"Number\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:timeout\">\n                /// The timeout period in milliseconds. If this value is zero or not specified\n                /// setImmediate is called, otherwise setTimeout is called.\n                /// </param>\n                /// <param name=\"promise\" type=\"Promise\" optional=\"true\" locid=\"WinJS.Promise.timeout_p:promise\">\n                /// A promise that will be canceled if it doesn't complete before the\n                /// timeout has expired.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.timeout_returnValue\">\n                /// A promise that is completed asynchronously after the specified timeout.\n                /// </returns>\n                /// </signature>\n                var to = timeout(time);\n                return promise ? timeoutWithPromise(to, promise) : to;\n            },\n            wrap: function Promise_wrap(value) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrap\">\n                /// <summary locid=\"WinJS.Promise.wrap\">\n                /// Wraps a non-promise value in a promise. You can use this function if you need\n                /// to pass a value to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"value\" locid=\"WinJS.Promise.wrap_p:value\">\n                /// Some non-promise value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrap_returnValue\">\n                /// A promise that is successfully fulfilled with the specified value\n                /// </returns>\n                /// </signature>\n                return new CompletePromise(value);\n            },\n            wrapError: function Promise_wrapError(error) {\n                /// <signature helpKeyword=\"WinJS.Promise.wrapError\">\n                /// <summary locid=\"WinJS.Promise.wrapError\">\n                /// Wraps a non-promise error value in a promise. You can use this function if you need\n                /// to pass an error to a function that requires a promise.\n                /// </summary>\n                /// <param name=\"error\" locid=\"WinJS.Promise.wrapError_p:error\">\n                /// A non-promise error value to be wrapped in a promise.\n                /// </param>\n                /// <returns type=\"WinJS.Promise\" locid=\"WinJS.Promise.wrapError_returnValue\">\n                /// A promise that is in an error state with the specified value.\n                /// </returns>\n                /// </signature>\n                return new ErrorPromise(error);\n            },\n\n            _veryExpensiveTagWithStack: {\n                get: function () { return tagWithStack; },\n                set: function (value) { tagWithStack = value; }\n            },\n            _veryExpensiveTagWithStack_tag: tag,\n            _getStack: function () {\n                if (Debug.debuggerEnabled) {\n                    try { throw new Error(); } catch (e) { return e.stack; }\n                }\n            },\n\n        }\n    );\n    Object.defineProperties(Promise, WinJS.Utilities.createEventProperties(errorET));\n\n    var SignalPromise = WinJS.Class.derive(PromiseStateMachine,\n        function (cancel) {\n            this._oncancel = cancel;\n            this._setState(state_created);\n            this._run();\n        }, {\n            _cancelAction: function () { this._oncancel && this._oncancel(); },\n            _cleanupAction: function () { this._oncancel = null; }\n        }, {\n            supportedForProcessing: false\n        }\n    );\n\n    var Signal = WinJS.Class.define(\n        function Signal_ctor(oncancel) {\n            this._promise = new SignalPromise(oncancel);\n        }, {\n            promise: {\n                get: function () { return this._promise; }\n            },\n\n            cancel: function Signal_cancel() {\n                this._promise.cancel();\n            },\n            complete: function Signal_complete(value) {\n                this._promise._completed(value);\n            },\n            error: function Signal_error(value) {\n                this._promise._error(value);\n            },\n            progress: function Signal_progress(value) {\n                this._promise._progress(value);\n            }\n        }, {\n            supportedForProcessing: false,\n        }\n    );\n\n    // Publish WinJS.Promise\n    //\n    WinJS.Namespace.define(\"WinJS\", {\n        Promise: Promise,\n        _Signal: Signal\n    });\n\n}(this, this.WinJS));\n\n(function errorsInit(global, WinJS) {\n    \"use strict\";\n\n\n    WinJS.Namespace.define(\"WinJS\", {\n        // ErrorFromName establishes a simple pattern for returning error codes.\n        //\n        ErrorFromName: WinJS.Class.derive(Error, function (name, message) {\n            /// <signature helpKeyword=\"WinJS.ErrorFromName\">\n            /// <summary locid=\"WinJS.ErrorFromName\">\n            /// Creates an Error object with the specified name and message properties.\n            /// </summary>\n            /// <param name=\"name\" type=\"String\" locid=\"WinJS.ErrorFromName_p:name\">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>\n            /// <param name=\"message\" type=\"String\" optional=\"true\" locid=\"WinJS.ErrorFromName_p:message\">The message for this error. The message is meant to be consumed by humans and should be localized.</param>\n            /// <returns type=\"Error\" locid=\"WinJS.ErrorFromName_returnValue\">Error instance with .name and .message properties populated</returns>\n            /// </signature>\n            this.name = name;\n            this.message = message || name;\n        }, {\n            /* empty */\n        }, {\n            supportedForProcessing: false,\n        })\n    });\n\n})(this, this.WinJS);\n\n\n(function xhrInit(WinJS) {\n    \"use strict\";\n\n\n    WinJS.Namespace.define(\"WinJS\", {\n        xhr: function (options) {\n            /// <signature helpKeyword=\"WinJS.xhr\">\n            /// <summary locid=\"WinJS.xhr\">\n            /// Wraps calls to XMLHttpRequest in a promise.\n            /// </summary>\n            /// <param name=\"options\" type=\"Object\" locid=\"WinJS.xhr_p:options\">\n            /// The options that are applied to the XMLHttpRequest object. They are: type,\n            /// url, user, password, headers, responseType, data, and customRequestInitializer.\n            /// </param>\n            /// <returns type=\"WinJS.Promise\" locid=\"WinJS.xhr_returnValue\">\n            /// A promise that returns the XMLHttpRequest object when it completes.\n            /// </returns>\n            /// </signature>\n            var req;\n            return new WinJS.Promise(\n                function (c, e, p) {\n                    /// <returns value=\"c(new XMLHttpRequest())\" locid=\"WinJS.xhr.constructor._returnValue\" />\n                    req = new XMLHttpRequest();\n                    req.onreadystatechange = function () {\n                        if (req._canceled) { return; }\n\n                        if (req.readyState === 4) {\n\t\t\t\t\t\t\t// MONACO CHANGE: Handle 1223: http://bugs.jquery.com/ticket/1450\n                            if ((req.status >= 200 && req.status < 300) || req.status === 1223) {\n                                c(req);\n                            } else {\n                                e(req);\n                            }\n                            req.onreadystatechange = function () { };\n                        } else {\n                            p(req);\n                        }\n                    };\n\n                    req.open(\n                        options.type || \"GET\",\n                        options.url,\n                        // Promise based XHR does not support sync.\n                        //\n                        true,\n                        options.user,\n                        options.password\n                    );\n                    req.responseType = options.responseType || \"\";\n\n                    Object.keys(options.headers || {}).forEach(function (k) {\n                        req.setRequestHeader(k, options.headers[k]);\n                    });\n\n                    if (options.customRequestInitializer) {\n                        options.customRequestInitializer(req);\n                    }\n\n                    req.send(options.data);\n                },\n                function () {\n                    req._canceled = true;\n                    req.abort();\n                }\n            );\n        }\n    });\n\n})(this.WinJS);\n\n\n(function safeHTMLInit(global, WinJS, undefined) {\n    \"use strict\";\n\n\n    var setInnerHTML,\n        setInnerHTMLUnsafe,\n        setOuterHTML,\n        setOuterHTMLUnsafe,\n        insertAdjacentHTML,\n        insertAdjacentHTMLUnsafe;\n\n    var strings = {\n\t\t// MONACO CHANGE\n        //get nonStaticHTML() { return WinJS.Resources._getWinJSString(\"base/nonStaticHTML\").value; },\n\t\tnonStaticHTML: \"Unable to add dynamic content. A script attempted to inject dynamic content, or elements previously modified dynamically, that might be unsafe. For example, using the innerHTML property or the document.write method to add a script element will generate this exception. If the content is safe and from a trusted source, use a method to explicitly manipulate elements and attributes, such as createElement, or use setInnerHTMLUnsafe (or other unsafe method).\"\n    };\n\n    setInnerHTML = setInnerHTMLUnsafe = function (element, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTML\">\n        /// <summary locid=\"WinJS.Utilities.setInnerHTML\">\n        /// Sets the innerHTML property of the specified element to the specified text.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setInnerHTML_p:element\">\n        /// The element on which the innerHTML property is to be set.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setInnerHTML_p:text\">\n        /// The value to be set to the innerHTML property.\n        /// </param>\n        /// </signature>\n        element.innerHTML = text;\n    };\n    setOuterHTML = setOuterHTMLUnsafe = function (element, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTML\">\n        /// <summary locid=\"WinJS.Utilities.setOuterHTML\">\n        /// Sets the outerHTML property of the specified element to the specified text.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setOuterHTML_p:element\">\n        /// The element on which the outerHTML property is to be set.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setOuterHTML_p:text\">\n        /// The value to be set to the outerHTML property.\n        /// </param>\n        /// </signature>\n        element.outerHTML = text;\n    };\n    insertAdjacentHTML = insertAdjacentHTMLUnsafe = function (element, position, text) {\n        /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTML\">\n        /// <summary locid=\"WinJS.Utilities.insertAdjacentHTML\">\n        /// Calls insertAdjacentHTML on the specified element.\n        /// </summary>\n        /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:element\">\n        /// The element on which insertAdjacentHTML is to be called.\n        /// </param>\n        /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:position\">\n        /// The position relative to the element at which to insert the HTML.\n        /// </param>\n        /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTML_p:text\">\n        /// The value to be provided to insertAdjacentHTML.\n        /// </param>\n        /// </signature>\n        element.insertAdjacentHTML(position, text);\n    };\n\n    var msApp = global.MSApp;\n    if (msApp) {\n        setInnerHTMLUnsafe = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.setInnerHTMLUnsafe\">\n            /// Sets the innerHTML property of the specified element to the specified text.\n            /// </summary>\n            /// <param name='element' type='HTMLElement' locid=\"WinJS.Utilities.setInnerHTMLUnsafe_p:element\">\n            /// The element on which the innerHTML property is to be set.\n            /// </param>\n            /// <param name='text' type=\"String\" locid=\"WinJS.Utilities.setInnerHTMLUnsafe_p:text\">\n            /// The value to be set to the innerHTML property.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.innerHTML = text;\n            });\n        };\n        setOuterHTMLUnsafe = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.setOuterHTMLUnsafe\">\n            /// Sets the outerHTML property of the specified element to the specified text\n            /// in the context of msWWA.execUnsafeLocalFunction.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.setOuterHTMLUnsafe_p:element\">\n            /// The element on which the outerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.setOuterHTMLUnsafe_p:text\">\n            /// The value to be set to the outerHTML property.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.outerHTML = text;\n            });\n        };\n        insertAdjacentHTMLUnsafe = function (element, position, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTMLUnsafe\">\n            /// <summary locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe\">\n            /// Calls insertAdjacentHTML on the specified element in the context\n            /// of msWWA.execUnsafeLocalFunction.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:element\">\n            /// The element on which insertAdjacentHTML is to be called.\n            /// </param>\n            /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:position\">\n            /// The position relative to the element at which to insert the HTML.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.insertAdjacentHTMLUnsafe_p:text\">\n            /// Value to be provided to insertAdjacentHTML.\n            /// </param>\n            /// </signature>\n            msApp.execUnsafeLocalFunction(function () {\n                element.insertAdjacentHTML(position, text);\n            });\n        };\n    }\n    else if (global.msIsStaticHTML) {\n        var check = function (str) {\n            if (!global.msIsStaticHTML(str)) {\n                throw new WinJS.ErrorFromName(\"WinJS.Utitilies.NonStaticHTML\", strings.nonStaticHTML);\n            }\n        }\n        // If we ever get isStaticHTML we can attempt to recreate the behavior we have in the local\n        // compartment, in the mean-time all we can do is sanitize the input.\n        //\n        setInnerHTML = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setInnerHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML\">\n            /// Sets the innerHTML property of a element to the specified text\n            /// if it passes a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:element\">\n            /// The element on which the innerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.setInnerHTML_p:text\">\n            /// The value to be set to the innerHTML property.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.innerHTML = text;\n        };\n        setOuterHTML = function (element, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.setOuterHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML\">\n            /// Sets the outerHTML property of a element to the specified text\n            /// if it passes a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:element\">\n            /// The element on which the outerHTML property is to be set.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.setOuterHTML_p:text\">\n            /// The value to be set to the outerHTML property.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.outerHTML = text;\n        };\n        insertAdjacentHTML = function (element, position, text) {\n            /// <signature helpKeyword=\"WinJS.Utilities.insertAdjacentHTML\">\n            /// <summary locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML\">\n            /// Calls insertAdjacentHTML on the element if it passes\n            /// a msIsStaticHTML check.\n            /// </summary>\n            /// <param name=\"element\" type=\"HTMLElement\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:element\">\n            /// The element on which insertAdjacentHTML is to be called.\n            /// </param>\n            /// <param name=\"position\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:position\">\n            /// The position relative to the element at which to insert the HTML.\n            /// </param>\n            /// <param name=\"text\" type=\"String\" locid=\"WinJS.Utilities.msIsStaticHTML.insertAdjacentHTML_p:text\">\n            /// The value to be provided to insertAdjacentHTML.\n            /// </param>\n            /// </signature>\n            check(text);\n            element.insertAdjacentHTML(position, text);\n        };\n    }\n\n    WinJS.Namespace.define(\"WinJS.Utilities\", {\n        setInnerHTML: setInnerHTML,\n        setInnerHTMLUnsafe: setInnerHTMLUnsafe,\n        setOuterHTML: setOuterHTML,\n        setOuterHTMLUnsafe: setOuterHTMLUnsafe,\n        insertAdjacentHTML: insertAdjacentHTML,\n        insertAdjacentHTMLUnsafe: insertAdjacentHTMLUnsafe\n    });\n\n}(this, this.WinJS));\n\n\n\n// MONACO CHANGE\n} // if (typeof WinJS === 'undefined')\n\n(function(global) {\n\n    if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {\n        define(\"vs/base/common/winjs.base.raw\", global.WinJS);\n    } else {\n        module.exports = global.WinJS;\n    }\n\n})(this);","define(\"vs/nls!vs/base/common/errors\",['vs/nls', 'vs/nls!vs/base/common/worker/simpleWorker'], function(nls, data) { return nls.create(\"vs/base/common/errors\", data); });","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport nls = require('vs/nls');\nimport objects = require('vs/base/common/objects');\nimport platform = require('vs/base/common/platform');\nimport types = require('vs/base/common/types');\nimport arrays = require('vs/base/common/arrays');\nimport strings = require('vs/base/common/strings');\nimport {IAction} from 'vs/base/common/actions';\nimport {IXHRResponse} from 'vs/base/common/http';\nimport Severity from 'vs/base/common/severity';\nimport { TPromise } from 'vs/base/common/winjs.base';\n\nexport interface ErrorListenerCallback {\n\t(error: any): void;\n}\n\nexport interface ErrorListenerUnbind {\n\t(): void;\n}\n\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n\tprivate unexpectedErrorHandler: (e: any) => void;\n\tprivate listeners: ErrorListenerCallback[];\n\n\tconstructor() {\n\n\t\tthis.listeners = [];\n\n\t\tthis.unexpectedErrorHandler = function(e: any) {\n\t\t\tplatform.setTimeout(() => {\n\t\t\t\tif (e.stack) {\n\t\t\t\t\tthrow new Error(e.message + '\\n\\n' + e.stack);\n\t\t\t\t}\n\n\t\t\t\tthrow e;\n\t\t\t}, 0);\n\t\t};\n\t}\n\n\tpublic addListener(listener: ErrorListenerCallback): ErrorListenerUnbind {\n\t\tthis.listeners.push(listener);\n\n\t\treturn () => {\n\t\t\tthis._removeListener(listener);\n\t\t};\n\t}\n\n\tprivate emit(e: any): void {\n\t\tthis.listeners.forEach((listener) => {\n\t\t\tlistener(e);\n\t\t});\n\t}\n\n\tprivate _removeListener(listener: ErrorListenerCallback): void {\n\t\tthis.listeners.splice(this.listeners.indexOf(listener), 1);\n\t}\n\n\tpublic setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\t\tthis.unexpectedErrorHandler = newUnexpectedErrorHandler;\n\t}\n\n\tpublic getUnexpectedErrorHandler(): (e: any) => void {\n\t\treturn this.unexpectedErrorHandler;\n\t}\n\n\tpublic onUnexpectedError(e: any): void {\n\t\tthis.unexpectedErrorHandler(e);\n\t\tthis.emit(e);\n\t}\n}\n\nexport let errorHandler = new ErrorHandler();\n\nexport function setUnexpectedErrorHandler(newUnexpectedErrorHandler: (e: any) => void): void {\n\terrorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);\n}\n\nexport function onUnexpectedError(e: any): void {\n\n\t// ignore errors from cancelled promises\n\tif (!isPromiseCanceledError(e)) {\n\t\terrorHandler.onUnexpectedError(e);\n\t}\n}\n\nexport function onUnexpectedPromiseError<T>(promise: TPromise<T>): TPromise<T> {\n\treturn promise.then<T>(null, onUnexpectedError);\n}\n\nexport interface IConnectionErrorData {\n\tstatus: number;\n\tstatusText?: string;\n\tresponseText?: string;\n}\n\nexport function transformErrorForSerialization(error: any): any {\n\tif (error instanceof Error) {\n\t\tlet {name, message} = error;\n\t\tlet stack: string = (<any>error).stacktrace || (<any>error).stack;\n\t\treturn {\n\t\t\t$isError: true,\n\t\t\tname,\n\t\t\tmessage,\n\t\t\tstack\n\t\t};\n\t}\n\n\t// return as is\n\treturn error;\n}\n\n/**\n * The base class for all connection errors originating from XHR requests.\n */\nexport class ConnectionError implements Error {\n\tpublic status: number;\n\tpublic statusText: string;\n\tpublic responseText: string;\n\tpublic errorMessage: string;\n\tpublic errorCode: string;\n\tpublic errorObject: any;\n\tpublic name: string;\n\n\tconstructor(mixin: IConnectionErrorData);\n\tconstructor(request: IXHRResponse);\n\tconstructor(arg: any) {\n\t\tthis.status = arg.status;\n\t\tthis.statusText = arg.statusText;\n\t\tthis.name = 'ConnectionError';\n\n\t\ttry {\n\t\t\tthis.responseText = arg.responseText;\n\t\t} catch (e) {\n\t\t\tthis.responseText = '';\n\t\t}\n\n\t\tthis.errorMessage = null;\n\t\tthis.errorCode = null;\n\t\tthis.errorObject = null;\n\n\t\tif (this.responseText) {\n\t\t\ttry {\n\t\t\t\tlet errorObj = JSON.parse(this.responseText);\n\t\t\t\tthis.errorMessage = errorObj.message;\n\t\t\t\tthis.errorCode = errorObj.code;\n\t\t\t\tthis.errorObject = errorObj;\n\t\t\t} catch (error) {\n\t\t\t\t// Ignore\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get message(): string {\n\t\treturn this.connectionErrorToMessage(this, false);\n\t}\n\n\tpublic get verboseMessage(): string {\n\t\treturn this.connectionErrorToMessage(this, true);\n\t}\n\n\tprivate connectionErrorDetailsToMessage(error: ConnectionError, verbose: boolean): string {\n\t\tlet errorCode = error.errorCode;\n\t\tlet errorMessage = error.errorMessage;\n\n\t\tif (errorCode !== null && errorMessage !== null) {\n\t\t\treturn nls.localize(\n\t\t\t\t{\n\t\t\t\t\tkey: 'message',\n\t\t\t\t\tcomment: [\n\t\t\t\t\t\t'{0} represents the error message',\n\t\t\t\t\t\t'{1} represents the error code'\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"{0}. Error code: {1}\",\n\t\t\t\tstrings.rtrim(errorMessage, '.'), errorCode);\n\t\t}\n\n\t\tif (errorMessage !== null) {\n\t\t\treturn errorMessage;\n\t\t}\n\n\t\tif (verbose && error.responseText !== null) {\n\t\t\treturn error.responseText;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate connectionErrorToMessage(error: ConnectionError, verbose: boolean): string {\n\t\tlet details = this.connectionErrorDetailsToMessage(error, verbose);\n\n\t\t// Status Code based Error\n\t\tif (error.status === 401) {\n\t\t\tif (details !== null) {\n\t\t\t\treturn nls.localize(\n\t\t\t\t\t{\n\t\t\t\t\t\tkey: 'error.permission.verbose',\n\t\t\t\t\t\tcomment: [\n\t\t\t\t\t\t\t'{0} represents detailed information why the permission got denied'\n\t\t\t\t\t\t]\n\t\t\t\t\t},\n\t\t\t\t\t\"Permission Denied (HTTP {0})\",\n\t\t\t\t\tdetails);\n\t\t\t}\n\n\t\t\treturn nls.localize('error.permission', \"Permission Denied\");\n\t\t}\n\n\t\t// Return error details if present\n\t\tif (details) {\n\t\t\treturn details;\n\t\t}\n\n\t\t// Fallback to HTTP Status and Code\n\t\tif (error.status > 0 && error.statusText !== null) {\n\t\t\tif (verbose && error.responseText !== null && error.responseText.length > 0) {\n\t\t\t\treturn nls.localize('error.http.verbose', \"{0} (HTTP {1}: {2})\", error.statusText, error.status, error.responseText);\n\t\t\t}\n\n\t\t\treturn nls.localize('error.http', \"{0} (HTTP {1})\", error.statusText, error.status);\n\t\t}\n\n\t\t// Finally its an Unknown Connection Error\n\t\tif (verbose && error.responseText !== null && error.responseText.length > 0) {\n\t\t\treturn nls.localize('error.connection.unknown.verbose', \"Unknown Connection Error ({0})\", error.responseText);\n\t\t}\n\n\t\treturn nls.localize('error.connection.unknown', \"An unknown connection error occurred. Either you are no longer connected to the internet or the server you are connected to is offline.\");\n\t}\n}\n\n// Bug: Can not subclass a JS Type. Do it manually (as done in WinJS.Class.derive)\nobjects.derive(Error, ConnectionError);\n\nfunction xhrToErrorMessage(xhr: IConnectionErrorData, verbose: boolean): string {\n\tlet ce = new ConnectionError(xhr);\n\tif (verbose) {\n\t\treturn ce.verboseMessage;\n\t} else {\n\t\treturn ce.message;\n\t}\n}\n\nfunction exceptionToErrorMessage(exception: any, verbose: boolean): string {\n\tif (exception.message) {\n\t\tif (verbose && (exception.stack || exception.stacktrace)) {\n\t\t\treturn nls.localize('stackTrace.format', \"{0}: {1}\", detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);\n\t\t}\n\n\t\treturn detectSystemErrorMessage(exception);\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\nfunction detectSystemErrorMessage(exception: any): string {\n\n\t// See https://nodejs.org/api/errors.html#errors_class_system_error\n\tif (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {\n\t\treturn nls.localize('nodeExceptionMessage', \"A system error occured ({0})\", exception.message);\n\t}\n\n\treturn exception.message;\n}\n\n/**\n * Tries to generate a human readable error message out of the error. If the verbose parameter\n * is set to true, the error message will include stacktrace details if provided.\n * @returns A string containing the error message.\n */\nexport function toErrorMessage(error: any = null, verbose: boolean = false): string {\n\tif (!error) {\n\t\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n\t}\n\n\tif (Array.isArray(error)) {\n\t\tlet errors: any[] = arrays.coalesce(error);\n\t\tlet msg = toErrorMessage(errors[0], verbose);\n\n\t\tif (errors.length > 1) {\n\t\t\treturn nls.localize('error.moreErrors', \"{0} ({1} errors in total)\", msg, errors.length);\n\t\t}\n\n\t\treturn msg;\n\t}\n\n\tif (types.isString(error)) {\n\t\treturn error;\n\t}\n\n\tif (!types.isUndefinedOrNull(error.status)) {\n\t\treturn xhrToErrorMessage(error, verbose);\n\t}\n\n\tif (error.detail) {\n\t\tlet detail = error.detail;\n\n\t\tif (detail.error) {\n\t\t\tif (detail.error && !types.isUndefinedOrNull(detail.error.status)) {\n\t\t\t\treturn xhrToErrorMessage(detail.error, verbose);\n\t\t\t}\n\n\t\t\tif (types.isArray(detail.error)) {\n\t\t\t\tfor (let i = 0; i < detail.error.length; i++) {\n\t\t\t\t\tif (detail.error[i] && !types.isUndefinedOrNull(detail.error[i].status)) {\n\t\t\t\t\t\treturn xhrToErrorMessage(detail.error[i], verbose);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\treturn exceptionToErrorMessage(detail.error, verbose);\n\t\t\t}\n\t\t}\n\n\t\tif (detail.exception) {\n\t\t\tif (!types.isUndefinedOrNull(detail.exception.status)) {\n\t\t\t\treturn xhrToErrorMessage(detail.exception, verbose);\n\t\t\t}\n\n\t\t\treturn exceptionToErrorMessage(detail.exception, verbose);\n\t\t}\n\t}\n\n\tif (error.stack) {\n\t\treturn exceptionToErrorMessage(error, verbose);\n\t}\n\n\tif (error.message) {\n\t\treturn error.message;\n\t}\n\n\treturn nls.localize('error.defaultMessage', \"An unknown error occurred. Please consult the log for more details.\");\n}\n\nconst canceledName = 'Canceled';\n\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isPromiseCanceledError(error: any): boolean {\n\treturn error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n\n/**\n * Returns an error that signals cancellation.\n */\nexport function canceled(): Error {\n\tlet error = new Error(canceledName);\n\terror.name = error.message;\n\treturn error;\n}\n\n/**\n * Returns an error that signals something is not implemented.\n */\nexport function notImplemented(): Error {\n\treturn new Error(nls.localize('notImplementedError', \"Not Implemented\"));\n}\n\nexport function illegalArgument(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(nls.localize('illegalArgumentError', \"Illegal argument: {0}\", name));\n\t} else {\n\t\treturn new Error(nls.localize('illegalArgumentError2', \"Illegal argument\"));\n\t}\n}\n\nexport function illegalState(name?: string): Error {\n\tif (name) {\n\t\treturn new Error(nls.localize('illegalStateError', \"Illegal state: {0}\", name));\n\t} else {\n\t\treturn new Error(nls.localize('illegalStateError2', \"Illegal state\"));\n\t}\n}\n\nexport function readonly(name?: string): Error {\n\treturn name\n\t\t? new Error(`readonly property '${name} cannot be changed'`)\n\t\t: new Error('readonly property cannot be changed');\n}\n\nexport function loaderError(err: Error): Error {\n\tif (platform.isWeb) {\n\t\treturn new Error(nls.localize('loaderError', \"Failed to load a required file. Either you are no longer connected to the internet or the server you are connected to is offline. Please refresh the browser to try again.\"));\n\t}\n\n\treturn new Error(nls.localize('loaderErrorNative', \"Failed to load a required file. Please restart the application to try again. Details: {0}\", JSON.stringify(err)));\n}\n\nexport interface IErrorOptions {\n\tseverity?: Severity;\n\tactions?: IAction[];\n}\n\nexport function create(message: string, options: IErrorOptions = {}): Error {\n\tlet result = new Error(message);\n\n\tif (types.isNumber(options.severity)) {\n\t\t(<any>result).severity = options.severity;\n\t}\n\n\tif (options.actions) {\n\t\t(<any>result).actions = options.actions;\n\t}\n\n\treturn result;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\ndefine(\"vs/base/common/winjs.base\", ['./winjs.base.raw', 'vs/base/common/errors'], function (raw, __Errors__) {\n\t'use strict';\n\n\tvar winjs = raw;\n\n\tvar outstandingPromiseErrors = {};\n\tfunction promiseErrorHandler(e) {\n\n\t\t//\n\t\t// e.detail looks like: { exception, error, promise, handler, id, parent }\n\t\t//\n\t\tvar details = e.detail;\n\t\tvar id = details.id;\n\n\t\t// If the error has a parent promise then this is not the origination of the\n\t\t//  error so we check if it has a handler, and if so we mark that the error\n\t\t//  was handled by removing it from outstandingPromiseErrors\n\t\t//\n\t\tif (details.parent) {\n\t\t\tif (details.handler && outstandingPromiseErrors) {\n\t\t\t\tdelete outstandingPromiseErrors[id];\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Indicate that this error was originated and needs to be handled\n\t\toutstandingPromiseErrors[id] = details;\n\n\t\t// The first time the queue fills up this iteration, schedule a timeout to\n\t\t// check if any errors are still unhandled.\n\t\tif (Object.keys(outstandingPromiseErrors).length === 1) {\n\t\t\tsetTimeout(function () {\n\t\t\t\tvar errors = outstandingPromiseErrors;\n\t\t\t\toutstandingPromiseErrors = {};\n\t\t\t\tObject.keys(errors).forEach(function (errorId) {\n\t\t\t\t\tvar error = errors[errorId];\n\t\t\t\t\tif(error.exception) {\n\t\t\t\t\t\t__Errors__.onUnexpectedError(error.exception);\n\t\t\t\t\t} else if(error.error) {\n\t\t\t\t\t\t__Errors__.onUnexpectedError(error.error);\n\t\t\t\t\t}\n\t\t\t\t\tconsole.log(\"WARNING: Promise with no error callback:\" + error.id);\n\t\t\t\t\tconsole.log(error);\n\t\t\t\t\tif(error.exception) {\n\t\t\t\t\t\tconsole.log(error.exception.stack);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}, 0);\n\t\t}\n\t}\n\n\twinjs.Promise.addEventListener(\"error\", promiseErrorHandler);\n\n\n\tfunction decoratePromise(promise, completeCallback, errorCallback) {\n\t\tvar pc, pe, pp;\n\n\t\tvar resultPromise = new winjs.Promise(\n\t\t\tfunction (c, e, p) {\n\t\t\t\tpc = c;\n\t\t\t\tpe = e;\n\t\t\t\tpp = p;\n\t\t\t}, function () {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\t\t);\n\n\t\tpromise.then(function (r) {\n\t\t\tif (completeCallback) {\n\t\t\t\tcompleteCallback(r);\n\t\t\t}\n\t\t\tpc(r);\n\t\t}, function (e) {\n\t\t\tif (errorCallback) {\n\t\t\t\terrorCallback(e);\n\t\t\t}\n\t\t\tpe(e);\n\t\t}, pp);\n\n\t\treturn resultPromise;\n\t}\n\n\treturn {\n\t\tdecoratePromise: decoratePromise,\n\t\tClass: winjs.Class,\n\t\txhr: winjs.xhr,\n\t\tPromise: winjs.Promise,\n\t\tTPromise: winjs.Promise,\n\t\tPPromise: winjs.Promise,\n\t\tUtilities: winjs.Utilities\n\t};\n});","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {transformErrorForSerialization} from 'vs/base/common/errors';\nimport {Disposable} from 'vs/base/common/lifecycle';\nimport {ErrorCallback, TPromise, ValueCallback} from 'vs/base/common/winjs.base';\nimport {IWorker, IWorkerFactory} from './workerClient';\n\nconst INITIALIZE = '$initialize';\n\ninterface IMessage {\n\tvsWorker: number;\n\treq?: string;\n\tseq?: string;\n}\n\ninterface IRequestMessage extends IMessage {\n\treq: string;\n\tmethod: string;\n\targs: any[];\n}\n\ninterface IReplyMessage extends IMessage {\n\tseq: string;\n\terr: any;\n\tres: any;\n}\n\ninterface IMessageReply {\n\tc: ValueCallback;\n\te: ErrorCallback;\n}\n\ninterface IMessageHandler {\n\tsendMessage(msg:string): void;\n\thandleMessage(method:string, args:any[]): TPromise<any>;\n}\n\nclass SimpleWorkerProtocol {\n\n\tprivate _workerId: number;\n\tprivate _lastSentReq: number;\n\tprivate _pendingReplies: { [req:string]:IMessageReply; };\n\tprivate _handler:IMessageHandler;\n\n\tconstructor(handler:IMessageHandler) {\n\t\tthis._workerId = -1;\n\t\tthis._handler = handler;\n\t\tthis._lastSentReq = 0;\n\t\tthis._pendingReplies = Object.create(null);\n\t}\n\n\tpublic setWorkerId(workerId:number): void {\n\t\tthis._workerId = workerId;\n\t}\n\n\tpublic sendMessage(method:string, args:any[]): TPromise<any> {\n\t\tlet req = String(++this._lastSentReq);\n\t\tlet reply: IMessageReply = {\n\t\t\tc: null,\n\t\t\te: null\n\t\t};\n\t\tlet result = new TPromise<any>((c, e, p) => {\n\t\t\treply.c = c;\n\t\t\treply.e = e;\n\t\t}, () => {\n\t\t\t// Cancel not supported\n\t\t});\n\t\tthis._pendingReplies[req] = reply;\n\n\t\tthis._send({\n\t\t\tvsWorker: this._workerId,\n\t\t\treq: req,\n\t\t\tmethod: method,\n\t\t\targs: args\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tpublic handleMessage(serializedMessage:string): void {\n\t\tlet message:IMessage;\n\t\ttry {\n\t\t\tmessage = JSON.parse(serializedMessage);\n\t\t} catch(e) {\n\t\t\t// nothing\n\t\t}\n\t\tif (!message.vsWorker) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n\t\t\treturn;\n\t\t}\n\t\tthis._handleMessage(message);\n\t}\n\n\tprivate _handleMessage(msg:IMessage): void {\n\t\tif (msg.seq) {\n\t\t\tlet replyMessage = <IReplyMessage>msg;\n\t\t\tif (!this._pendingReplies[replyMessage.seq]) {\n\t\t\t\tconsole.warn('Got reply to unknown seq');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet reply = this._pendingReplies[replyMessage.seq];\n\t\t\tdelete this._pendingReplies[replyMessage.seq];\n\n\t\t\tif (replyMessage.err) {\n\t\t\t\tlet err = replyMessage.err;\n\t\t\t\tif (replyMessage.err.$isError) {\n\t\t\t\t\terr = new Error();\n\t\t\t\t\terr.name = replyMessage.err.name;\n\t\t\t\t\terr.message = replyMessage.err.message;\n\t\t\t\t\terr.stack = replyMessage.err.stack;\n\t\t\t\t}\n\t\t\t\treply.e(err);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treply.c(replyMessage.res);\n\t\t\treturn;\n\t\t}\n\n\t\tlet requestMessage = <IRequestMessage>msg;\n\t\tlet req = requestMessage.req;\n\t\tlet result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n\t\tresult.then((r) => {\n\t\t\tthis._send({\n\t\t\t\tvsWorker: this._workerId,\n\t\t\t\tseq: req,\n\t\t\t\tres: r,\n\t\t\t\terr: undefined\n\t\t\t});\n\t\t}, (e) => {\n\t\t\tthis._send({\n\t\t\t\tvsWorker: this._workerId,\n\t\t\t\tseq: req,\n\t\t\t\tres: undefined,\n\t\t\t\terr: transformErrorForSerialization(e)\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate _send(msg:IRequestMessage|IReplyMessage): void {\n\t\tlet strMsg = JSON.stringify(msg);\n\t\t// console.log('SENDING: ' + strMsg);\n\t\tthis._handler.sendMessage(strMsg);\n\t}\n}\n\n/**\n * Main thread side\n */\nexport class SimpleWorkerClient<T> extends Disposable {\n\n\tprivate _worker:IWorker;\n\tprivate _onModuleLoaded:TPromise<string[]>;\n\tprivate _protocol: SimpleWorkerProtocol;\n\tprivate _proxy: T;\n\tprivate _lazyProxy: TPromise<T>;\n\tprivate _lastRequestTimestamp = -1;\n\n\tconstructor(workerFactory:IWorkerFactory, moduleId:string, ctor:any) {\n\t\tsuper();\n\t\tthis._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg:string) => {\n\t\t\tthis._protocol.handleMessage(msg);\n\t\t}));\n\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg:string): void => {\n\t\t\t\tthis._worker.postMessage(msg);\n\t\t\t},\n\t\t\thandleMessage: (method:string, args:any[]): TPromise<any> => {\n\t\t\t\t// Intentionally not supporting worker -> main requests\n\t\t\t\treturn TPromise.as(null);\n\t\t\t}\n\t\t});\n\t\tthis._protocol.setWorkerId(this._worker.getId());\n\n\t\t// Gather loader configuration\n\t\tlet loaderConfiguration:any = null;\n\t\tlet globalRequire = (<any>window).require;\n\t\tif (typeof globalRequire.getConfig === 'function') {\n\t\t\t// Get the configuration from the Monaco AMD Loader\n\t\t\tloaderConfiguration = globalRequire.getConfig();\n\t\t} else if (typeof (<any>window).requirejs !== 'undefined') {\n\t\t\t// Get the configuration from requirejs\n\t\t\tloaderConfiguration = (<any>window).requirejs.s.contexts._.config;\n\t\t}\n\n\t\tlet lazyProxyFulfill : (v:T)=>void = null;\n\t\tlet lazyProxyReject: (err:any)=>void = null;\n\n\t\tthis._lazyProxy = new TPromise((c, e, p) => {\n\t\t\tlazyProxyFulfill = c;\n\t\t\tlazyProxyReject = e;\n\t\t}, () => { /* no cancel */ });\n\n\t\t// Send initialize message\n\t\tthis._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\n\t\t\tthis._worker.getId(),\n\t\t\tmoduleId,\n\t\t\tloaderConfiguration\n\t\t]);\n\t\tthis._onModuleLoaded.then((availableMethods:string[]) => {\n\t\t\tlet proxy = <T><any>{};\n\t\t\tfor (let i = 0; i < availableMethods.length; i++) {\n\t\t\t\tproxy[availableMethods[i]] = createProxyMethod(availableMethods[i], proxyMethodRequest);\n\t\t\t}\n\t\t\tlazyProxyFulfill(proxy);\n\t\t}, (e) => {\n\t\t\tlazyProxyReject(e);\n\t\t\tthis._onError('Worker failed to load ' + moduleId, e);\n\t\t});\n\n\t\t// Create proxy to loaded code\n\t\tlet proxyMethodRequest = (method:string, args:any[]):TPromise<any> => {\n\t\t\treturn this._request(method, args);\n\t\t};\n\n\t\tlet createProxyMethod = (method:string, proxyMethodRequest:(method:string, args:any[])=>TPromise<any>): Function => {\n\t\t\treturn function () {\n\t\t\t\tlet args = Array.prototype.slice.call(arguments, 0);\n\t\t\t\treturn proxyMethodRequest(method, args);\n\t\t\t};\n\t\t};\n\n\t\tthis._proxy = <T><any>{};\n\t\tif (ctor) {\n\t\t\t// console.warn('deprecated');\n\t\t\tfor (let prop in ctor.prototype) {\n\t\t\t\tif (ctor.prototype.hasOwnProperty(prop)) {\n\t\t\t\t\tif (typeof ctor.prototype[prop] === 'function') {\n\t\t\t\t\t\tthis._proxy[prop] = createProxyMethod(prop, proxyMethodRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic get(): T {\n\t\treturn this._proxy;\n\t}\n\n\tpublic getProxyObject(): TPromise<T> {\n\t\treturn this._lazyProxy;\n\t}\n\n\tpublic getLastRequestTimestamp(): number {\n\t\treturn this._lastRequestTimestamp;\n\t}\n\n\tprivate _request(method:string, args:any[]): TPromise<any> {\n\t\treturn new TPromise<any>((c, e, p) => {\n\t\t\tthis._onModuleLoaded.then(() => {\n\t\t\t\tthis._lastRequestTimestamp = Date.now();\n\t\t\t\tthis._protocol.sendMessage(method, args).then(c, e);\n\t\t\t}, e);\n\t\t}, () => {\n\t\t\t// Cancel intentionally not supported\n\t\t});\n\t}\n\n\tprivate _onError(message:string, error?:any): void {\n\t\tconsole.error(message);\n\t\tconsole.info(error);\n\t}\n}\n\nexport interface IRequestHandler {\n\t_requestHandlerTrait: any;\n}\n\n/**\n * Worker side\n */\nexport class SimpleWorkerServer {\n\n\tprivate _protocol: SimpleWorkerProtocol;\n\tprivate _requestHandler: IRequestHandler;\n\n\tconstructor(postSerializedMessage:(msg:string)=>void) {\n\t\tthis._protocol = new SimpleWorkerProtocol({\n\t\t\tsendMessage: (msg:string): void => {\n\t\t\t\tpostSerializedMessage(msg);\n\t\t\t},\n\t\t\thandleMessage: (method:string, args:any[]): TPromise<any> => this._handleMessage(method, args)\n\t\t});\n\t}\n\n\tpublic onmessage(msg:string): void {\n\t\tthis._protocol.handleMessage(msg);\n\t}\n\n\tprivate _handleMessage(method: string, args:any[]): TPromise<any> {\n\t\tif (method === INITIALIZE) {\n\t\t\treturn this.initialize(<number>args[0], <string>args[1], <any>args[2]);\n\t\t}\n\n\t\tif (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\n\t\t\treturn TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));\n\t\t}\n\n\t\ttry {\n\t\t\treturn TPromise.as(this._requestHandler[method].apply(this._requestHandler, args));\n\t\t} catch (e) {\n\t\t\treturn TPromise.wrapError(e);\n\t\t}\n\t}\n\n\tprivate initialize(workerId: number, moduleId: string, loaderConfig:any): TPromise<any> {\n\t\tthis._protocol.setWorkerId(workerId);\n\n\t\t// TODO@Alex: share this code with workerServer\n\t\tif (loaderConfig) {\n\t\t\t// Remove 'baseUrl', handling it is beyond scope for now\n\t\t\tif (typeof loaderConfig.baseUrl !== 'undefined') {\n\t\t\t\tdelete loaderConfig['baseUrl'];\n\t\t\t}\n\t\t\tif (typeof loaderConfig.paths !== 'undefined') {\n\t\t\t\tif (typeof loaderConfig.paths.vs !== 'undefined') {\n\t\t\t\t\tdelete loaderConfig.paths['vs'];\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet nlsConfig = loaderConfig['vs/nls'];\n\t\t\t// We need to have pseudo translation\n\t\t\tif (nlsConfig && nlsConfig.pseudo) {\n\t\t\t\trequire(['vs/nls'], function(nlsPlugin) {\n\t\t\t\t\tnlsPlugin.setPseudoTranslation(nlsConfig.pseudo);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Since this is in a web worker, enable catching errors\n\t\t\tloaderConfig.catchError = true;\n\t\t\t(<any>self).require.config(loaderConfig);\n\t\t}\n\n\t\tlet cc: ValueCallback;\n\t\tlet ee: ErrorCallback;\n\t\tlet r = new TPromise<any>((c, e, p) => {\n\t\t\tcc = c;\n\t\t\tee = e;\n\t\t});\n\n\t\trequire([moduleId], (...result:any[]) => {\n\t\t\tlet handlerModule = result[0];\n\t\t\tthis._requestHandler = handlerModule.create();\n\n\t\t\tlet methods: string[] = [];\n\t\t\tfor (let prop in this._requestHandler) {\n\t\t\t\tif (typeof this._requestHandler[prop] === 'function') {\n\t\t\t\t\tmethods.push(prop);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcc(methods);\n\t\t}, ee);\n\n\t\treturn r;\n\t}\n}\n\n/**\n * Called on the worker side\n */\nexport function create(postMessage:(msg:string)=>void): SimpleWorkerServer {\n\treturn new SimpleWorkerServer(postMessage);\n}\n"]}