{"version":3,"sources":["vs/languages/json/common/json.js","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/features/jsonTokenTypes.ts","vs/languages/json/common/fake","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/base/common/json.ts","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/features/tokenization.ts","vs/languages/json/common/file:/C:/Alex/src/vscode/src/vs/languages/json/common/json.ts"],"names":["define","require","exports","TOKEN_DELIM_OBJECT","TOKEN_DELIM_ARRAY","TOKEN_DELIM_COLON","TOKEN_DELIM_COMMA","TOKEN_VALUE_BOOLEAN","TOKEN_VALUE_NULL","TOKEN_VALUE_STRING","TOKEN_VALUE_NUMBER","TOKEN_PROPERTY_NAME","TOKEN_COMMENT_BLOCK","TOKEN_COMMENT_LINE","nls","data","create","nls_1","createScanner","text","ignoreTrivia","scanHexDigits","count","exact","digits","value","ch","charCodeAt","pos","CharacterCodes","_0","_9","A","F","a","f","setPosition","newPosition","tokenOffset","token","SyntaxKind","Unknown","scanError","ScanError","None","scanNumber","start","length","isDigit","dot","UnexpectedEndOfNumber","substring","end","E","e","plus","minus","scanString","result","len","UnexpectedEndOfString","doubleQuote","backslash","isLineBreak","slash","b","n","r","t","u","ch_1","String","fromCharCode","InvalidUnicode","InvalidEscapeCharacter","scanNext","EOF","code","isWhiteSpace","Trivia","carriageReturn","lineFeed","LineBreakTrivia","openBrace","OpenBraceToken","closeBrace","CloseBraceToken","openBracket","OpenBracketToken","closeBracket","CloseBracketToken","colon","ColonToken","comma","CommaToken","StringLiteral","LineCommentTrivia","asterisk","safeLength","commentClosed","UnexpectedEndOfComment","BlockCommentTrivia","_1","_2","_3","_4","_5","_6","_7","_8","NumericLiteral","isUnknownContentCharacter","TrueKeyword","FalseKeyword","NullKeyword","scanNextNonTrivia","getPosition","scan","getToken","getTokenValue","getTokenOffset","getTokenLength","getTokenError","space","tab","verticalTab","formFeed","nonBreakingSpace","ogham","enQuad","zeroWidthSpace","narrowNoBreakSpace","mathematicalSpace","ideographicSpace","byteOrderMark","lineSeparator","paragraphSeparator","stripComments","replaceCh","kind","_scanner","parts","offset","push","replace","join","getParseErrorMessage","errorCode","ParseErrorCode","InvalidSymbol","localize","InvalidNumberFormat","PropertyNameExpected","ValueExpected","ColonExpected","CommaExpected","CloseBraceExpected","CloseBracketExpected","EndOfFileExpected","getLiteralNodeType","getLocation","position","setPreviousNode","type","previousNodeInst","columnOffset","previousNode","segments","earlyReturnException","Object","isAtPropertyKey","visit","onObjectBegin","onObjectProperty","name","onObjectEnd","pop","onArrayBegin","onArrayEnd","onLiteralValue","onSeparator","sep","last","path","matches","pattern","k","i","parse","errors","options","onValue","Array","isArray","currentParent","currentProperty","previousParents","visitor","object","array","onError","error","parseTree","ensurePropertyComplete","endOffset","parent","valueNode","children","findNodeAtLocation","root","node","_i","path_1","segment","found","_a","_b","propertyNode","index","getNodeValue","map","obj","prop","toNoArgVisit","visitFunction","toOneArgVisit","arg","disallowComments","handleError","skipUntilAfter","skipUntil","indexOf","parseString","isValue","parseLiteral","JSON","parseProperty","parseValue","parseObject","needsComma","parseArray","json","jsonTokenTypes","createTokenizationSupport","mode","supportComments","shouldGenerateEmbeddedModels","getInitialState","JSONState","tokenize","line","state","offsetDelta","stopAtOffset","comments","numberOfInsertedCharacters","adjustOffset","ret","scanner","lastWasColon","tokens","actualStopOffset","endState","clone","modeTransitions","startIndex","Error","substr","getMode","getStateData","this","_mode","_state","prototype","equals","other","stream","setStateData","__extends","d","__","constructor","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","modes","Platform","tokenization","abstractMode_1","threadService_1","thread_1","jsonContributionRegistry_1","instantiation_1","richEditSupport_1","async_1","JSONMode","_super","descriptor","instantiationService","threadService","_this","call","id","_modeWorkerManager","ModeWorkerManager","_threadService","tokenizationSupport","richEditSupport","RichEditSupport","getId","wordPattern","createWordRegExp","lineComment","blockComment","brackets","autoClosingPairs","open","close","notIn","HoverProviderRegistry","register","provideHover","model","wireCancellationToken","_provideHover","uri","inplaceReplaceSupport","configSupport","DocumentSymbolProviderRegistry","provideDocumentSymbols","_provideDocumentSymbols","DocumentFormattingEditProviderRegistry","provideDocumentFormattingEdits","_provideDocumentFormattingEdits","DocumentRangeFormattingEditProviderRegistry","provideDocumentRangeFormattingEdits","range","_provideDocumentRangeFormattingEdits","SuggestRegistry","triggerCharacters","shouldAutotriggerSuggest","provideCompletionItems","_provideCompletionItems","creationDone","isInMainThread","_pickAWorkerToValidate","_configureWorkerSchemas","getSchemaConfiguration","contributionRegistry","Registry","as","Extensions","JSONContribution","addRegistryChangedListener","_worker","runner","worker","getSchemaContributions","configure","_configureWorkers","w","_doConfigure","setSchemaContributions","enableValidator","navigateValueSet","resource","up","format","$_configureWorkers","AllWorkersAttr","$_configureWorkerSchemas","$_pickAWorkerToValidate","OneWorkerAttr","ThreadAffinity","Group1","$navigateValueSet","$_provideCompletionItems","$_provideHover","$_provideDocumentSymbols","$_provideDocumentFormattingEdits","$_provideDocumentRangeFormattingEdits","IInstantiationService","IThreadService","AbstractMode"],"mappings":";;;;;;AAOAA,OAAO,oDAAqD,UAAW,WAAY,SAAUC,EAASC,GCHtG,YAEaA,GAAAC,mBAAqB,2BACrBD,EAAAE,kBAAoB,yBACpBF,EAAAG,kBAAoB,yBACpBH,EAAAI,kBAAoB,yBACpBJ,EAAAK,oBAAqB,sCACrBL,EAAAM,iBAAkB,6CAClBN,EAAAO,mBAAqB,2CACrBP,EAAAQ,mBAAqB,+CACrBR,EAAAS,oBAAsB,kCACtBT,EAAAU,oBAAsB,qBACtBV,EAAAW,mBAAqB,sBChBlCb,OAAA,8BAAA,SAAA,wCAAA,SAAAc,EAAAC,GAAA,MAAAD,GAAAE,OAAA,sBAAAD,KF2BAf,OAAO,uBAAwB,UAAW,UAAW,8BAA+B,SAAUC,EAASC,EAASe,GGvBhH,YA0EA,SAAAC,GAA8BC,EAAaC,GAS1C,QAAAC,GAAuBC,EAAeC,GAGrC,IAFA,GAAIC,GAAS,EACTC,EAAQ,EACIH,EAATE,IAAmBD,GAAO,CAChC,GAAIG,GAAKP,EAAKQ,WAAWC,EACzB,IAAIF,GAAMG,EAAeC,IAAMJ,GAAMG,EAAeE,GACnDN,EAAgB,GAARA,EAAaC,EAAKG,EAAeC,OAErC,IAAIJ,GAAMG,EAAeG,GAAKN,GAAMG,EAAeI,EACvDR,EAAgB,GAARA,EAAaC,EAAKG,EAAeG,EAAI,OAEzC,CAAA,KAAIN,GAAMG,EAAeK,GAAKR,GAAMG,EAAeM,GAIvD,KAHAV,GAAgB,GAARA,EAAaC,EAAKG,EAAeK,EAAI,GAK9CN,IACAJ,IAKD,MAHaF,GAATE,IACHC,EAAQ,IAEFA,EAGR,QAAAW,GAAqBC,GACpBT,EAAMS,EACNZ,EAAQ,GACRa,EAAc,EACdC,EAAQC,EAAWC,QACnBC,EAAYC,EAAUC,KAGvB,QAAAC,KACC,GAAIC,GAAQlB,CACZ,IAAIT,EAAKQ,WAAWC,KAASC,EAAeC,GAC3CF,QAGA,KADAA,IACOA,EAAMT,EAAK4B,QAAUC,EAAQ7B,EAAKQ,WAAWC,KACnDA,GAGF,IAAIA,EAAMT,EAAK4B,QAAU5B,EAAKQ,WAAWC,KAASC,EAAeoB,IAAK,CAErE,GADArB,MACIA,EAAMT,EAAK4B,QAAUC,EAAQ7B,EAAKQ,WAAWC,KAOhD,MADAc,GAAYC,EAAUO,sBACf/B,EAAKgC,UAAUL,EAAOlB,EAL7B,KADAA,IACOA,EAAMT,EAAK4B,QAAUC,EAAQ7B,EAAKQ,WAAWC,KACnDA,IAOH,GAAIwB,GAAMxB,CACV,IAAIA,EAAMT,EAAK4B,SAAW5B,EAAKQ,WAAWC,KAASC,EAAewB,GAAKlC,EAAKQ,WAAWC,KAASC,EAAeyB,GAK9G,GAJA1B,KACIA,EAAMT,EAAK4B,QAAU5B,EAAKQ,WAAWC,KAASC,EAAe0B,MAAQpC,EAAKQ,WAAWC,KAASC,EAAe2B,QAChH5B,IAEGA,EAAMT,EAAK4B,QAAUC,EAAQ7B,EAAKQ,WAAWC,IAAO,CAEvD,IADAA,IACOA,EAAMT,EAAK4B,QAAUC,EAAQ7B,EAAKQ,WAAWC,KACnDA,GAEDwB,GAAMxB,MAENc,GAAYC,EAAUO,qBAGxB,OAAO/B,GAAKgC,UAAUL,EAAOM,GAG9B,QAAAK,KAKC,IAHA,GAAIC,GAAS,GACZZ,EAAQlB,IAEI,CACZ,GAAIA,GAAO+B,EAAK,CACfD,GAAUvC,EAAKgC,UAAUL,EAAOlB,GAChCc,EAAYC,EAAUiB,qBACtB,OAED,GAAIlC,GAAKP,EAAKQ,WAAWC,EACzB,IAAIF,IAAOG,EAAegC,YAAa,CACtCH,GAAUvC,EAAKgC,UAAUL,EAAOlB,GAChCA,GACA,OAED,GAAIF,IAAOG,EAAeiC,UAA1B,CA+CA,GAAIC,EAAYrC,GAAK,CACpBgC,GAAUvC,EAAKgC,UAAUL,EAAOlB,GAChCc,EAAYC,EAAUiB,qBACtB,OAEDhC,QApDA,CAGC,GAFA8B,GAAUvC,EAAKgC,UAAUL,EAAOlB,GAChCA,IACIA,GAAO+B,EAAK,CACfjB,EAAYC,EAAUiB,qBACtB,OAGD,OADAlC,EAAKP,EAAKQ,WAAWC,MAEpB,IAAKC,GAAegC,YACnBH,GAAU,GACV,MACD,KAAK7B,GAAeiC,UACnBJ,GAAU,IACV,MACD,KAAK7B,GAAemC,MACnBN,GAAU,GACV,MACD,KAAK7B,GAAeoC,EACnBP,GAAU,IACV,MACD,KAAK7B,GAAeM,EACnBuB,GAAU,IACV,MACD,KAAK7B,GAAeqC,EACnBR,GAAU,IACV,MACD,KAAK7B,GAAesC,EACnBT,GAAU,IACV,MACD,KAAK7B,GAAeuC,EACnBV,GAAU,GACV,MACD,KAAK7B,GAAewC,EACnB,GAAIC,GAAKjD,EAAc,GAAG,EACtBiD,IAAM,EACTZ,GAAUa,OAAOC,aAAaF,GAE9B5B,EAAYC,EAAU8B,cAEvB,MACD,SACC/B,EAAYC,EAAU+B,uBAExB5B,EAAQlB,GAUV,MAAO8B,GAGR,QAAAiB,KAOC,GALAlD,EAAQ,GACRiB,EAAYC,EAAUC,KAEtBN,EAAcV,EAEXA,GAAO+B,EAGT,MADArB,GAAcqB,EACPpB,EAAQC,EAAWoC,GAG3B,IAAIC,GAAO1D,EAAKQ,WAAWC,EAE3B,IAAIkD,EAAaD,GAAO,CACvB,EACCjD,KACAH,GAAS8C,OAAOC,aAAaK,GAC7BA,EAAO1D,EAAKQ,WAAWC,SACfkD,EAAaD,GAEtB,OAAOtC,GAAQC,EAAWuC,OAI3B,GAAIhB,EAAYc,GAOf,MANAjD,KACAH,GAAS8C,OAAOC,aAAaK,GACzBA,IAAShD,EAAemD,gBAAkB7D,EAAKQ,WAAWC,KAASC,EAAeoD,WACrFrD,IACAH,GAAS,MAEHc,EAAQC,EAAW0C,eAG3B,QAAOL,GAEN,IAAKhD,GAAesD,UAEnB,MADAvD,KACOW,EAAQC,EAAW4C,cAC3B,KAAKvD,GAAewD,WAEnB,MADAzD,KACOW,EAAQC,EAAW8C,eAC3B,KAAKzD,GAAe0D,YAEnB,MADA3D,KACOW,EAAQC,EAAWgD,gBAC3B,KAAK3D,GAAe4D,aAEnB,MADA7D,KACOW,EAAQC,EAAWkD,iBAC3B,KAAK7D,GAAe8D,MAEnB,MADA/D,KACOW,EAAQC,EAAWoD,UAC3B,KAAK/D,GAAegE,MAEnB,MADAjE,KACOW,EAAQC,EAAWsD,UAG3B,KAAKjE,GAAegC,YAGnB,MAFAjC,KACAH,EAAQgC,IACDlB,EAAQC,EAAWuD,aAG3B,KAAKlE,GAAemC,MACnB,GAAIlB,GAAQlB,EAAM,CAElB,IAAIT,EAAKQ,WAAWC,EAAM,KAAOC,EAAemC,MAAO,CAGtD,IAFApC,GAAO,EAEM+B,EAAN/B,IACFmC,EAAY5C,EAAKQ,WAAWC,KAGhCA,GAID,OADAH,GAAQN,EAAKgC,UAAUL,EAAOlB,GACvBW,EAAQC,EAAWwD,kBAI3B,GAAI7E,EAAKQ,WAAWC,EAAM,KAAOC,EAAeoE,SAAU,CACzDrE,GAAO,CAIP,KAFA,GAAIsE,GAAavC,EAAM,EACnBwC,GAAgB,EACPD,EAANtE,GAAkB,CACxB,GAAIF,GAAKP,EAAKQ,WAAWC,EAEzB,IAAIF,IAAOG,EAAeoE,UAAY9E,EAAKQ,WAAWC,EAAM,KAAOC,EAAemC,MAAO,CACxFpC,GAAO,EACPuE,GAAgB,CAChB,OAEDvE,IASD,MANKuE,KACJvE,IACAc,EAAYC,EAAUyD,wBAGvB3E,EAAQN,EAAKgC,UAAUL,EAAOlB,GACvBW,EAAQC,EAAW6D,mBAK3B,MAFA5E,IAAS8C,OAAOC,aAAaK,GAC7BjD,IACOW,EAAQC,EAAWC,OAG3B,KAAKZ,GAAe2B,MAGnB,GAFA/B,GAAS8C,OAAOC,aAAaK,GAC7BjD,IACIA,IAAQ+B,IAAQX,EAAQ7B,EAAKQ,WAAWC,IAC3C,MAAOW,GAAQC,EAAWC,OAK5B,KAAKZ,GAAeC,GACpB,IAAKD,GAAeyE,GACpB,IAAKzE,GAAe0E,GACpB,IAAK1E,GAAe2E,GACpB,IAAK3E,GAAe4E,GACpB,IAAK5E,GAAe6E,GACpB,IAAK7E,GAAe8E,GACpB,IAAK9E,GAAe+E,GACpB,IAAK/E,GAAegF,GACpB,IAAKhF,GAAeE,GAEnB,MADAN,IAASoB,IACFN,EAAQC,EAAWsE,cAE3B,SAEC,KAAanD,EAAN/B,GAAamF,EAA0BlC,IAC7CjD,IACAiD,EAAO1D,EAAKQ,WAAWC,EAExB,IAAIU,IAAgBV,EAAK,CAGxB,OAFAH,EAAQN,EAAKgC,UAAUb,EAAaV,IAGnC,IAAK,OAAQ,MAAOW,GAAQC,EAAWwE,WACvC,KAAK,QAAS,MAAOzE,GAAQC,EAAWyE,YACxC,KAAK,OAAQ,MAAO1E,GAAQC,EAAW0E,YAExC,MAAO3E,GAAQC,EAAWC,QAK3B,MAFAhB,IAAS8C,OAAOC,aAAaK,GAC7BjD,IACOW,EAAQC,EAAWC,SAI7B,QAAAsE,GAAmClC,GAClC,GAAIC,EAAaD,IAASd,EAAYc,GACrC,OAAO,CAER,QAAQA,GACP,IAAKhD,GAAewD,WACpB,IAAKxD,GAAe4D,aACpB,IAAK5D,GAAesD,UACpB,IAAKtD,GAAe0D,YACpB,IAAK1D,GAAegC,YACpB,IAAKhC,GAAe8D,MACpB,IAAK9D,GAAegE,MACnB,OAAO,EAET,OAAO,EAIR,QAAAsB,KACC,GAAIzD,EACJ,GACCA,GAASiB,UACDjB,GAAUlB,EAAWwD,mBAAqBtC,GAAUlB,EAAWuC,OACxE,OAAOrB,GAlVkC,SAAAtC,IAAAA,GAAA,EAE1C,IAAIQ,GAAM,EACT+B,EAAMxC,EAAK4B,OACXtB,EAAe,GACfa,EAAc,EACdC,EAAmBC,EAAWC,QAC9BC,EAAsBC,EAAUC,IA8UjC,QACCR,YAAaA,EACbgF,YAAa,WAAM,MAAAxF,IACnByF,KAAMjG,EAAe+F,EAAoBxC,EACzC2C,SAAU,WAAM,MAAA/E,IAChBgF,cAAe,WAAM,MAAA9F,IACrB+F,eAAgB,WAAM,MAAAlF,IACtBmF,eAAgB,WAAM,MAAA7F,GAAMU,GAC5BoF,cAAe,WAAM,MAAAhF,KAIvB,QAAAoC,GAAsBpD,GACrB,MAAOA,KAAOG,EAAe8F,OAASjG,IAAOG,EAAe+F,KAAOlG,IAAOG,EAAegG,aAAenG,IAAOG,EAAeiG,UAC7HpG,IAAOG,EAAekG,kBAAoBrG,IAAOG,EAAemG,OAAStG,GAAMG,EAAeoG,QAAUvG,GAAMG,EAAeqG,gBAC7HxG,IAAOG,EAAesG,oBAAsBzG,IAAOG,EAAeuG,mBAAqB1G,IAAOG,EAAewG,kBAAoB3G,IAAOG,EAAeyG,cAGzJ,QAAAvE,GAAqBrC,GACpB,MAAOA,KAAOG,EAAeoD,UAAYvD,IAAOG,EAAemD,gBAAkBtD,IAAOG,EAAe0G,eAAiB7G,IAAOG,EAAe2G,mBAG/I,QAAAxF,GAAiBtB,GAChB,MAAOA,IAAMG,EAAeC,IAAMJ,GAAMG,EAAeE,GAkJxD,QAAA0G,GAA8BtH,EAAauH,GAE1C,GAECC,GAEA/G,EAJGgH,EAAW1H,EAAcC,GAC5B0H,KAEAC,EAAS,CAGV,GAGC,QAFAlH,EAAMgH,EAASxB,cACfuB,EAAOC,EAASvB,QAEf,IAAK7E,GAAWwD,kBAChB,IAAKxD,GAAW6D,mBAChB,IAAK7D,GAAWoC,IACZkE,IAAWlH,GACbiH,EAAME,KAAK5H,EAAKgC,UAAU2F,EAAQlH,IAElB,SAAd8G,GACFG,EAAME,KAAKH,EAASrB,gBAAgByB,QAAQ,WAAYN,IAEzDI,EAASF,EAASxB,oBAGbuB,IAASnG,EAAWoC,IAE5B,OAAOiE,GAAMI,KAAK,IAmBnB,QAAAC,GAAqCC,GACpC,OAAQA,GACP,IAAKC,GAAeC,cAAe,MAAOpI,GAAAqI,SAAS,EAAuB,KAC1E,KAAKF,GAAeG,oBAAqB,MAAOtI,GAAAqI,SAAS,EAA6B,KACtF,KAAKF,GAAeI,qBAAsB,MAAOvI,GAAAqI,SAAS,EAA8B,KACxF,KAAKF,GAAeK,cAAe,MAAOxI,GAAAqI,SAAS,EAAuB,KAC1E,KAAKF,GAAeM,cAAe,MAAOzI,GAAAqI,SAAS,EAAuB,KAC1E,KAAKF,GAAeO,cAAe,MAAO1I,GAAAqI,SAAS,EAAuB,KAC1E,KAAKF,GAAeQ,mBAAoB,MAAO3I,GAAAqI,SAAS,EAA4B,KACpF,KAAKF,GAAeS,qBAAsB,MAAO5I,GAAAqI,SAAS,EAA8B,KACxF,KAAKF,GAAeU,kBAAmB,MAAO7I,GAAAqI,SAAS,EAA2B,KAClF,SACC,MAAO,IAMV,QAAAS,GAA4BtI,GAC3B,aAAeA,IACd,IAAK,UAAW,MAAO,SACvB,KAAK,SAAU,MAAO,QACtB,KAAK,SAAU,MAAO,QACtB,SAAS,MAAO,QA2ClB,QAAAuI,GAA4B7I,EAAa8I,GAWxC,QAAAC,GAAyBzI,EAAeqH,EAAgB/F,EAAgBoH,GACvEC,EAAiB3I,MAAQA,EACzB2I,EAAiBtB,OAASA,EAC1BsB,EAAiBrH,OAASA,EAC1BqH,EAAiBD,KAAOA,EACxBC,EAAiBC,aAAe,OAChCC,EAAeF,EAhBhB,GAAIG,MACAC,EAAuB,GAAIC,QAC3BH,EAAsB,OACpBF,GACL3I,MAAO,OACPqH,OAAQ,OACR/F,OAAQ,OACRoH,KAAM,QAEHO,GAAkB,CAStB,KAECC,EAAMxJ,GACLyJ,cAAe,SAAC9B,EAAgB/F,GAC/B,GAAgB+F,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfI,EAAkBT,EAAWnB,EAC7ByB,EAASxB,KAAK,KAEf8B,iBAAkB,SAACC,EAAchC,EAAgB/F,GAChD,GAAe+F,EAAXmB,EACH,KAAMO,EAIP,IAFAN,EAAgBY,EAAMhC,EAAQ/F,EAAQ,YACtCwH,EAASA,EAASxH,OAAS,GAAK+H,EAChBhC,EAAS/F,GAArBkH,EACH,KAAMO,IAGRO,YAAa,SAACjC,EAAgB/F,GAC7B,GAAgB+F,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASS,OAEVC,aAAc,SAACnC,EAAgB/F,GAC9B,GAAgB+F,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASxB,KAAK,IAEfmC,WAAY,SAACpC,EAAgB/F,GAC5B,GAAgB+F,GAAZmB,EACH,KAAMO,EAEPF,GAAe,OACfC,EAASS,OAEVG,eAAgB,SAAC1J,EAAYqH,EAAgB/F,GAC5C,GAAe+F,EAAXmB,EACH,KAAMO,EAIP,IAFAN,EAAgBzI,EAAOqH,EAAQ/F,EAAQgH,EAAmBtI,IAE1CqH,EAAS/F,GAArBkH,EACH,KAAMO,IAGRY,YAAa,SAACC,EAAavC,EAAgB/F,GAC1C,GAAgB+F,GAAZmB,EACH,KAAMO,EAEP,IAAY,MAARa,GAAqC,aAAtBf,EAAaH,KAC/BG,EAAaD,aAAevB,EAC5B4B,GAAkB,EAClBJ,EAAe,WACT,IAAY,MAARe,EAAa,CACvB,GAAIC,GAAOf,EAASA,EAASxH,OAAS,EAClB,iBAATuI,GACVf,EAASA,EAASxH,OAAS,GAAKuI,EAAO,GAEvCZ,GAAkB,EAClBH,EAASA,EAASxH,OAAS,GAAK,IAEjCuH,EAAe,WAIjB,MAAOhH,GACR,GAAIA,IAAMkH,EACT,KAAMlH,GAOR,MAHsC,KAAlCiH,EAASA,EAASxH,OAAS,IAC9BwH,EAASS,OAGTO,KAAMhB,EACND,aAAAA,EACAI,gBAAAA,EACAc,QAAS,SAACC,GAET,IAAK,GADDC,GAAI,EACCC,EAAI,EAAGD,EAAID,EAAQ1I,QAAU4I,EAAIpB,EAASxH,OAAQ4I,IAC1D,GAAIF,EAAQC,KAAOnB,EAASoB,IAAqB,MAAfF,EAAQC,GACzCA,QACM,IAAmB,OAAfD,EAAQC,GAClB,OAAO,CAGT,OAAOA,KAAMD,EAAQ1I,SAaxB,QAAA6I,GAAsBzK,EAAa0K,EAA2BC,GAK7D,QAAAC,GAAiBtK,GACZuK,MAAMC,QAAQC,GACRA,EAAenD,KAAKtH,GACnB0K,IACVD,EAAcC,GAAmB1K,GATD,SAAAoK,IAAAA,KAClC,IAAIM,GAA2B,KAC3BD,KACAE,KAUAC,GACHzB,cAAe,WACd,GAAI0B,KACJP,GAAQO,GACRF,EAAgBrD,KAAKmD,GACrBA,EAAgBI,EAChBH,EAAkB,MAEnBtB,iBAAkB,SAACC,GAClBqB,EAAkBrB,GAEnBC,YAAa,WACZmB,EAAgBE,EAAgBpB,OAEjCC,aAAc,WACb,GAAIsB,KACJR,GAAQQ,GACRH,EAAgBrD,KAAKmD,GACrBA,EAAgBK,EAChBJ,EAAkB,MAEnBjB,WAAY,WACXgB,EAAgBE,EAAgBpB,OAEjCG,eAAgBY,EAChBS,QAAQ,SAACC,GACRZ,EAAO9C,MAAM0D,MAAOA,KAItB,OADA9B,GAAMxJ,EAAMkL,EAASP,GACdI,EAAc,GAOtB,QAAAQ,GAA0BvL,EAAa0K,EAA2BC,GAGjE,QAAAa,GAAgCC,GACJ,aAAvBV,EAAc/B,OACjB+B,EAAcnJ,OAAS6J,EAAYV,EAAcpD,OACjDoD,EAAgBA,EAAcW,QAIhC,QAAAd,GAAiBe,GAGhB,MAFAZ,GAAca,SAAShE,KAAK+D,GAC5BH,EAAuBG,EAAUhE,OAASgE,EAAU/J,QAC7C+J,EAb8B,SAAAjB,IAAAA,KACtC,IAAIK,IAAyB/B,KAAM,QAASrB,OAAQ,GAAI/F,OAAQ,GAAIgK,aAehEV,GACHzB,cAAe,SAAC9B,GACfoD,EAAgBH,GAAU5B,KAAM,SAAUrB,OAAAA,EAAQ/F,OAAQ,GAAI8J,OAAQX,EAAea,eAEtFlC,iBAAkB,SAACC,EAAchC,EAAgB/F,GAChDmJ,EAAgBH,GAAU5B,KAAM,WAAYrB,OAAAA,EAAQ/F,OAAQ,GAAI8J,OAAQX,EAAea,cACvFb,EAAca,SAAShE,MAAOoB,KAAM,SAAU1I,MAAOqJ,EAAMhC,OAAAA,EAAQ/F,OAAAA,EAAQ8J,OAAQX,KAEpFnB,YAAa,SAACjC,EAAgB/F,GAC7B4J,EAAuB7D,GACvBoD,EAAcnJ,OAAS+F,EAAS/F,EAASmJ,EAAcpD,OACvDoD,EAAgBA,EAAcW,QAE/B5B,aAAc,SAACnC,EAAgB/F,GAC9BmJ,EAAgBH,GAAU5B,KAAM,QAASrB,OAAAA,EAAQ/F,OAAQ,GAAI8J,OAAQX,EAAea,eAErF7B,WAAY,SAACpC,EAAgB/F,GAC5BmJ,EAAcnJ,OAAS+F,EAAS/F,EAASmJ,EAAcpD,OACvDoD,EAAgBA,EAAcW,QAE/B1B,eAAgB,SAAC1J,EAAYqH,EAAgB/F,GAC5CgJ,GAAU5B,KAAMJ,EAAmBtI,GAAQqH,OAAAA,EAAQ/F,OAAAA,EAAQ8J,OAAQX,EAAezK,MAAAA,KAEnF2J,YAAa,SAACC,EAAavC,EAAgB/F,GACf,aAAvBmJ,EAAc/B,OACL,MAARkB,EACHa,EAAc7B,aAAevB,EACX,MAARuC,GACVsB,EAAuB7D,KAI1B0D,QAAQ,SAACC,GACRZ,EAAO9C,MAAM0D,MAAOA,KAGtB9B,GAAMxJ,EAAMkL,EAASP,EAErB,IAAIpI,GAASwI,EAAca,SAAS,EAIpC,OAHIrJ,UACIA,GAAOmJ,OAERnJ,EAGR,QAAAsJ,GAAmCC,EAAY1B,GAC9C,GAAK0B,EAAL,CAIA,IAAoB,GADhBC,GAAOD,EACSE,EAAA,EAAAC,EAAA7B,EAAA4B,EAAAC,EAAArK,OAAAoK,IAAK,CAApB,GAAIE,GAAOD,EAAAD,EACf,IAAuB,gBAAZE,GAAsB,CAChC,GAAkB,WAAdH,EAAK/C,KACR,MAGD,KAAyB,GADrBmD,IAAQ,EACaC,EAAA,EAAAC,EAAAN,EAAKH,SAALQ,EAAAC,EAAAzK,OAAAwK,IAAc,CAAlC,GAAIE,GAAYD,EAAAD,EACpB,IAAIE,EAAaV,SAAS,GAAGtL,QAAU4L,EAAS,CAC/CH,EAAOO,EAAaV,SAAS,GAC7BO,GAAQ,CACR,QAGF,IAAKA,EACJ,WAEK,CACN,GAAII,GAAiBL,CACrB,IAAkB,UAAdH,EAAK/C,MAA4B,EAARuD,GAAaA,GAASR,EAAKH,SAAShK,OAChE,MAEDmK,GAAOA,EAAKH,SAASW,IAGvB,MAAOR,IAGR,QAAAS,GAA6BT,GAC5B,GAAkB,UAAdA,EAAK/C,KACR,MAAO+C,GAAKH,SAASa,IAAID,EACnB,IAAkB,WAAdT,EAAK/C,KAAmB,CAElC,IAAiB,GADb0D,MACaV,EAAA,EAAAI,EAAAL,EAAKH,SAALI,EAAAI,EAAAxK,OAAAoK,IAAc,CAA1B,GAAIW,GAAIP,EAAAJ,EACZU,GAAIC,EAAKf,SAAS,GAAGtL,OAASkM,EAAaG,EAAKf,SAAS,IAE1D,MAAOc,GAER,MAAOX,GAAKzL,MAOb,QAAAkJ,GAAsBxJ,EAAakL,EAAsBP,GAIxD,QAAAiC,GAAsBC,GACrB,MAAOA,GAAgB,WAAM,MAAAA,GAAcpF,EAASpB,iBAAkBoB,EAASnB,mBAAoB,WAAM,OAAA,GAE1G,QAAAwG,GAA0BD,GACzB,MAAOA,GAAgB,SAACE,GAAW,MAAAF,GAAcE,EAAKtF,EAASpB,iBAAkBoB,EAASnB,mBAAoB,WAAM,OAAA,GAarH,QAAA9C,KACC,OAAa,CACZ,GAAIpC,GAAQqG,EAASvB,MACrB,QAAQ9E,GACP,IAAKC,GAAWwD,kBAChB,IAAKxD,GAAW6D,mBACX8H,GACHC,EAAYhF,EAAeC,cAE5B,MACD,KAAK7G,GAAWC,QACf2L,EAAYhF,EAAeC,cAC3B,MACD,KAAK7G,GAAWuC,OAChB,IAAKvC,GAAW0C,gBACf,KACD,SACC,MAAO3C,KAKX,QAAA6L,GAAqB3B,EAAsB4B,EAAmCC,GAE7E,GAF0C,SAAAD,IAAAA,MAAmC,SAAAC,IAAAA,MAC7E9B,EAAQC,GACJ4B,EAAetL,OAASuL,EAAUvL,OAAS,EAE9C,IADA,GAAIR,GAAQqG,EAAStB,WACd/E,IAAUC,EAAWoC,KAAK,CAChC,GAAsC,KAAlCyJ,EAAeE,QAAQhM,GAAe,CACzCoC,GACA,OACM,GAAiC,KAA7B2J,EAAUC,QAAQhM,GAC5B,KAEDA,GAAQoC,KAKX,QAAA6J,GAAqBC,GACpB,GAAI7F,EAAStB,aAAe9E,EAAWuD,cACtC,OAAO,CAER,IAAItE,GAAQmH,EAASrB,eAOrB,OANIkH,GACHtD,EAAe1J,GAEfoJ,EAAiBpJ,GAElBkD,KACO,EAGR,QAAA+J,KACC,OAAQ9F,EAAStB,YAChB,IAAK9E,GAAWsE,eACf,GAAIrF,GAAQ,CACZ,KACCA,EAAQkN,KAAK/C,MAAMhD,EAASrB,iBACP,gBAAV9F,KACV2M,EAAYhF,EAAeG,qBAC3B9H,EAAQ,GAER,MAAO6B,GACR8K,EAAYhF,EAAeG,qBAE5B4B,EAAe1J,EACf,MACD,KAAKe,GAAW0E,YACfiE,EAAe,KACf,MACD,KAAK3I,GAAWwE,YACfmE,GAAe,EACf,MACD,KAAK3I,GAAWyE,aACfkE,GAAe,EACf,MACD,SACC,OAAO,EAGT,MADAxG,MACO,EAGR,QAAAiK,KACC,MAAKJ,IAAY,IAIb5F,EAAStB,aAAe9E,EAAWoD,YACtCwF,EAAY,KACZzG,IAEKkK,KACJT,EAAYhF,EAAeK,kBAAoBjH,EAAW8C,gBAAiB9C,EAAWsD,cAGvFsI,EAAYhF,EAAeM,kBAAoBlH,EAAW8C,gBAAiB9C,EAAWsD,cAEhF,IAbNsI,EAAYhF,EAAeI,yBAA2BhH,EAAW8C,gBAAiB9C,EAAWsD,cACtF,GAeT,QAAAgJ,KACC,GAAIlG,EAAStB,aAAe9E,EAAW4C,eACtC,OAAO,CAERwF,KACAjG,GAGA,KADA,GAAIoK,IAAa,EACVnG,EAAStB,aAAe9E,EAAW8C,iBAAmBsD,EAAStB,aAAe9E,EAAWoC,KAC3FgE,EAAStB,aAAe9E,EAAWsD,YACjCiJ,GACJX,EAAYhF,EAAeK,qBAE5B2B,EAAY,KACZzG,KACUoK,GACVX,EAAYhF,EAAeO,qBAEvBiF,KACJR,EAAYhF,EAAeK,kBAAoBjH,EAAW8C,gBAAiB9C,EAAWsD,aAEvFiJ,GAAa,CAQd,OANAhE,KACInC,EAAStB,aAAe9E,EAAW8C,gBACtC8I,EAAYhF,EAAeQ,oBAAqBpH,EAAW8C,qBAE3DX,KAEM,EAGR,QAAAqK,KACC,GAAIpG,EAAStB,aAAe9E,EAAWgD,iBACtC,OAAO,CAERyF,KACAtG,GAGA,KADA,GAAIoK,IAAa,EACVnG,EAAStB,aAAe9E,EAAWkD,mBAAqBkD,EAAStB,aAAe9E,EAAWoC,KAC7FgE,EAAStB,aAAe9E,EAAWsD,YACjCiJ,GACJX,EAAYhF,EAAeK,qBAE5B2B,EAAY,KACZzG,KACUoK,GACVX,EAAYhF,EAAeO,qBAEvBkF,KACJT,EAAYhF,EAAeK,kBAAoBjH,EAAWkD,kBAAmBlD,EAAWsD,aAEzFiJ,GAAa,CAQd,OANA7D,KACItC,EAAStB,aAAe9E,EAAWkD,kBACtC0I,EAAYhF,EAAeS,sBAAuBrH,EAAWkD,uBAE7Df,KAEM,EAGR,QAAAkK,KACC,MAAOG,MAAgBF,KAAiBN,GAAY,IAASE,IAzL9D,GAAI9F,GAAW1H,EAAcC,GAAM,GAS/ByJ,EAAgBmD,EAAa1B,EAAQzB,eACxCC,EAAmBoD,EAAc5B,EAAQxB,kBACzCE,EAAcgD,EAAa1B,EAAQtB,aACnCE,EAAe8C,EAAa1B,EAAQpB,cACpCC,EAAa6C,EAAa1B,EAAQnB,YAClCC,EAAiB8C,EAAc5B,EAAQlB,gBACvCC,EAAc6C,EAAc5B,EAAQjB,aACpCoB,EAAUyB,EAAc5B,EAAQG,SAE7B2B,EAAmBrC,GAAWA,EAAQqC,gBA2K1C,OADAxJ,KACIiE,EAAStB,aAAe9E,EAAWoC,KAC/B,EAEHiK,KAIDjG,EAAStB,aAAe9E,EAAWoC,KACtCwJ,EAAYhF,EAAeU,0BAErB,IANNsE,EAAYhF,EAAeK,sBACpB,IArpCT,SAAY9G,GACXA,EAAAA,EAAA,KAAA,GAAA,OACAA,EAAAA,EAAA,uBAAA,GAAA,yBACAA,EAAAA,EAAA,sBAAA,GAAA,wBACAA,EAAAA,EAAA,sBAAA,GAAA,wBACAA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,uBAAA,GAAA,0BANWzC,EAAAyC,YAAAzC,EAAAyC,cAAZ,IAAYA,GAAAzC,EAAAyC,WASZ,SAAYH,GACXA,EAAAA,EAAA,QAAA,GAAA,UACAA,EAAAA,EAAA,eAAA,GAAA,iBACAA,EAAAA,EAAA,gBAAA,GAAA,kBACAA,EAAAA,EAAA,iBAAA,GAAA,mBACAA,EAAAA,EAAA,kBAAA,GAAA,oBACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,WAAA,GAAA,aACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,YAAA,GAAA,cACAA,EAAAA,EAAA,aAAA,GAAA,eACAA,EAAAA,EAAA,cAAA,IAAA,gBACAA,EAAAA,EAAA,eAAA,IAAA,iBACAA,EAAAA,EAAA,kBAAA,IAAA,oBACAA,EAAAA,EAAA,mBAAA,IAAA,qBACAA,EAAAA,EAAA,gBAAA,IAAA,kBACAA,EAAAA,EAAA,OAAA,IAAA,SACAA,EAAAA,EAAA,IAAA,IAAA,OAjBWtC,EAAAsC,aAAAtC,EAAAsC,eAAZ,IAAYA,GAAAtC,EAAAsC,UA6DItC,GAAAgB,cAAaA,CA+W7B,IAAKW,IAAL,SAAKA,GACJA,EAAAA,EAAA,cAAA,GAAA,gBACAA,EAAAA,EAAA,kBAAA,KAAA,oBAEAA,EAAAA,EAAA,SAAA,IAAA,WACAA,EAAAA,EAAA,eAAA,IAAA,iBACAA,EAAAA,EAAA,cAAA,MAAA,gBACAA,EAAAA,EAAA,mBAAA,MAAA,qBAIAA,EAAAA,EAAA,SAAA,KAAA,WAGAA,EAAAA,EAAA,MAAA,IAAA,QACAA,EAAAA,EAAA,iBAAA,KAAA,mBACAA,EAAAA,EAAA,OAAA,MAAA,SACAA,EAAAA,EAAA,OAAA,MAAA,SACAA,EAAAA,EAAA,QAAA,MAAA,UACAA,EAAAA,EAAA,QAAA,MAAA,UACAA,EAAAA,EAAA,gBAAA,MAAA,kBACAA,EAAAA,EAAA,eAAA,MAAA,iBACAA,EAAAA,EAAA,cAAA,MAAA,gBACAA,EAAAA,EAAA,YAAA,MAAA,cACAA,EAAAA,EAAA,iBAAA,MAAA,mBACAA,EAAAA,EAAA,UAAA,MAAA,YACAA,EAAAA,EAAA,UAAA,MAAA,YACAA,EAAAA,EAAA,eAAA,MAAA,iBACAA,EAAAA,EAAA,mBAAA,MAAA,qBACAA,EAAAA,EAAA,iBAAA,OAAA,mBACAA,EAAAA,EAAA,kBAAA,MAAA,oBACAA,EAAAA,EAAA,MAAA,MAAA,QAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IAEAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KACAA,EAAAA,EAAA,GAAA,IAAA,KAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IACAA,EAAAA,EAAA,EAAA,KAAA,IAEAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,EAAA,EAAA,IAAA,IACAA,EAAAA,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","file":"vs/languages/json/common/json.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.2.3(84e204b238a1eff25d4c6f611fdcd76a494005a7)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n\ndefine(\"vs/languages/json/common/features/jsonTokenTypes\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.TOKEN_DELIM_OBJECT = 'punctuation.bracket.json';\r\n    exports.TOKEN_DELIM_ARRAY = 'punctuation.array.json';\r\n    exports.TOKEN_DELIM_COLON = 'punctuation.colon.json';\r\n    exports.TOKEN_DELIM_COMMA = 'punctuation.comma.json';\r\n    exports.TOKEN_VALUE_BOOLEAN = 'support.property-value.keyword.json';\r\n    exports.TOKEN_VALUE_NULL = 'support.property-value.constant.other.json';\r\n    exports.TOKEN_VALUE_STRING = 'support.property-value.string.value.json';\r\n    exports.TOKEN_VALUE_NUMBER = 'support.property-value.constant.numeric.json';\r\n    exports.TOKEN_PROPERTY_NAME = 'support.type.property-name.json';\r\n    exports.TOKEN_COMMENT_BLOCK = 'comment.block.json';\r\n    exports.TOKEN_COMMENT_LINE = 'comment.line.json';\r\n});\r\n\ndefine(\"vs/nls!vs/base/common/json\",['vs/nls', 'vs/nls!vs/languages/json/common/json'], function(nls, data) { return nls.create(\"vs/base/common/json\", data); });\ndefine(\"vs/base/common/json\", [\"require\", \"exports\", 'vs/nls!vs/base/common/json'], function (require, exports, nls_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    (function (ScanError) {\r\n        ScanError[ScanError[\"None\"] = 0] = \"None\";\r\n        ScanError[ScanError[\"UnexpectedEndOfComment\"] = 1] = \"UnexpectedEndOfComment\";\r\n        ScanError[ScanError[\"UnexpectedEndOfString\"] = 2] = \"UnexpectedEndOfString\";\r\n        ScanError[ScanError[\"UnexpectedEndOfNumber\"] = 3] = \"UnexpectedEndOfNumber\";\r\n        ScanError[ScanError[\"InvalidUnicode\"] = 4] = \"InvalidUnicode\";\r\n        ScanError[ScanError[\"InvalidEscapeCharacter\"] = 5] = \"InvalidEscapeCharacter\";\r\n    })(exports.ScanError || (exports.ScanError = {}));\r\n    var ScanError = exports.ScanError;\r\n    (function (SyntaxKind) {\r\n        SyntaxKind[SyntaxKind[\"Unknown\"] = 0] = \"Unknown\";\r\n        SyntaxKind[SyntaxKind[\"OpenBraceToken\"] = 1] = \"OpenBraceToken\";\r\n        SyntaxKind[SyntaxKind[\"CloseBraceToken\"] = 2] = \"CloseBraceToken\";\r\n        SyntaxKind[SyntaxKind[\"OpenBracketToken\"] = 3] = \"OpenBracketToken\";\r\n        SyntaxKind[SyntaxKind[\"CloseBracketToken\"] = 4] = \"CloseBracketToken\";\r\n        SyntaxKind[SyntaxKind[\"CommaToken\"] = 5] = \"CommaToken\";\r\n        SyntaxKind[SyntaxKind[\"ColonToken\"] = 6] = \"ColonToken\";\r\n        SyntaxKind[SyntaxKind[\"NullKeyword\"] = 7] = \"NullKeyword\";\r\n        SyntaxKind[SyntaxKind[\"TrueKeyword\"] = 8] = \"TrueKeyword\";\r\n        SyntaxKind[SyntaxKind[\"FalseKeyword\"] = 9] = \"FalseKeyword\";\r\n        SyntaxKind[SyntaxKind[\"StringLiteral\"] = 10] = \"StringLiteral\";\r\n        SyntaxKind[SyntaxKind[\"NumericLiteral\"] = 11] = \"NumericLiteral\";\r\n        SyntaxKind[SyntaxKind[\"LineCommentTrivia\"] = 12] = \"LineCommentTrivia\";\r\n        SyntaxKind[SyntaxKind[\"BlockCommentTrivia\"] = 13] = \"BlockCommentTrivia\";\r\n        SyntaxKind[SyntaxKind[\"LineBreakTrivia\"] = 14] = \"LineBreakTrivia\";\r\n        SyntaxKind[SyntaxKind[\"Trivia\"] = 15] = \"Trivia\";\r\n        SyntaxKind[SyntaxKind[\"EOF\"] = 16] = \"EOF\";\r\n    })(exports.SyntaxKind || (exports.SyntaxKind = {}));\r\n    var SyntaxKind = exports.SyntaxKind;\r\n    /**\r\n     * Creates a JSON scanner on the given text.\r\n     * If ignoreTrivia is set, whitespaces or comments are ignored.\r\n     */\r\n    function createScanner(text, ignoreTrivia) {\r\n        if (ignoreTrivia === void 0) { ignoreTrivia = false; }\r\n        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;\r\n        function scanHexDigits(count, exact) {\r\n            var digits = 0;\r\n            var value = 0;\r\n            while (digits < count || !exact) {\r\n                var ch = text.charCodeAt(pos);\r\n                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\r\n                    value = value * 16 + ch - CharacterCodes._0;\r\n                }\r\n                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\r\n                    value = value * 16 + ch - CharacterCodes.A + 10;\r\n                }\r\n                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\r\n                    value = value * 16 + ch - CharacterCodes.a + 10;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n                pos++;\r\n                digits++;\r\n            }\r\n            if (digits < count) {\r\n                value = -1;\r\n            }\r\n            return value;\r\n        }\r\n        function setPosition(newPosition) {\r\n            pos = newPosition;\r\n            value = '';\r\n            tokenOffset = 0;\r\n            token = SyntaxKind.Unknown;\r\n            scanError = ScanError.None;\r\n        }\r\n        function scanNumber() {\r\n            var start = pos;\r\n            if (text.charCodeAt(pos) === CharacterCodes._0) {\r\n                pos++;\r\n            }\r\n            else {\r\n                pos++;\r\n                while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n                    pos++;\r\n                }\r\n            }\r\n            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\r\n                pos++;\r\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n                    pos++;\r\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n                        pos++;\r\n                    }\r\n                }\r\n                else {\r\n                    scanError = ScanError.UnexpectedEndOfNumber;\r\n                    return text.substring(start, pos);\r\n                }\r\n            }\r\n            var end = pos;\r\n            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\r\n                pos++;\r\n                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\r\n                    pos++;\r\n                }\r\n                if (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n                    pos++;\r\n                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {\r\n                        pos++;\r\n                    }\r\n                    end = pos;\r\n                }\r\n                else {\r\n                    scanError = ScanError.UnexpectedEndOfNumber;\r\n                }\r\n            }\r\n            return text.substring(start, end);\r\n        }\r\n        function scanString() {\r\n            var result = '', start = pos;\r\n            while (true) {\r\n                if (pos >= len) {\r\n                    result += text.substring(start, pos);\r\n                    scanError = ScanError.UnexpectedEndOfString;\r\n                    break;\r\n                }\r\n                var ch = text.charCodeAt(pos);\r\n                if (ch === CharacterCodes.doubleQuote) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    break;\r\n                }\r\n                if (ch === CharacterCodes.backslash) {\r\n                    result += text.substring(start, pos);\r\n                    pos++;\r\n                    if (pos >= len) {\r\n                        scanError = ScanError.UnexpectedEndOfString;\r\n                        break;\r\n                    }\r\n                    ch = text.charCodeAt(pos++);\r\n                    switch (ch) {\r\n                        case CharacterCodes.doubleQuote:\r\n                            result += '\\\"';\r\n                            break;\r\n                        case CharacterCodes.backslash:\r\n                            result += '\\\\';\r\n                            break;\r\n                        case CharacterCodes.slash:\r\n                            result += '/';\r\n                            break;\r\n                        case CharacterCodes.b:\r\n                            result += '\\b';\r\n                            break;\r\n                        case CharacterCodes.f:\r\n                            result += '\\f';\r\n                            break;\r\n                        case CharacterCodes.n:\r\n                            result += '\\n';\r\n                            break;\r\n                        case CharacterCodes.r:\r\n                            result += '\\r';\r\n                            break;\r\n                        case CharacterCodes.t:\r\n                            result += '\\t';\r\n                            break;\r\n                        case CharacterCodes.u:\r\n                            var ch_1 = scanHexDigits(4, true);\r\n                            if (ch_1 >= 0) {\r\n                                result += String.fromCharCode(ch_1);\r\n                            }\r\n                            else {\r\n                                scanError = ScanError.InvalidUnicode;\r\n                            }\r\n                            break;\r\n                        default:\r\n                            scanError = ScanError.InvalidEscapeCharacter;\r\n                    }\r\n                    start = pos;\r\n                    continue;\r\n                }\r\n                if (isLineBreak(ch)) {\r\n                    result += text.substring(start, pos);\r\n                    scanError = ScanError.UnexpectedEndOfString;\r\n                    break;\r\n                }\r\n                pos++;\r\n            }\r\n            return result;\r\n        }\r\n        function scanNext() {\r\n            value = '';\r\n            scanError = ScanError.None;\r\n            tokenOffset = pos;\r\n            if (pos >= len) {\r\n                // at the end\r\n                tokenOffset = len;\r\n                return token = SyntaxKind.EOF;\r\n            }\r\n            var code = text.charCodeAt(pos);\r\n            // trivia: whitespace\r\n            if (isWhiteSpace(code)) {\r\n                do {\r\n                    pos++;\r\n                    value += String.fromCharCode(code);\r\n                    code = text.charCodeAt(pos);\r\n                } while (isWhiteSpace(code));\r\n                return token = SyntaxKind.Trivia;\r\n            }\r\n            // trivia: newlines\r\n            if (isLineBreak(code)) {\r\n                pos++;\r\n                value += String.fromCharCode(code);\r\n                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\r\n                    pos++;\r\n                    value += '\\n';\r\n                }\r\n                return token = SyntaxKind.LineBreakTrivia;\r\n            }\r\n            switch (code) {\r\n                // tokens: []{}:,\r\n                case CharacterCodes.openBrace:\r\n                    pos++;\r\n                    return token = SyntaxKind.OpenBraceToken;\r\n                case CharacterCodes.closeBrace:\r\n                    pos++;\r\n                    return token = SyntaxKind.CloseBraceToken;\r\n                case CharacterCodes.openBracket:\r\n                    pos++;\r\n                    return token = SyntaxKind.OpenBracketToken;\r\n                case CharacterCodes.closeBracket:\r\n                    pos++;\r\n                    return token = SyntaxKind.CloseBracketToken;\r\n                case CharacterCodes.colon:\r\n                    pos++;\r\n                    return token = SyntaxKind.ColonToken;\r\n                case CharacterCodes.comma:\r\n                    pos++;\r\n                    return token = SyntaxKind.CommaToken;\r\n                // strings\r\n                case CharacterCodes.doubleQuote:\r\n                    pos++;\r\n                    value = scanString();\r\n                    return token = SyntaxKind.StringLiteral;\r\n                // comments\r\n                case CharacterCodes.slash:\r\n                    var start = pos - 1;\r\n                    // Single-line comment\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                        pos += 2;\r\n                        while (pos < len) {\r\n                            if (isLineBreak(text.charCodeAt(pos))) {\r\n                                break;\r\n                            }\r\n                            pos++;\r\n                        }\r\n                        value = text.substring(start, pos);\r\n                        return token = SyntaxKind.LineCommentTrivia;\r\n                    }\r\n                    // Multi-line comment\r\n                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\r\n                        pos += 2;\r\n                        var safeLength = len - 1; // For lookahead.\r\n                        var commentClosed = false;\r\n                        while (pos < safeLength) {\r\n                            var ch = text.charCodeAt(pos);\r\n                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\r\n                                pos += 2;\r\n                                commentClosed = true;\r\n                                break;\r\n                            }\r\n                            pos++;\r\n                        }\r\n                        if (!commentClosed) {\r\n                            pos++;\r\n                            scanError = ScanError.UnexpectedEndOfComment;\r\n                        }\r\n                        value = text.substring(start, pos);\r\n                        return token = SyntaxKind.BlockCommentTrivia;\r\n                    }\r\n                    // just a single slash\r\n                    value += String.fromCharCode(code);\r\n                    pos++;\r\n                    return token = SyntaxKind.Unknown;\r\n                // numbers\r\n                case CharacterCodes.minus:\r\n                    value += String.fromCharCode(code);\r\n                    pos++;\r\n                    if (pos === len || !isDigit(text.charCodeAt(pos))) {\r\n                        return token = SyntaxKind.Unknown;\r\n                    }\r\n                // found a minus, followed by a number so\r\n                // we fall through to proceed with scanning\r\n                // numbers\r\n                case CharacterCodes._0:\r\n                case CharacterCodes._1:\r\n                case CharacterCodes._2:\r\n                case CharacterCodes._3:\r\n                case CharacterCodes._4:\r\n                case CharacterCodes._5:\r\n                case CharacterCodes._6:\r\n                case CharacterCodes._7:\r\n                case CharacterCodes._8:\r\n                case CharacterCodes._9:\r\n                    value += scanNumber();\r\n                    return token = SyntaxKind.NumericLiteral;\r\n                // literals and unknown symbols\r\n                default:\r\n                    // is a literal? Read the full word.\r\n                    while (pos < len && isUnknownContentCharacter(code)) {\r\n                        pos++;\r\n                        code = text.charCodeAt(pos);\r\n                    }\r\n                    if (tokenOffset !== pos) {\r\n                        value = text.substring(tokenOffset, pos);\r\n                        // keywords: true, false, null\r\n                        switch (value) {\r\n                            case 'true': return token = SyntaxKind.TrueKeyword;\r\n                            case 'false': return token = SyntaxKind.FalseKeyword;\r\n                            case 'null': return token = SyntaxKind.NullKeyword;\r\n                        }\r\n                        return token = SyntaxKind.Unknown;\r\n                    }\r\n                    // some\r\n                    value += String.fromCharCode(code);\r\n                    pos++;\r\n                    return token = SyntaxKind.Unknown;\r\n            }\r\n        }\r\n        function isUnknownContentCharacter(code) {\r\n            if (isWhiteSpace(code) || isLineBreak(code)) {\r\n                return false;\r\n            }\r\n            switch (code) {\r\n                case CharacterCodes.closeBrace:\r\n                case CharacterCodes.closeBracket:\r\n                case CharacterCodes.openBrace:\r\n                case CharacterCodes.openBracket:\r\n                case CharacterCodes.doubleQuote:\r\n                case CharacterCodes.colon:\r\n                case CharacterCodes.comma:\r\n                    return false;\r\n            }\r\n            return true;\r\n        }\r\n        function scanNextNonTrivia() {\r\n            var result;\r\n            do {\r\n                result = scanNext();\r\n            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\r\n            return result;\r\n        }\r\n        return {\r\n            setPosition: setPosition,\r\n            getPosition: function () { return pos; },\r\n            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\r\n            getToken: function () { return token; },\r\n            getTokenValue: function () { return value; },\r\n            getTokenOffset: function () { return tokenOffset; },\r\n            getTokenLength: function () { return pos - tokenOffset; },\r\n            getTokenError: function () { return scanError; }\r\n        };\r\n    }\r\n    exports.createScanner = createScanner;\r\n    function isWhiteSpace(ch) {\r\n        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\r\n            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\r\n            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\r\n    }\r\n    function isLineBreak(ch) {\r\n        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\r\n    }\r\n    function isDigit(ch) {\r\n        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\r\n    }\r\n    var CharacterCodes;\r\n    (function (CharacterCodes) {\r\n        CharacterCodes[CharacterCodes[\"nullCharacter\"] = 0] = \"nullCharacter\";\r\n        CharacterCodes[CharacterCodes[\"maxAsciiCharacter\"] = 127] = \"maxAsciiCharacter\";\r\n        CharacterCodes[CharacterCodes[\"lineFeed\"] = 10] = \"lineFeed\";\r\n        CharacterCodes[CharacterCodes[\"carriageReturn\"] = 13] = \"carriageReturn\";\r\n        CharacterCodes[CharacterCodes[\"lineSeparator\"] = 8232] = \"lineSeparator\";\r\n        CharacterCodes[CharacterCodes[\"paragraphSeparator\"] = 8233] = \"paragraphSeparator\";\r\n        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\r\n        // like an odd disparity?  (Or maybe it's completely fine for them to be different).\r\n        CharacterCodes[CharacterCodes[\"nextLine\"] = 133] = \"nextLine\";\r\n        // Unicode 3.0 space characters\r\n        CharacterCodes[CharacterCodes[\"space\"] = 32] = \"space\";\r\n        CharacterCodes[CharacterCodes[\"nonBreakingSpace\"] = 160] = \"nonBreakingSpace\";\r\n        CharacterCodes[CharacterCodes[\"enQuad\"] = 8192] = \"enQuad\";\r\n        CharacterCodes[CharacterCodes[\"emQuad\"] = 8193] = \"emQuad\";\r\n        CharacterCodes[CharacterCodes[\"enSpace\"] = 8194] = \"enSpace\";\r\n        CharacterCodes[CharacterCodes[\"emSpace\"] = 8195] = \"emSpace\";\r\n        CharacterCodes[CharacterCodes[\"threePerEmSpace\"] = 8196] = \"threePerEmSpace\";\r\n        CharacterCodes[CharacterCodes[\"fourPerEmSpace\"] = 8197] = \"fourPerEmSpace\";\r\n        CharacterCodes[CharacterCodes[\"sixPerEmSpace\"] = 8198] = \"sixPerEmSpace\";\r\n        CharacterCodes[CharacterCodes[\"figureSpace\"] = 8199] = \"figureSpace\";\r\n        CharacterCodes[CharacterCodes[\"punctuationSpace\"] = 8200] = \"punctuationSpace\";\r\n        CharacterCodes[CharacterCodes[\"thinSpace\"] = 8201] = \"thinSpace\";\r\n        CharacterCodes[CharacterCodes[\"hairSpace\"] = 8202] = \"hairSpace\";\r\n        CharacterCodes[CharacterCodes[\"zeroWidthSpace\"] = 8203] = \"zeroWidthSpace\";\r\n        CharacterCodes[CharacterCodes[\"narrowNoBreakSpace\"] = 8239] = \"narrowNoBreakSpace\";\r\n        CharacterCodes[CharacterCodes[\"ideographicSpace\"] = 12288] = \"ideographicSpace\";\r\n        CharacterCodes[CharacterCodes[\"mathematicalSpace\"] = 8287] = \"mathematicalSpace\";\r\n        CharacterCodes[CharacterCodes[\"ogham\"] = 5760] = \"ogham\";\r\n        CharacterCodes[CharacterCodes[\"_\"] = 95] = \"_\";\r\n        CharacterCodes[CharacterCodes[\"$\"] = 36] = \"$\";\r\n        CharacterCodes[CharacterCodes[\"_0\"] = 48] = \"_0\";\r\n        CharacterCodes[CharacterCodes[\"_1\"] = 49] = \"_1\";\r\n        CharacterCodes[CharacterCodes[\"_2\"] = 50] = \"_2\";\r\n        CharacterCodes[CharacterCodes[\"_3\"] = 51] = \"_3\";\r\n        CharacterCodes[CharacterCodes[\"_4\"] = 52] = \"_4\";\r\n        CharacterCodes[CharacterCodes[\"_5\"] = 53] = \"_5\";\r\n        CharacterCodes[CharacterCodes[\"_6\"] = 54] = \"_6\";\r\n        CharacterCodes[CharacterCodes[\"_7\"] = 55] = \"_7\";\r\n        CharacterCodes[CharacterCodes[\"_8\"] = 56] = \"_8\";\r\n        CharacterCodes[CharacterCodes[\"_9\"] = 57] = \"_9\";\r\n        CharacterCodes[CharacterCodes[\"a\"] = 97] = \"a\";\r\n        CharacterCodes[CharacterCodes[\"b\"] = 98] = \"b\";\r\n        CharacterCodes[CharacterCodes[\"c\"] = 99] = \"c\";\r\n        CharacterCodes[CharacterCodes[\"d\"] = 100] = \"d\";\r\n        CharacterCodes[CharacterCodes[\"e\"] = 101] = \"e\";\r\n        CharacterCodes[CharacterCodes[\"f\"] = 102] = \"f\";\r\n        CharacterCodes[CharacterCodes[\"g\"] = 103] = \"g\";\r\n        CharacterCodes[CharacterCodes[\"h\"] = 104] = \"h\";\r\n        CharacterCodes[CharacterCodes[\"i\"] = 105] = \"i\";\r\n        CharacterCodes[CharacterCodes[\"j\"] = 106] = \"j\";\r\n        CharacterCodes[CharacterCodes[\"k\"] = 107] = \"k\";\r\n        CharacterCodes[CharacterCodes[\"l\"] = 108] = \"l\";\r\n        CharacterCodes[CharacterCodes[\"m\"] = 109] = \"m\";\r\n        CharacterCodes[CharacterCodes[\"n\"] = 110] = \"n\";\r\n        CharacterCodes[CharacterCodes[\"o\"] = 111] = \"o\";\r\n        CharacterCodes[CharacterCodes[\"p\"] = 112] = \"p\";\r\n        CharacterCodes[CharacterCodes[\"q\"] = 113] = \"q\";\r\n        CharacterCodes[CharacterCodes[\"r\"] = 114] = \"r\";\r\n        CharacterCodes[CharacterCodes[\"s\"] = 115] = \"s\";\r\n        CharacterCodes[CharacterCodes[\"t\"] = 116] = \"t\";\r\n        CharacterCodes[CharacterCodes[\"u\"] = 117] = \"u\";\r\n        CharacterCodes[CharacterCodes[\"v\"] = 118] = \"v\";\r\n        CharacterCodes[CharacterCodes[\"w\"] = 119] = \"w\";\r\n        CharacterCodes[CharacterCodes[\"x\"] = 120] = \"x\";\r\n        CharacterCodes[CharacterCodes[\"y\"] = 121] = \"y\";\r\n        CharacterCodes[CharacterCodes[\"z\"] = 122] = \"z\";\r\n        CharacterCodes[CharacterCodes[\"A\"] = 65] = \"A\";\r\n        CharacterCodes[CharacterCodes[\"B\"] = 66] = \"B\";\r\n        CharacterCodes[CharacterCodes[\"C\"] = 67] = \"C\";\r\n        CharacterCodes[CharacterCodes[\"D\"] = 68] = \"D\";\r\n        CharacterCodes[CharacterCodes[\"E\"] = 69] = \"E\";\r\n        CharacterCodes[CharacterCodes[\"F\"] = 70] = \"F\";\r\n        CharacterCodes[CharacterCodes[\"G\"] = 71] = \"G\";\r\n        CharacterCodes[CharacterCodes[\"H\"] = 72] = \"H\";\r\n        CharacterCodes[CharacterCodes[\"I\"] = 73] = \"I\";\r\n        CharacterCodes[CharacterCodes[\"J\"] = 74] = \"J\";\r\n        CharacterCodes[CharacterCodes[\"K\"] = 75] = \"K\";\r\n        CharacterCodes[CharacterCodes[\"L\"] = 76] = \"L\";\r\n        CharacterCodes[CharacterCodes[\"M\"] = 77] = \"M\";\r\n        CharacterCodes[CharacterCodes[\"N\"] = 78] = \"N\";\r\n        CharacterCodes[CharacterCodes[\"O\"] = 79] = \"O\";\r\n        CharacterCodes[CharacterCodes[\"P\"] = 80] = \"P\";\r\n        CharacterCodes[CharacterCodes[\"Q\"] = 81] = \"Q\";\r\n        CharacterCodes[CharacterCodes[\"R\"] = 82] = \"R\";\r\n        CharacterCodes[CharacterCodes[\"S\"] = 83] = \"S\";\r\n        CharacterCodes[CharacterCodes[\"T\"] = 84] = \"T\";\r\n        CharacterCodes[CharacterCodes[\"U\"] = 85] = \"U\";\r\n        CharacterCodes[CharacterCodes[\"V\"] = 86] = \"V\";\r\n        CharacterCodes[CharacterCodes[\"W\"] = 87] = \"W\";\r\n        CharacterCodes[CharacterCodes[\"X\"] = 88] = \"X\";\r\n        CharacterCodes[CharacterCodes[\"Y\"] = 89] = \"Y\";\r\n        CharacterCodes[CharacterCodes[\"Z\"] = 90] = \"Z\";\r\n        CharacterCodes[CharacterCodes[\"ampersand\"] = 38] = \"ampersand\";\r\n        CharacterCodes[CharacterCodes[\"asterisk\"] = 42] = \"asterisk\";\r\n        CharacterCodes[CharacterCodes[\"at\"] = 64] = \"at\";\r\n        CharacterCodes[CharacterCodes[\"backslash\"] = 92] = \"backslash\";\r\n        CharacterCodes[CharacterCodes[\"bar\"] = 124] = \"bar\";\r\n        CharacterCodes[CharacterCodes[\"caret\"] = 94] = \"caret\";\r\n        CharacterCodes[CharacterCodes[\"closeBrace\"] = 125] = \"closeBrace\";\r\n        CharacterCodes[CharacterCodes[\"closeBracket\"] = 93] = \"closeBracket\";\r\n        CharacterCodes[CharacterCodes[\"closeParen\"] = 41] = \"closeParen\";\r\n        CharacterCodes[CharacterCodes[\"colon\"] = 58] = \"colon\";\r\n        CharacterCodes[CharacterCodes[\"comma\"] = 44] = \"comma\";\r\n        CharacterCodes[CharacterCodes[\"dot\"] = 46] = \"dot\";\r\n        CharacterCodes[CharacterCodes[\"doubleQuote\"] = 34] = \"doubleQuote\";\r\n        CharacterCodes[CharacterCodes[\"equals\"] = 61] = \"equals\";\r\n        CharacterCodes[CharacterCodes[\"exclamation\"] = 33] = \"exclamation\";\r\n        CharacterCodes[CharacterCodes[\"greaterThan\"] = 62] = \"greaterThan\";\r\n        CharacterCodes[CharacterCodes[\"lessThan\"] = 60] = \"lessThan\";\r\n        CharacterCodes[CharacterCodes[\"minus\"] = 45] = \"minus\";\r\n        CharacterCodes[CharacterCodes[\"openBrace\"] = 123] = \"openBrace\";\r\n        CharacterCodes[CharacterCodes[\"openBracket\"] = 91] = \"openBracket\";\r\n        CharacterCodes[CharacterCodes[\"openParen\"] = 40] = \"openParen\";\r\n        CharacterCodes[CharacterCodes[\"percent\"] = 37] = \"percent\";\r\n        CharacterCodes[CharacterCodes[\"plus\"] = 43] = \"plus\";\r\n        CharacterCodes[CharacterCodes[\"question\"] = 63] = \"question\";\r\n        CharacterCodes[CharacterCodes[\"semicolon\"] = 59] = \"semicolon\";\r\n        CharacterCodes[CharacterCodes[\"singleQuote\"] = 39] = \"singleQuote\";\r\n        CharacterCodes[CharacterCodes[\"slash\"] = 47] = \"slash\";\r\n        CharacterCodes[CharacterCodes[\"tilde\"] = 126] = \"tilde\";\r\n        CharacterCodes[CharacterCodes[\"backspace\"] = 8] = \"backspace\";\r\n        CharacterCodes[CharacterCodes[\"formFeed\"] = 12] = \"formFeed\";\r\n        CharacterCodes[CharacterCodes[\"byteOrderMark\"] = 65279] = \"byteOrderMark\";\r\n        CharacterCodes[CharacterCodes[\"tab\"] = 9] = \"tab\";\r\n        CharacterCodes[CharacterCodes[\"verticalTab\"] = 11] = \"verticalTab\";\r\n    })(CharacterCodes || (CharacterCodes = {}));\r\n    /**\r\n     * Takes JSON with JavaScript-style comments and remove\r\n     * them. Optionally replaces every none-newline character\r\n     * of comments with a replaceCharacter\r\n     */\r\n    function stripComments(text, replaceCh) {\r\n        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;\r\n        do {\r\n            pos = _scanner.getPosition();\r\n            kind = _scanner.scan();\r\n            switch (kind) {\r\n                case SyntaxKind.LineCommentTrivia:\r\n                case SyntaxKind.BlockCommentTrivia:\r\n                case SyntaxKind.EOF:\r\n                    if (offset !== pos) {\r\n                        parts.push(text.substring(offset, pos));\r\n                    }\r\n                    if (replaceCh !== void 0) {\r\n                        parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\r\n                    }\r\n                    offset = _scanner.getPosition();\r\n                    break;\r\n            }\r\n        } while (kind !== SyntaxKind.EOF);\r\n        return parts.join('');\r\n    }\r\n    exports.stripComments = stripComments;\r\n    (function (ParseErrorCode) {\r\n        ParseErrorCode[ParseErrorCode[\"InvalidSymbol\"] = 0] = \"InvalidSymbol\";\r\n        ParseErrorCode[ParseErrorCode[\"InvalidNumberFormat\"] = 1] = \"InvalidNumberFormat\";\r\n        ParseErrorCode[ParseErrorCode[\"PropertyNameExpected\"] = 2] = \"PropertyNameExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"ValueExpected\"] = 3] = \"ValueExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"ColonExpected\"] = 4] = \"ColonExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"CommaExpected\"] = 5] = \"CommaExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"CloseBraceExpected\"] = 6] = \"CloseBraceExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"CloseBracketExpected\"] = 7] = \"CloseBracketExpected\";\r\n        ParseErrorCode[ParseErrorCode[\"EndOfFileExpected\"] = 8] = \"EndOfFileExpected\";\r\n    })(exports.ParseErrorCode || (exports.ParseErrorCode = {}));\r\n    var ParseErrorCode = exports.ParseErrorCode;\r\n    function getParseErrorMessage(errorCode) {\r\n        switch (errorCode) {\r\n            case ParseErrorCode.InvalidSymbol: return nls_1.localize(0, null);\r\n            case ParseErrorCode.InvalidNumberFormat: return nls_1.localize(1, null);\r\n            case ParseErrorCode.PropertyNameExpected: return nls_1.localize(2, null);\r\n            case ParseErrorCode.ValueExpected: return nls_1.localize(3, null);\r\n            case ParseErrorCode.ColonExpected: return nls_1.localize(4, null);\r\n            case ParseErrorCode.CommaExpected: return nls_1.localize(5, null);\r\n            case ParseErrorCode.CloseBraceExpected: return nls_1.localize(6, null);\r\n            case ParseErrorCode.CloseBracketExpected: return nls_1.localize(7, null);\r\n            case ParseErrorCode.EndOfFileExpected: return nls_1.localize(8, null);\r\n            default:\r\n                return '';\r\n        }\r\n    }\r\n    exports.getParseErrorMessage = getParseErrorMessage;\r\n    function getLiteralNodeType(value) {\r\n        switch (typeof value) {\r\n            case 'boolean': return 'boolean';\r\n            case 'number': return 'number';\r\n            case 'string': return 'string';\r\n            default: return 'null';\r\n        }\r\n    }\r\n    /**\r\n     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\r\n     */\r\n    function getLocation(text, position) {\r\n        var segments = []; // strings or numbers\r\n        var earlyReturnException = new Object();\r\n        var previousNode = void 0;\r\n        var previousNodeInst = {\r\n            value: void 0,\r\n            offset: void 0,\r\n            length: void 0,\r\n            type: void 0\r\n        };\r\n        var isAtPropertyKey = false;\r\n        function setPreviousNode(value, offset, length, type) {\r\n            previousNodeInst.value = value;\r\n            previousNodeInst.offset = offset;\r\n            previousNodeInst.length = length;\r\n            previousNodeInst.type = type;\r\n            previousNodeInst.columnOffset = void 0;\r\n            previousNode = previousNodeInst;\r\n        }\r\n        try {\r\n            visit(text, {\r\n                onObjectBegin: function (offset, length) {\r\n                    if (position <= offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    previousNode = void 0;\r\n                    isAtPropertyKey = position > offset;\r\n                    segments.push(''); // push a placeholder (will be replaced or removed)\r\n                },\r\n                onObjectProperty: function (name, offset, length) {\r\n                    if (position < offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    setPreviousNode(name, offset, length, 'property');\r\n                    segments[segments.length - 1] = name;\r\n                    if (position <= offset + length) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                },\r\n                onObjectEnd: function (offset, length) {\r\n                    if (position <= offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    previousNode = void 0;\r\n                    segments.pop();\r\n                },\r\n                onArrayBegin: function (offset, length) {\r\n                    if (position <= offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    previousNode = void 0;\r\n                    segments.push(0);\r\n                },\r\n                onArrayEnd: function (offset, length) {\r\n                    if (position <= offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    previousNode = void 0;\r\n                    segments.pop();\r\n                },\r\n                onLiteralValue: function (value, offset, length) {\r\n                    if (position < offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    setPreviousNode(value, offset, length, getLiteralNodeType(value));\r\n                    if (position <= offset + length) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                },\r\n                onSeparator: function (sep, offset, length) {\r\n                    if (position <= offset) {\r\n                        throw earlyReturnException;\r\n                    }\r\n                    if (sep === ':' && previousNode.type === 'property') {\r\n                        previousNode.columnOffset = offset;\r\n                        isAtPropertyKey = false;\r\n                        previousNode = void 0;\r\n                    }\r\n                    else if (sep === ',') {\r\n                        var last = segments[segments.length - 1];\r\n                        if (typeof last === 'number') {\r\n                            segments[segments.length - 1] = last + 1;\r\n                        }\r\n                        else {\r\n                            isAtPropertyKey = true;\r\n                            segments[segments.length - 1] = '';\r\n                        }\r\n                        previousNode = void 0;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        catch (e) {\r\n            if (e !== earlyReturnException) {\r\n                throw e;\r\n            }\r\n        }\r\n        if (segments[segments.length - 1] === '') {\r\n            segments.pop();\r\n        }\r\n        return {\r\n            path: segments,\r\n            previousNode: previousNode,\r\n            isAtPropertyKey: isAtPropertyKey,\r\n            matches: function (pattern) {\r\n                var k = 0;\r\n                for (var i = 0; k < pattern.length && i < segments.length; i++) {\r\n                    if (pattern[k] === segments[i] || pattern[k] === '*') {\r\n                        k++;\r\n                    }\r\n                    else if (pattern[k] !== '**') {\r\n                        return false;\r\n                    }\r\n                }\r\n                return k === pattern.length;\r\n            }\r\n        };\r\n    }\r\n    exports.getLocation = getLocation;\r\n    /**\r\n     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\r\n     * Therefore always check the errors list to find out if the input was valid.\r\n     */\r\n    function parse(text, errors, options) {\r\n        if (errors === void 0) { errors = []; }\r\n        var currentProperty = null;\r\n        var currentParent = [];\r\n        var previousParents = [];\r\n        function onValue(value) {\r\n            if (Array.isArray(currentParent)) {\r\n                currentParent.push(value);\r\n            }\r\n            else if (currentProperty) {\r\n                currentParent[currentProperty] = value;\r\n            }\r\n        }\r\n        var visitor = {\r\n            onObjectBegin: function () {\r\n                var object = {};\r\n                onValue(object);\r\n                previousParents.push(currentParent);\r\n                currentParent = object;\r\n                currentProperty = null;\r\n            },\r\n            onObjectProperty: function (name) {\r\n                currentProperty = name;\r\n            },\r\n            onObjectEnd: function () {\r\n                currentParent = previousParents.pop();\r\n            },\r\n            onArrayBegin: function () {\r\n                var array = [];\r\n                onValue(array);\r\n                previousParents.push(currentParent);\r\n                currentParent = array;\r\n                currentProperty = null;\r\n            },\r\n            onArrayEnd: function () {\r\n                currentParent = previousParents.pop();\r\n            },\r\n            onLiteralValue: onValue,\r\n            onError: function (error) {\r\n                errors.push({ error: error });\r\n            }\r\n        };\r\n        visit(text, visitor, options);\r\n        return currentParent[0];\r\n    }\r\n    exports.parse = parse;\r\n    /**\r\n     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\r\n     */\r\n    function parseTree(text, errors, options) {\r\n        if (errors === void 0) { errors = []; }\r\n        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root\r\n        function ensurePropertyComplete(endOffset) {\r\n            if (currentParent.type === 'property') {\r\n                currentParent.length = endOffset - currentParent.offset;\r\n                currentParent = currentParent.parent;\r\n            }\r\n        }\r\n        function onValue(valueNode) {\r\n            currentParent.children.push(valueNode);\r\n            ensurePropertyComplete(valueNode.offset + valueNode.length);\r\n            return valueNode;\r\n        }\r\n        var visitor = {\r\n            onObjectBegin: function (offset) {\r\n                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });\r\n            },\r\n            onObjectProperty: function (name, offset, length) {\r\n                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });\r\n                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });\r\n            },\r\n            onObjectEnd: function (offset, length) {\r\n                ensurePropertyComplete(offset);\r\n                currentParent.length = offset + length - currentParent.offset;\r\n                currentParent = currentParent.parent;\r\n            },\r\n            onArrayBegin: function (offset, length) {\r\n                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });\r\n            },\r\n            onArrayEnd: function (offset, length) {\r\n                currentParent.length = offset + length - currentParent.offset;\r\n                currentParent = currentParent.parent;\r\n            },\r\n            onLiteralValue: function (value, offset, length) {\r\n                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });\r\n            },\r\n            onSeparator: function (sep, offset, length) {\r\n                if (currentParent.type === 'property') {\r\n                    if (sep === ':') {\r\n                        currentParent.columnOffset = offset;\r\n                    }\r\n                    else if (sep === ',') {\r\n                        ensurePropertyComplete(offset);\r\n                    }\r\n                }\r\n            },\r\n            onError: function (error) {\r\n                errors.push({ error: error });\r\n            }\r\n        };\r\n        visit(text, visitor, options);\r\n        var result = currentParent.children[0];\r\n        if (result) {\r\n            delete result.parent;\r\n        }\r\n        return result;\r\n    }\r\n    exports.parseTree = parseTree;\r\n    function findNodeAtLocation(root, path) {\r\n        if (!root) {\r\n            return void 0;\r\n        }\r\n        var node = root;\r\n        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\r\n            var segment = path_1[_i];\r\n            if (typeof segment === 'string') {\r\n                if (node.type !== 'object') {\r\n                    return void 0;\r\n                }\r\n                var found = false;\r\n                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\r\n                    var propertyNode = _b[_a];\r\n                    if (propertyNode.children[0].value === segment) {\r\n                        node = propertyNode.children[1];\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return void 0;\r\n                }\r\n            }\r\n            else {\r\n                var index = segment;\r\n                if (node.type !== 'array' || index < 0 || index >= node.children.length) {\r\n                    return void 0;\r\n                }\r\n                node = node.children[index];\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n    exports.findNodeAtLocation = findNodeAtLocation;\r\n    function getNodeValue(node) {\r\n        if (node.type === 'array') {\r\n            return node.children.map(getNodeValue);\r\n        }\r\n        else if (node.type === 'object') {\r\n            var obj = {};\r\n            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\r\n                var prop = _a[_i];\r\n                obj[prop.children[0].value] = getNodeValue(prop.children[1]);\r\n            }\r\n            return obj;\r\n        }\r\n        return node.value;\r\n    }\r\n    exports.getNodeValue = getNodeValue;\r\n    /**\r\n     * Parses the given text and invokes the visitor functions for each object, array and literal reached.\r\n     */\r\n    function visit(text, visitor, options) {\r\n        var _scanner = createScanner(text, false);\r\n        function toNoArgVisit(visitFunction) {\r\n            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\r\n        }\r\n        function toOneArgVisit(visitFunction) {\r\n            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };\r\n        }\r\n        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);\r\n        var disallowComments = options && options.disallowComments;\r\n        function scanNext() {\r\n            while (true) {\r\n                var token = _scanner.scan();\r\n                switch (token) {\r\n                    case SyntaxKind.LineCommentTrivia:\r\n                    case SyntaxKind.BlockCommentTrivia:\r\n                        if (disallowComments) {\r\n                            handleError(ParseErrorCode.InvalidSymbol);\r\n                        }\r\n                        break;\r\n                    case SyntaxKind.Unknown:\r\n                        handleError(ParseErrorCode.InvalidSymbol);\r\n                        break;\r\n                    case SyntaxKind.Trivia:\r\n                    case SyntaxKind.LineBreakTrivia:\r\n                        break;\r\n                    default:\r\n                        return token;\r\n                }\r\n            }\r\n        }\r\n        function handleError(error, skipUntilAfter, skipUntil) {\r\n            if (skipUntilAfter === void 0) { skipUntilAfter = []; }\r\n            if (skipUntil === void 0) { skipUntil = []; }\r\n            onError(error);\r\n            if (skipUntilAfter.length + skipUntil.length > 0) {\r\n                var token = _scanner.getToken();\r\n                while (token !== SyntaxKind.EOF) {\r\n                    if (skipUntilAfter.indexOf(token) !== -1) {\r\n                        scanNext();\r\n                        break;\r\n                    }\r\n                    else if (skipUntil.indexOf(token) !== -1) {\r\n                        break;\r\n                    }\r\n                    token = scanNext();\r\n                }\r\n            }\r\n        }\r\n        function parseString(isValue) {\r\n            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {\r\n                return false;\r\n            }\r\n            var value = _scanner.getTokenValue();\r\n            if (isValue) {\r\n                onLiteralValue(value);\r\n            }\r\n            else {\r\n                onObjectProperty(value);\r\n            }\r\n            scanNext();\r\n            return true;\r\n        }\r\n        function parseLiteral() {\r\n            switch (_scanner.getToken()) {\r\n                case SyntaxKind.NumericLiteral:\r\n                    var value = 0;\r\n                    try {\r\n                        value = JSON.parse(_scanner.getTokenValue());\r\n                        if (typeof value !== 'number') {\r\n                            handleError(ParseErrorCode.InvalidNumberFormat);\r\n                            value = 0;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        handleError(ParseErrorCode.InvalidNumberFormat);\r\n                    }\r\n                    onLiteralValue(value);\r\n                    break;\r\n                case SyntaxKind.NullKeyword:\r\n                    onLiteralValue(null);\r\n                    break;\r\n                case SyntaxKind.TrueKeyword:\r\n                    onLiteralValue(true);\r\n                    break;\r\n                case SyntaxKind.FalseKeyword:\r\n                    onLiteralValue(false);\r\n                    break;\r\n                default:\r\n                    return false;\r\n            }\r\n            scanNext();\r\n            return true;\r\n        }\r\n        function parseProperty() {\r\n            if (!parseString(false)) {\r\n                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\r\n                return false;\r\n            }\r\n            if (_scanner.getToken() === SyntaxKind.ColonToken) {\r\n                onSeparator(':');\r\n                scanNext(); // consume colon\r\n                if (!parseValue()) {\r\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\r\n                }\r\n            }\r\n            else {\r\n                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\r\n            }\r\n            return true;\r\n        }\r\n        function parseObject() {\r\n            if (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {\r\n                return false;\r\n            }\r\n            onObjectBegin();\r\n            scanNext(); // consume open brace\r\n            var needsComma = false;\r\n            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\r\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\r\n                    if (!needsComma) {\r\n                        handleError(ParseErrorCode.ValueExpected, [], []);\r\n                    }\r\n                    onSeparator(',');\r\n                    scanNext(); // consume comma\r\n                }\r\n                else if (needsComma) {\r\n                    handleError(ParseErrorCode.CommaExpected, [], []);\r\n                }\r\n                if (!parseProperty()) {\r\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);\r\n                }\r\n                needsComma = true;\r\n            }\r\n            onObjectEnd();\r\n            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\r\n                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\r\n            }\r\n            else {\r\n                scanNext(); // consume close brace\r\n            }\r\n            return true;\r\n        }\r\n        function parseArray() {\r\n            if (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {\r\n                return false;\r\n            }\r\n            onArrayBegin();\r\n            scanNext(); // consume open bracket\r\n            var needsComma = false;\r\n            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\r\n                if (_scanner.getToken() === SyntaxKind.CommaToken) {\r\n                    if (!needsComma) {\r\n                        handleError(ParseErrorCode.ValueExpected, [], []);\r\n                    }\r\n                    onSeparator(',');\r\n                    scanNext(); // consume comma\r\n                }\r\n                else if (needsComma) {\r\n                    handleError(ParseErrorCode.CommaExpected, [], []);\r\n                }\r\n                if (!parseValue()) {\r\n                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);\r\n                }\r\n                needsComma = true;\r\n            }\r\n            onArrayEnd();\r\n            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\r\n                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\r\n            }\r\n            else {\r\n                scanNext(); // consume close bracket\r\n            }\r\n            return true;\r\n        }\r\n        function parseValue() {\r\n            return parseArray() || parseObject() || parseString(true) || parseLiteral();\r\n        }\r\n        scanNext();\r\n        if (_scanner.getToken() === SyntaxKind.EOF) {\r\n            return true;\r\n        }\r\n        if (!parseValue()) {\r\n            handleError(ParseErrorCode.ValueExpected, [], []);\r\n            return false;\r\n        }\r\n        if (_scanner.getToken() !== SyntaxKind.EOF) {\r\n            handleError(ParseErrorCode.EndOfFileExpected, [], []);\r\n        }\r\n        return true;\r\n    }\r\n    exports.visit = visit;\r\n});\r\n\ndefine(\"vs/languages/json/common/features/tokenization\", [\"require\", \"exports\", 'vs/base/common/json', 'vs/languages/json/common/features/jsonTokenTypes'], function (require, exports, json, jsonTokenTypes) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    function createTokenizationSupport(mode, supportComments) {\r\n        return {\r\n            shouldGenerateEmbeddedModels: false,\r\n            getInitialState: function () { return new JSONState(mode, null, null, false); },\r\n            tokenize: function (line, state, offsetDelta, stopAtOffset) { return tokenize(mode, supportComments, line, state, offsetDelta, stopAtOffset); }\r\n        };\r\n    }\r\n    exports.createTokenizationSupport = createTokenizationSupport;\r\n    var JSONState = (function () {\r\n        function JSONState(mode, state, scanError, lastWasColon) {\r\n            this._mode = mode;\r\n            this._state = state;\r\n            this.scanError = scanError;\r\n            this.lastWasColon = lastWasColon;\r\n        }\r\n        JSONState.prototype.clone = function () {\r\n            return new JSONState(this._mode, this._state, this.scanError, this.lastWasColon);\r\n        };\r\n        JSONState.prototype.equals = function (other) {\r\n            if (other === this) {\r\n                return true;\r\n            }\r\n            if (!other || !(other instanceof JSONState)) {\r\n                return false;\r\n            }\r\n            return this.scanError === other.scanError &&\r\n                this.lastWasColon === other.lastWasColon;\r\n        };\r\n        JSONState.prototype.getMode = function () {\r\n            return this._mode;\r\n        };\r\n        JSONState.prototype.tokenize = function (stream) {\r\n            throw new Error();\r\n        };\r\n        JSONState.prototype.getStateData = function () {\r\n            return this._state;\r\n        };\r\n        JSONState.prototype.setStateData = function (state) {\r\n            this._state = state;\r\n        };\r\n        return JSONState;\r\n    }());\r\n    function tokenize(mode, comments, line, state, offsetDelta, stopAtOffset) {\r\n        if (offsetDelta === void 0) { offsetDelta = 0; }\r\n        // handle multiline strings and block comments\r\n        var numberOfInsertedCharacters = 0, adjustOffset = false;\r\n        switch (state.scanError) {\r\n            case json.ScanError.UnexpectedEndOfString:\r\n                line = '\"' + line;\r\n                numberOfInsertedCharacters = 1;\r\n                break;\r\n            case json.ScanError.UnexpectedEndOfComment:\r\n                line = '/*' + line;\r\n                numberOfInsertedCharacters = 2;\r\n                break;\r\n        }\r\n        var scanner = json.createScanner(line), kind, ret, lastWasColon = state.lastWasColon;\r\n        ret = {\r\n            tokens: [],\r\n            actualStopOffset: line.length,\r\n            endState: state.clone(),\r\n            modeTransitions: [{ startIndex: 0, mode: mode }],\r\n        };\r\n        while (true) {\r\n            var offset = offsetDelta + scanner.getPosition(), type = '';\r\n            kind = scanner.scan();\r\n            if (kind === json.SyntaxKind.EOF) {\r\n                break;\r\n            }\r\n            // Check that the scanner has advanced\r\n            if (offset === offsetDelta + scanner.getPosition()) {\r\n                throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\r\n            }\r\n            // In case we inserted /* or \" character, we need to\r\n            // adjust the offset of all tokens (except the first)\r\n            if (adjustOffset) {\r\n                offset -= numberOfInsertedCharacters;\r\n            }\r\n            adjustOffset = numberOfInsertedCharacters > 0;\r\n            // brackets and type\r\n            switch (kind) {\r\n                case json.SyntaxKind.OpenBraceToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_OBJECT;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.CloseBraceToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_OBJECT;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.OpenBracketToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_ARRAY;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.CloseBracketToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_ARRAY;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.ColonToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_COLON;\r\n                    lastWasColon = true;\r\n                    break;\r\n                case json.SyntaxKind.CommaToken:\r\n                    type = jsonTokenTypes.TOKEN_DELIM_COMMA;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.TrueKeyword:\r\n                case json.SyntaxKind.FalseKeyword:\r\n                    type = jsonTokenTypes.TOKEN_VALUE_BOOLEAN;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.NullKeyword:\r\n                    type = jsonTokenTypes.TOKEN_VALUE_NULL;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.StringLiteral:\r\n                    type = lastWasColon ? jsonTokenTypes.TOKEN_VALUE_STRING : jsonTokenTypes.TOKEN_PROPERTY_NAME;\r\n                    lastWasColon = false;\r\n                    break;\r\n                case json.SyntaxKind.NumericLiteral:\r\n                    type = jsonTokenTypes.TOKEN_VALUE_NUMBER;\r\n                    lastWasColon = false;\r\n                    break;\r\n            }\r\n            // comments, iff enabled\r\n            if (comments) {\r\n                switch (kind) {\r\n                    case json.SyntaxKind.LineCommentTrivia:\r\n                        type = jsonTokenTypes.TOKEN_COMMENT_LINE;\r\n                        break;\r\n                    case json.SyntaxKind.BlockCommentTrivia:\r\n                        type = jsonTokenTypes.TOKEN_COMMENT_BLOCK;\r\n                        break;\r\n                }\r\n            }\r\n            ret.endState = new JSONState(state.getMode(), state.getStateData(), scanner.getTokenError(), lastWasColon);\r\n            ret.tokens.push({\r\n                startIndex: offset,\r\n                type: type\r\n            });\r\n        }\r\n        return ret;\r\n    }\r\n});\r\n\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n};\r\ndefine(\"vs/languages/json/common/json\", [\"require\", \"exports\", 'vs/editor/common/modes', 'vs/platform/platform', 'vs/languages/json/common/features/tokenization', 'vs/editor/common/modes/abstractMode', 'vs/platform/thread/common/threadService', 'vs/platform/thread/common/thread', 'vs/platform/jsonschemas/common/jsonContributionRegistry', 'vs/platform/instantiation/common/instantiation', 'vs/editor/common/modes/supports/richEditSupport', 'vs/base/common/async'], function (require, exports, modes, Platform, tokenization, abstractMode_1, threadService_1, thread_1, jsonContributionRegistry_1, instantiation_1, richEditSupport_1, async_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var JSONMode = (function (_super) {\r\n        __extends(JSONMode, _super);\r\n        function JSONMode(descriptor, instantiationService, threadService) {\r\n            var _this = this;\r\n            _super.call(this, descriptor.id);\r\n            this._modeWorkerManager = new abstractMode_1.ModeWorkerManager(descriptor, 'vs/languages/json/common/jsonWorker', 'JSONWorker', null, instantiationService);\r\n            this._threadService = threadService;\r\n            this.tokenizationSupport = tokenization.createTokenizationSupport(this, true);\r\n            this.richEditSupport = new richEditSupport_1.RichEditSupport(this.getId(), null, {\r\n                wordPattern: abstractMode_1.createWordRegExp('.-'),\r\n                comments: {\r\n                    lineComment: '//',\r\n                    blockComment: ['/*', '*/']\r\n                },\r\n                brackets: [\r\n                    ['{', '}'],\r\n                    ['[', ']']\r\n                ],\r\n                autoClosingPairs: [\r\n                    { open: '{', close: '}', notIn: ['string'] },\r\n                    { open: '[', close: ']', notIn: ['string'] },\r\n                    { open: '\"', close: '\"', notIn: ['string'] }\r\n                ]\r\n            });\r\n            modes.HoverProviderRegistry.register(this.getId(), {\r\n                provideHover: function (model, position, token) {\r\n                    return async_1.wireCancellationToken(token, _this._provideHover(model.uri, position));\r\n                }\r\n            }, true);\r\n            this.inplaceReplaceSupport = this;\r\n            this.configSupport = this;\r\n            // Initialize Outline support\r\n            modes.DocumentSymbolProviderRegistry.register(this.getId(), {\r\n                provideDocumentSymbols: function (model, token) {\r\n                    return async_1.wireCancellationToken(token, _this._provideDocumentSymbols(model.uri));\r\n                }\r\n            }, true);\r\n            modes.DocumentFormattingEditProviderRegistry.register(this.getId(), {\r\n                provideDocumentFormattingEdits: function (model, options, token) {\r\n                    return async_1.wireCancellationToken(token, _this._provideDocumentFormattingEdits(model.uri, options));\r\n                }\r\n            }, true);\r\n            modes.DocumentRangeFormattingEditProviderRegistry.register(this.getId(), {\r\n                provideDocumentRangeFormattingEdits: function (model, range, options, token) {\r\n                    return async_1.wireCancellationToken(token, _this._provideDocumentRangeFormattingEdits(model.uri, range, options));\r\n                }\r\n            }, true);\r\n            modes.SuggestRegistry.register(this.getId(), {\r\n                triggerCharacters: [],\r\n                shouldAutotriggerSuggest: true,\r\n                provideCompletionItems: function (model, position, token) {\r\n                    return async_1.wireCancellationToken(token, _this._provideCompletionItems(model.uri, position));\r\n                }\r\n            }, true);\r\n        }\r\n        JSONMode.prototype.creationDone = function () {\r\n            var _this = this;\r\n            if (this._threadService.isInMainThread) {\r\n                // Pick a worker to do validation\r\n                this._pickAWorkerToValidate();\r\n                // Configure all workers\r\n                this._configureWorkerSchemas(this.getSchemaConfiguration());\r\n                var contributionRegistry = Platform.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\r\n                contributionRegistry.addRegistryChangedListener(function (e) {\r\n                    _this._configureWorkerSchemas(_this.getSchemaConfiguration());\r\n                });\r\n            }\r\n        };\r\n        JSONMode.prototype._worker = function (runner) {\r\n            return this._modeWorkerManager.worker(runner);\r\n        };\r\n        JSONMode.prototype.getSchemaConfiguration = function () {\r\n            var contributionRegistry = Platform.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);\r\n            return contributionRegistry.getSchemaContributions();\r\n        };\r\n        JSONMode.prototype.configure = function (options) {\r\n            if (this._threadService.isInMainThread) {\r\n                return this._configureWorkers(options);\r\n            }\r\n            else {\r\n                return this._worker(function (w) { return w._doConfigure(options); });\r\n            }\r\n        };\r\n        JSONMode.prototype._configureWorkers = function (options) {\r\n            return this._worker(function (w) { return w._doConfigure(options); });\r\n        };\r\n        JSONMode.prototype._configureWorkerSchemas = function (data) {\r\n            return this._worker(function (w) { return w.setSchemaContributions(data); });\r\n        };\r\n        JSONMode.prototype._pickAWorkerToValidate = function () {\r\n            return this._worker(function (w) { return w.enableValidator(); });\r\n        };\r\n        JSONMode.prototype.navigateValueSet = function (resource, position, up) {\r\n            return this._worker(function (w) { return w.navigateValueSet(resource, position, up); });\r\n        };\r\n        JSONMode.prototype._provideCompletionItems = function (resource, position) {\r\n            return this._worker(function (w) { return w.provideCompletionItems(resource, position); });\r\n        };\r\n        JSONMode.prototype._provideHover = function (resource, position) {\r\n            return this._worker(function (w) { return w.provideHover(resource, position); });\r\n        };\r\n        JSONMode.prototype._provideDocumentSymbols = function (resource) {\r\n            return this._worker(function (w) { return w.provideDocumentSymbols(resource); });\r\n        };\r\n        JSONMode.prototype._provideDocumentFormattingEdits = function (resource, options) {\r\n            return this._worker(function (w) { return w.format(resource, null, options); });\r\n        };\r\n        JSONMode.prototype._provideDocumentRangeFormattingEdits = function (resource, range, options) {\r\n            return this._worker(function (w) { return w.format(resource, range, options); });\r\n        };\r\n        JSONMode.$_configureWorkers = threadService_1.AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkers);\r\n        JSONMode.$_configureWorkerSchemas = threadService_1.AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkerSchemas);\r\n        JSONMode.$_pickAWorkerToValidate = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._pickAWorkerToValidate, thread_1.ThreadAffinity.Group1);\r\n        JSONMode.$navigateValueSet = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype.navigateValueSet);\r\n        JSONMode.$_provideCompletionItems = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideCompletionItems);\r\n        JSONMode.$_provideHover = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideHover);\r\n        JSONMode.$_provideDocumentSymbols = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentSymbols);\r\n        JSONMode.$_provideDocumentFormattingEdits = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentFormattingEdits);\r\n        JSONMode.$_provideDocumentRangeFormattingEdits = threadService_1.OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentRangeFormattingEdits);\r\n        JSONMode = __decorate([\r\n            __param(1, instantiation_1.IInstantiationService),\r\n            __param(2, thread_1.IThreadService)\r\n        ], JSONMode);\r\n        return JSONMode;\r\n    }(abstractMode_1.AbstractMode));\r\n    exports.JSONMode = JSONMode;\r\n});\r\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport const TOKEN_DELIM_OBJECT = 'punctuation.bracket.json';\nexport const TOKEN_DELIM_ARRAY = 'punctuation.array.json';\nexport const TOKEN_DELIM_COLON = 'punctuation.colon.json';\nexport const TOKEN_DELIM_COMMA = 'punctuation.comma.json';\nexport const TOKEN_VALUE_BOOLEAN= 'support.property-value.keyword.json';\nexport const TOKEN_VALUE_NULL= 'support.property-value.constant.other.json';\nexport const TOKEN_VALUE_STRING = 'support.property-value.string.value.json';\nexport const TOKEN_VALUE_NUMBER = 'support.property-value.constant.numeric.json';\nexport const TOKEN_PROPERTY_NAME = 'support.type.property-name.json';\nexport const TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport const TOKEN_COMMENT_LINE = 'comment.line.json';","define(\"vs/nls!vs/base/common/json\",['vs/nls', 'vs/nls!vs/languages/json/common/json'], function(nls, data) { return nls.create(\"vs/base/common/json\", data); });","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {localize} from 'vs/nls';\n\nexport enum ScanError {\n\tNone,\n\tUnexpectedEndOfComment,\n\tUnexpectedEndOfString,\n\tUnexpectedEndOfNumber,\n\tInvalidUnicode,\n\tInvalidEscapeCharacter\n}\n\nexport enum SyntaxKind {\n\tUnknown = 0,\n\tOpenBraceToken,\n\tCloseBraceToken,\n\tOpenBracketToken,\n\tCloseBracketToken,\n\tCommaToken,\n\tColonToken,\n\tNullKeyword,\n\tTrueKeyword,\n\tFalseKeyword,\n\tStringLiteral,\n\tNumericLiteral,\n\tLineCommentTrivia,\n\tBlockCommentTrivia,\n\tLineBreakTrivia,\n\tTrivia,\n\tEOF\n}\n\n/**\n * The scanner object, representing a JSON scanner at a position in the input string.\n */\nexport interface JSONScanner {\n\t/**\n\t * Sets the scan position to a new offset. A call to 'scan' is needed to get the first token.\n\t */\n\tsetPosition(pos: number);\n\t/**\n\t * Read the next token. Returns the tolen code.\n\t */\n\tscan(): SyntaxKind;\n\t/**\n\t * Returns the current scan position, which is after the last read token.\n\t */\n\tgetPosition(): number;\n\t/**\n\t * Returns the last read token.\n\t */\n\tgetToken(): SyntaxKind;\n\t/**\n\t * Returns the last read token value. The value for strings is the decoded string content. For numbers its of type number, for boolean it's true or false.\n\t */\n\tgetTokenValue(): string;\n\t/**\n\t * The start offset of the last read token.\n\t */\n\tgetTokenOffset(): number;\n\t/**\n\t * The length of the last read token.\n\t */\n\tgetTokenLength(): number;\n\t/**\n\t * An error code of the last scan.\n\t */\n\tgetTokenError(): ScanError;\n}\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\nexport function createScanner(text:string, ignoreTrivia:boolean = false):JSONScanner {\n\n\tlet pos = 0,\n\t\tlen = text.length,\n\t\tvalue:string = '',\n\t\ttokenOffset = 0,\n\t\ttoken:SyntaxKind = SyntaxKind.Unknown,\n\t\tscanError:ScanError = ScanError.None;\n\n\tfunction scanHexDigits(count: number, exact?: boolean): number {\n\t\tlet digits = 0;\n\t\tlet value = 0;\n\t\twhile (digits < count || !exact) {\n\t\t\tlet ch = text.charCodeAt(pos);\n\t\t\tif (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes._0;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.A + 10;\n\t\t\t}\n\t\t\telse if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {\n\t\t\t\tvalue = value * 16 + ch - CharacterCodes.a + 10;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t\tdigits++;\n\t\t}\n\t\tif (digits < count) {\n\t\t\tvalue = -1;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction setPosition(newPosition: number) {\n\t\tpos = newPosition;\n\t\tvalue = '';\n\t\ttokenOffset = 0;\n\t\ttoken = SyntaxKind.Unknown;\n\t\tscanError = ScanError.None;\n\t}\n\n\tfunction scanNumber(): string {\n\t\tlet start = pos;\n\t\tif (text.charCodeAt(pos) === CharacterCodes._0) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t}\n\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t\treturn text.substring(start, pos);\n\t\t\t}\n\t\t}\n\t\tlet end = pos;\n\t\tif (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {\n\t\t\tpos++;\n\t\t\tif (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\tpos++;\n\t\t\t\twhile (pos < text.length && isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\t\t\t\tend = pos;\n\t\t\t} else {\n\t\t\t\tscanError = ScanError.UnexpectedEndOfNumber;\n\t\t\t}\n\t\t}\n\t\treturn text.substring(start, end);\n\t}\n\n\tfunction scanString(): string {\n\n\t\tlet result = '',\n\t\t\tstart = pos;\n\n\t\twhile (true) {\n\t\t\tif (pos >= len) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet ch = text.charCodeAt(pos);\n\t\t\tif (ch === CharacterCodes.doubleQuote) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch === CharacterCodes.backslash) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tpos++;\n\t\t\t\tif (pos >= len) {\n\t\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tch = text.charCodeAt(pos++);\n\t\t\t\tswitch (ch) {\n\t\t\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\t\t\tresult += '\\\"';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.backslash:\n\t\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.slash:\n\t\t\t\t\t\tresult += '/';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.b:\n\t\t\t\t\t\tresult += '\\b';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.f:\n\t\t\t\t\t\tresult += '\\f';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.n:\n\t\t\t\t\t\tresult += '\\n';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.r:\n\t\t\t\t\t\tresult += '\\r';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.t:\n\t\t\t\t\t\tresult += '\\t';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CharacterCodes.u:\n\t\t\t\t\t\tlet ch = scanHexDigits(4, true);\n\t\t\t\t\t\tif (ch >= 0) {\n\t\t\t\t\t\t\tresult += String.fromCharCode(ch);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tscanError = ScanError.InvalidUnicode;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tscanError = ScanError.InvalidEscapeCharacter;\n\t\t\t\t}\n\t\t\t\tstart = pos;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isLineBreak(ch)) {\n\t\t\t\tresult += text.substring(start, pos);\n\t\t\t\tscanError = ScanError.UnexpectedEndOfString;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction scanNext():SyntaxKind {\n\n\t\tvalue = '';\n\t\tscanError = ScanError.None;\n\n\t\ttokenOffset = pos;\n\n\t\tif(pos >= len) {\n\t\t\t// at the end\n\t\t\ttokenOffset = len;\n\t\t\treturn token = SyntaxKind.EOF;\n\t\t}\n\n\t\tlet code = text.charCodeAt(pos);\n\t\t// trivia: whitespace\n\t\tif (isWhiteSpace(code)) {\n\t\t\tdo {\n\t\t\t\tpos++;\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t} while (isWhiteSpace(code));\n\n\t\t\treturn token = SyntaxKind.Trivia;\n\t\t}\n\n\t\t// trivia: newlines\n\t\tif (isLineBreak(code)) {\n\t\t\tpos++;\n\t\t\tvalue += String.fromCharCode(code);\n\t\t\tif (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {\n\t\t\t\tpos++;\n\t\t\t\tvalue += '\\n';\n\t\t\t}\n\t\t\treturn token = SyntaxKind.LineBreakTrivia;\n\t\t}\n\n\t\tswitch(code) {\n\t\t\t// tokens: []{}:,\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBraceToken;\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBraceToken;\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.OpenBracketToken;\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CloseBracketToken;\n\t\t\tcase CharacterCodes.colon:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.ColonToken;\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.CommaToken;\n\n\t\t\t// strings\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\t\tpos++;\n\t\t\t\tvalue = scanString();\n\t\t\t\treturn token = SyntaxKind.StringLiteral;\n\n\t\t\t// comments\n\t\t\tcase CharacterCodes.slash:\n\t\t\t\tlet start = pos - 1;\n\t\t\t\t// Single-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\twhile (pos < len) {\n\t\t\t\t\t\tif (isLineBreak(text.charCodeAt(pos))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\n\t\t\t\t\t}\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.LineCommentTrivia;\n\t\t\t\t}\n\n\t\t\t\t// Multi-line comment\n\t\t\t\tif (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {\n\t\t\t\t\tpos += 2;\n\n\t\t\t\t\tlet safeLength = len - 1; // For lookahead.\n\t\t\t\t\tlet commentClosed = false;\n\t\t\t\t\twhile (pos < safeLength) {\n\t\t\t\t\t\tlet ch = text.charCodeAt(pos);\n\n\t\t\t\t\t\tif (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {\n\t\t\t\t\t\t\tpos += 2;\n\t\t\t\t\t\t\tcommentClosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!commentClosed) {\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\tscanError = ScanError.UnexpectedEndOfComment;\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = text.substring(start, pos);\n\t\t\t\t\treturn token = SyntaxKind.BlockCommentTrivia;\n\t\t\t\t}\n\t\t\t\t// just a single slash\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\n\t\t\t// numbers\n\t\t\tcase CharacterCodes.minus:\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\tif (pos === len || !isDigit(text.charCodeAt(pos))) {\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// found a minus, followed by a number so\n\t\t\t\t// we fall through to proceed with scanning\n\t\t\t\t// numbers\n\t\t\tcase CharacterCodes._0:\n\t\t\tcase CharacterCodes._1:\n\t\t\tcase CharacterCodes._2:\n\t\t\tcase CharacterCodes._3:\n\t\t\tcase CharacterCodes._4:\n\t\t\tcase CharacterCodes._5:\n\t\t\tcase CharacterCodes._6:\n\t\t\tcase CharacterCodes._7:\n\t\t\tcase CharacterCodes._8:\n\t\t\tcase CharacterCodes._9:\n\t\t\t\tvalue += scanNumber();\n\t\t\t\treturn token = SyntaxKind.NumericLiteral;\n\t\t\t// literals and unknown symbols\n\t\t\tdefault:\n\t\t\t\t// is a literal? Read the full word.\n\t\t\t\twhile (pos < len && isUnknownContentCharacter(code)) {\n\t\t\t\t\tpos++;\n\t\t\t\t\tcode = text.charCodeAt(pos);\n\t\t\t\t}\n\t\t\t\tif (tokenOffset !== pos) {\n\t\t\t\t\tvalue = text.substring(tokenOffset, pos);\n\t\t\t\t\t// keywords: true, false, null\n\t\t\t\t\tswitch (value) {\n\t\t\t\t\t\tcase 'true': return token = SyntaxKind.TrueKeyword;\n\t\t\t\t\t\tcase 'false': return token = SyntaxKind.FalseKeyword;\n\t\t\t\t\t\tcase 'null': return token = SyntaxKind.NullKeyword;\n\t\t\t\t\t}\n\t\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t\t\t}\n\t\t\t\t// some\n\t\t\t\tvalue += String.fromCharCode(code);\n\t\t\t\tpos++;\n\t\t\t\treturn token = SyntaxKind.Unknown;\n\t\t}\n\t}\n\n\tfunction isUnknownContentCharacter(code: CharacterCodes) {\n\t\tif (isWhiteSpace(code) || isLineBreak(code)) {\n\t\t\treturn false;\n\t\t}\n\t\tswitch (code) {\n\t\t\tcase CharacterCodes.closeBrace:\n\t\t\tcase CharacterCodes.closeBracket:\n\t\t\tcase CharacterCodes.openBrace:\n\t\t\tcase CharacterCodes.openBracket:\n\t\t\tcase CharacterCodes.doubleQuote:\n\t\t\tcase CharacterCodes.colon:\n\t\t\tcase CharacterCodes.comma:\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\n\tfunction scanNextNonTrivia():SyntaxKind {\n\t\tlet result : SyntaxKind;\n\t\tdo {\n\t\t\tresult = scanNext();\n\t\t} while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);\n\t\treturn result;\n\t}\n\n\treturn {\n\t\tsetPosition: setPosition,\n\t\tgetPosition: () => pos,\n\t\tscan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n\t\tgetToken: () => token,\n\t\tgetTokenValue: () => value,\n\t\tgetTokenOffset: () => tokenOffset,\n\t\tgetTokenLength: () => pos - tokenOffset,\n\t\tgetTokenError: () => scanError\n\t};\n}\n\nfunction isWhiteSpace(ch: number): boolean {\n\treturn ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||\n\t\tch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||\n\t\tch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;\n}\n\nfunction isLineBreak(ch: number): boolean {\n\treturn ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;\n}\n\nfunction isDigit(ch: number): boolean {\n\treturn ch >= CharacterCodes._0 && ch <= CharacterCodes._9;\n}\n\nenum CharacterCodes {\n\tnullCharacter = 0,\n\tmaxAsciiCharacter = 0x7F,\n\n\tlineFeed = 0x0A,              // \\n\n\tcarriageReturn = 0x0D,        // \\r\n\tlineSeparator = 0x2028,\n\tparagraphSeparator = 0x2029,\n\n\t// REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems\n\t// like an odd disparity?  (Or maybe it's completely fine for them to be different).\n\tnextLine = 0x0085,\n\n\t// Unicode 3.0 space characters\n\tspace = 0x0020,   // \" \"\n\tnonBreakingSpace = 0x00A0,   //\n\tenQuad = 0x2000,\n\temQuad = 0x2001,\n\tenSpace = 0x2002,\n\temSpace = 0x2003,\n\tthreePerEmSpace = 0x2004,\n\tfourPerEmSpace = 0x2005,\n\tsixPerEmSpace = 0x2006,\n\tfigureSpace = 0x2007,\n\tpunctuationSpace = 0x2008,\n\tthinSpace = 0x2009,\n\thairSpace = 0x200A,\n\tzeroWidthSpace = 0x200B,\n\tnarrowNoBreakSpace = 0x202F,\n\tideographicSpace = 0x3000,\n\tmathematicalSpace = 0x205F,\n\togham = 0x1680,\n\n\t_ = 0x5F,\n\t$ = 0x24,\n\n\t_0 = 0x30,\n\t_1 = 0x31,\n\t_2 = 0x32,\n\t_3 = 0x33,\n\t_4 = 0x34,\n\t_5 = 0x35,\n\t_6 = 0x36,\n\t_7 = 0x37,\n\t_8 = 0x38,\n\t_9 = 0x39,\n\n\ta = 0x61,\n\tb = 0x62,\n\tc = 0x63,\n\td = 0x64,\n\te = 0x65,\n\tf = 0x66,\n\tg = 0x67,\n\th = 0x68,\n\ti = 0x69,\n\tj = 0x6A,\n\tk = 0x6B,\n\tl = 0x6C,\n\tm = 0x6D,\n\tn = 0x6E,\n\to = 0x6F,\n\tp = 0x70,\n\tq = 0x71,\n\tr = 0x72,\n\ts = 0x73,\n\tt = 0x74,\n\tu = 0x75,\n\tv = 0x76,\n\tw = 0x77,\n\tx = 0x78,\n\ty = 0x79,\n\tz = 0x7A,\n\n\tA = 0x41,\n\tB = 0x42,\n\tC = 0x43,\n\tD = 0x44,\n\tE = 0x45,\n\tF = 0x46,\n\tG = 0x47,\n\tH = 0x48,\n\tI = 0x49,\n\tJ = 0x4A,\n\tK = 0x4B,\n\tL = 0x4C,\n\tM = 0x4D,\n\tN = 0x4E,\n\tO = 0x4F,\n\tP = 0x50,\n\tQ = 0x51,\n\tR = 0x52,\n\tS = 0x53,\n\tT = 0x54,\n\tU = 0x55,\n\tV = 0x56,\n\tW = 0x57,\n\tX = 0x58,\n\tY = 0x59,\n\tZ = 0x5a,\n\n\tampersand = 0x26,             // &\n\tasterisk = 0x2A,              // *\n\tat = 0x40,                    // @\n\tbackslash = 0x5C,             // \\\n\tbar = 0x7C,                   // |\n\tcaret = 0x5E,                 // ^\n\tcloseBrace = 0x7D,            // }\n\tcloseBracket = 0x5D,          // ]\n\tcloseParen = 0x29,            // )\n\tcolon = 0x3A,                 // :\n\tcomma = 0x2C,                 // ,\n\tdot = 0x2E,                   // .\n\tdoubleQuote = 0x22,           // \"\n\tequals = 0x3D,                // =\n\texclamation = 0x21,           // !\n\tgreaterThan = 0x3E,           // >\n\tlessThan = 0x3C,              // <\n\tminus = 0x2D,                 // -\n\topenBrace = 0x7B,             // {\n\topenBracket = 0x5B,           // [\n\topenParen = 0x28,             // (\n\tpercent = 0x25,               // %\n\tplus = 0x2B,                  // +\n\tquestion = 0x3F,              // ?\n\tsemicolon = 0x3B,             // ;\n\tsingleQuote = 0x27,           // '\n\tslash = 0x2F,                 // /\n\ttilde = 0x7E,                 // ~\n\n\tbackspace = 0x08,             // \\b\n\tformFeed = 0x0C,              // \\f\n\tbyteOrderMark = 0xFEFF,\n\ttab = 0x09,                   // \\t\n\tverticalTab = 0x0B,           // \\v\n}\n\n\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\nexport function stripComments(text:string, replaceCh?:string):string {\n\n\tlet _scanner = createScanner(text),\n\t\tparts: string[] = [],\n\t\tkind:SyntaxKind,\n\t\toffset = 0,\n\t\tpos:number;\n\n\tdo {\n\t\tpos = _scanner.getPosition();\n\t\tkind = _scanner.scan();\n\t\tswitch (kind) {\n\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\tcase SyntaxKind.EOF:\n\t\t\t\tif(offset !== pos) {\n\t\t\t\t\tparts.push(text.substring(offset, pos));\n\t\t\t\t}\n\t\t\t\tif(replaceCh !== void 0) {\n\t\t\t\t\tparts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n\t\t\t\t}\n\t\t\t\toffset = _scanner.getPosition();\n\t\t\t\tbreak;\n\t\t}\n\t} while(kind !== SyntaxKind.EOF);\n\n\treturn parts.join('');\n}\n\nexport interface ParseError {\n\terror: ParseErrorCode;\n}\n\nexport enum ParseErrorCode {\n\tInvalidSymbol,\n\tInvalidNumberFormat,\n\tPropertyNameExpected,\n\tValueExpected,\n\tColonExpected,\n\tCommaExpected,\n\tCloseBraceExpected,\n\tCloseBracketExpected,\n\tEndOfFileExpected\n}\n\nexport function getParseErrorMessage(errorCode: ParseErrorCode) : string {\n\tswitch (errorCode) {\n\t\tcase ParseErrorCode.InvalidSymbol: return localize('error.invalidSymbol', 'Invalid symbol');\n\t\tcase ParseErrorCode.InvalidNumberFormat: return localize('error.invalidNumberFormat', 'Invalid number format');\n\t\tcase ParseErrorCode.PropertyNameExpected: return localize('error.propertyNameExpected', 'Property name expected');\n\t\tcase ParseErrorCode.ValueExpected: return localize('error.valueExpected', 'Value expected');\n\t\tcase ParseErrorCode.ColonExpected: return localize('error.colonExpected', 'Colon expected');\n\t\tcase ParseErrorCode.CommaExpected: return localize('error.commaExpected', 'Comma expected');\n\t\tcase ParseErrorCode.CloseBraceExpected: return localize('error.closeBraceExpected', 'Closing brace expected');\n\t\tcase ParseErrorCode.CloseBracketExpected: return localize('error.closeBracketExpected', 'Closing bracket expected');\n\t\tcase ParseErrorCode.EndOfFileExpected: return localize('error.endOfFileExpected', 'End of file expected');\n\t\tdefault:\n\t\t\treturn '';\n\t}\n}\n\nexport type NodeType = \"object\" | \"array\" | \"property\" | \"string\" | \"number\" | \"boolean\" | \"null\";\n\nfunction getLiteralNodeType(value: any) : NodeType {\n\tswitch (typeof value) {\n\t\tcase 'boolean': return 'boolean';\n\t\tcase 'number': return 'number';\n\t\tcase 'string': return 'string';\n\t\tdefault: return 'null';\n\t}\n}\n\nexport interface Node {\n\ttype: NodeType;\n\tvalue?: any;\n\toffset: number;\n\tlength: number;\n\tcolumnOffset?: number;\n\tparent?: Node;\n\tchildren?: Node[];\n}\n\nexport type Segment = string | number;\nexport type JSONPath = Segment[];\n\nexport interface Location {\n\t/**\n\t * The previous property key or literal value (string, number, boolean or null) or undefined.\n\t */\n\tpreviousNode?: Node;\n\t/**\n\t * The path describing the location in the JSON document. The path consists of a sequence strings\n\t * representing an object property or numbers for array indices.\n\t */\n\tpath: JSONPath;\n\t/**\n\t * Matches the locations path against a pattern consisting of strings (for properties) and numbers (for array indices).\n\t * '*' will match a single segment, of any property name or index.\n\t * '**' will match a sequece of segments or no segment, of any property name or index.\n\t */\n\tmatches: (patterns: JSONPath) => boolean;\n\t/**\n\t * If set, the location's offset is at a property key.\n\t */\n\tisAtPropertyKey: boolean;\n}\n\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text:string, position: number) : Location {\n\tlet segments: any[] = []; // strings or numbers\n\tlet earlyReturnException = new Object();\n\tlet previousNode : Node = void 0;\n\tconst previousNodeInst : Node = {\n\t\tvalue: void 0,\n\t\toffset: void 0,\n\t\tlength: void 0,\n\t\ttype: void 0\n\t};\n\tlet isAtPropertyKey = false;\n\tfunction setPreviousNode(value: string, offset: number, length: number, type: NodeType) {\n\t\tpreviousNodeInst.value = value;\n\t\tpreviousNodeInst.offset = offset;\n\t\tpreviousNodeInst.length = length;\n\t\tpreviousNodeInst.type = type;\n\t\tpreviousNodeInst.columnOffset = void 0;\n\t\tpreviousNode = previousNodeInst;\n\t}\n\ttry {\n\n\t\tvisit(text, {\n\t\t\tonObjectBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tisAtPropertyKey = position > offset;\n\t\t\t\tsegments.push(''); // push a placeholder (will be replaced or removed)\n\t\t\t},\n\t\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(name, offset, length, 'property');\n\t\t\t\tsegments[segments.length - 1] = name;\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.push(0);\n\t\t\t},\n\t\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tpreviousNode = void 0;\n\t\t\t\tsegments.pop();\n\t\t\t},\n\t\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\t\tif (position < offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tsetPreviousNode(value, offset, length, getLiteralNodeType(value));\n\n\t\t\t\tif (position <= offset + length) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t},\n\t\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\t\tif (position <= offset) {\n\t\t\t\t\tthrow earlyReturnException;\n\t\t\t\t}\n\t\t\t\tif (sep === ':' && previousNode.type === 'property') {\n\t\t\t\t\tpreviousNode.columnOffset = offset;\n\t\t\t\t\tisAtPropertyKey = false;\n\t\t\t\t\tpreviousNode = void 0;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tlet last = segments[segments.length - 1];\n\t\t\t\t\tif (typeof last === 'number') {\n\t\t\t\t\t\tsegments[segments.length - 1] = last + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tisAtPropertyKey = true;\n\t\t\t\t\t\tsegments[segments.length - 1] = '';\n\t\t\t\t\t}\n\t\t\t\t\tpreviousNode = void 0;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t} catch (e) {\n\t\tif (e !== earlyReturnException) {\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\tif (segments[segments.length - 1] === '') {\n\t\tsegments.pop();\n\t}\n\treturn {\n\t\tpath: segments,\n\t\tpreviousNode,\n\t\tisAtPropertyKey,\n\t\tmatches: (pattern: string[]) => {\n\t\t\tlet k = 0;\n\t\t\tfor (let i = 0; k < pattern.length && i < segments.length; i++) {\n\t\t\t\tif (pattern[k] === segments[i] || pattern[k] === '*') {\n\t\t\t\t\tk++;\n\t\t\t\t} else if (pattern[k] !== '**') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn k === pattern.length;\n\t\t}\n\t};\n}\n\nexport interface ParseOptions {\n\tdisallowComments?: boolean;\n}\n\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\nexport function parse(text:string, errors: ParseError[] = [], options?: ParseOptions) : any {\n\tlet currentProperty : string = null;\n\tlet currentParent : any = [];\n\tlet previousParents : any[] = [];\n\n\tfunction onValue(value: any) {\n\t\tif (Array.isArray(currentParent)) {\n\t\t\t(<any[]> currentParent).push(value);\n\t\t} else if (currentProperty) {\n\t\t\tcurrentParent[currentProperty] = value;\n\t\t}\n\t}\n\n\tlet visitor : JSONVisitor = {\n\t\tonObjectBegin: () => {\n\t\t\tlet object = {};\n\t\t\tonValue(object);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = object;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonObjectProperty: (name: string) => {\n\t\t\tcurrentProperty = name;\n\t\t},\n\t\tonObjectEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonArrayBegin: () => {\n\t\t\tlet array = [];\n\t\t\tonValue(array);\n\t\t\tpreviousParents.push(currentParent);\n\t\t\tcurrentParent = array;\n\t\t\tcurrentProperty = null;\n\t\t},\n\t\tonArrayEnd: () => {\n\t\t\tcurrentParent = previousParents.pop();\n\t\t},\n\t\tonLiteralValue: onValue,\n\t\tonError:(error:ParseErrorCode) => {\n\t\t\terrors.push({error: error});\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\treturn currentParent[0];\n}\n\n\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\nexport function parseTree(text:string, errors: ParseError[] = [], options?: ParseOptions) : Node {\n\tlet currentParent : Node = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root\n\n\tfunction ensurePropertyComplete(endOffset:number) {\n\t\tif (currentParent.type === 'property') {\n\t\t\tcurrentParent.length = endOffset - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t}\n\t}\n\n\tfunction onValue(valueNode: Node) : Node {\n\t\tcurrentParent.children.push(valueNode);\n\t\tensurePropertyComplete(valueNode.offset + valueNode.length);\n\t\treturn valueNode;\n\t}\n\n\tlet visitor : JSONVisitor = {\n\t\tonObjectBegin: (offset: number) => {\n\t\t\tcurrentParent = onValue({ type: 'object', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonObjectProperty: (name: string, offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'property', offset, length: -1, parent: currentParent, children: [] });\n\t\t\tcurrentParent.children.push({ type: 'string', value: name, offset, length, parent: currentParent});\n\t\t},\n\t\tonObjectEnd: (offset: number, length: number) => {\n\t\t\tensurePropertyComplete(offset);\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t},\n\t\tonArrayBegin: (offset: number, length: number) => {\n\t\t\tcurrentParent = onValue({ type: 'array', offset, length: -1, parent: currentParent, children: [] });\n\t\t},\n\t\tonArrayEnd: (offset: number, length: number) => {\n\t\t\tcurrentParent.length = offset + length - currentParent.offset;\n\t\t\tcurrentParent = currentParent.parent;\n\t\t},\n\t\tonLiteralValue: (value: any, offset: number, length: number) => {\n\t\t\tonValue({ type: getLiteralNodeType(value), offset, length, parent: currentParent, value });\n\t\t},\n\t\tonSeparator: (sep: string, offset: number, length: number) => {\n\t\t\tif (currentParent.type === 'property') {\n\t\t\t\tif (sep === ':') {\n\t\t\t\t\tcurrentParent.columnOffset = offset;\n\t\t\t\t} else if (sep === ',') {\n\t\t\t\t\tensurePropertyComplete(offset);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tonError:(error:ParseErrorCode) => {\n\t\t\terrors.push({error: error});\n\t\t}\n\t};\n\tvisit(text, visitor, options);\n\n\tlet result = currentParent.children[0];\n\tif (result) {\n\t\tdelete result.parent;\n\t}\n\treturn result;\n}\n\nexport function findNodeAtLocation(root: Node, path: JSONPath) : Node {\n\tif (!root) {\n\t\treturn void 0;\n\t}\n\tlet node = root;\n\tfor (let segment of path) {\n\t\tif (typeof segment === 'string') {\n\t\t\tif (node.type !== 'object') {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\tlet found = false;\n\t\t\tfor (let propertyNode of node.children) {\n\t\t\t\tif (propertyNode.children[0].value === segment) {\n\t\t\t\t\tnode = propertyNode.children[1];\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t} else {\n\t\t\tlet index = <number> segment;\n\t\t\tif (node.type !== 'array' || index < 0 || index >= node.children.length) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\tnode = node.children[index];\n\t\t}\n\t}\n\treturn node;\n}\n\nexport function getNodeValue(node: Node) : any {\n\tif (node.type === 'array') {\n\t\treturn node.children.map(getNodeValue);\n\t} else if (node.type === 'object') {\n\t\tlet obj = {};\n\t\tfor (let prop of node.children) {\n\t\t\tobj[prop.children[0].value] = getNodeValue(prop.children[1]);\n\t\t}\n\t\treturn obj;\n\t}\n\treturn node.value;\n}\n\n\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\nexport function visit(text:string, visitor: JSONVisitor, options?: ParseOptions) : any {\n\n\tlet _scanner = createScanner(text, false);\n\n\tfunction toNoArgVisit(visitFunction: (offset: number, length: number) => void) : () => void {\n\t\treturn visitFunction ? () => visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\tfunction toOneArgVisit<T>(visitFunction: (arg: T, offset: number, length: number) => void) : (arg: T) => void {\n\t\treturn visitFunction ? (arg: T) => visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()) : () => true;\n\t}\n\n\tlet onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n\t\tonObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n\t\tonObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n\t\tonArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n\t\tonArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n\t\tonLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n\t\tonSeparator = toOneArgVisit(visitor.onSeparator),\n\t\tonError = toOneArgVisit(visitor.onError);\n\n\tlet disallowComments = options && options.disallowComments;\n\tfunction scanNext() : SyntaxKind {\n\t\twhile (true) {\n\t\t\tlet token = _scanner.scan();\n\t\t\tswitch (token) {\n\t\t\t\tcase SyntaxKind.LineCommentTrivia:\n\t\t\t\tcase SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\tif (disallowComments) {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Unknown:\n\t\t\t\t\thandleError(ParseErrorCode.InvalidSymbol);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.Trivia:\n\t\t\t\tcase SyntaxKind.LineBreakTrivia:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn token;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleError(error:ParseErrorCode, skipUntilAfter: SyntaxKind[] = [], skipUntil: SyntaxKind[] = []) : void {\n\t\tonError(error);\n\t\tif (skipUntilAfter.length + skipUntil.length > 0) {\n\t\t\tlet token = _scanner.getToken();\n\t\t\twhile (token !== SyntaxKind.EOF) {\n\t\t\t\tif (skipUntilAfter.indexOf(token) !== -1) {\n\t\t\t\t\tscanNext();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (skipUntil.indexOf(token) !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttoken = scanNext();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(isValue: boolean) : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.StringLiteral) {\n\t\t\treturn false;\n\t\t}\n\t\tlet value = _scanner.getTokenValue();\n\t\tif (isValue) {\n\t\t\tonLiteralValue(value);\n\t\t} else {\n\t\t\tonObjectProperty(value);\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseLiteral() : boolean {\n\t\tswitch (_scanner.getToken()) {\n\t\t\tcase SyntaxKind.NumericLiteral:\n\t\t\t\tlet value = 0;\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(_scanner.getTokenValue());\n\t\t\t\t\tif (typeof value !== 'number') {\n\t\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t\t\tvalue = 0;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(ParseErrorCode.InvalidNumberFormat);\n\t\t\t\t}\n\t\t\t\tonLiteralValue(value);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.NullKeyword:\n\t\t\t\tonLiteralValue(null);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.TrueKeyword:\n\t\t\t\tonLiteralValue(true);\n\t\t\t\tbreak;\n\t\t\tcase SyntaxKind.FalseKeyword:\n\t\t\t\tonLiteralValue(false);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t\tscanNext();\n\t\treturn true;\n\t}\n\n\tfunction parseProperty() : boolean {\n\t\tif (!parseString(false)) {\n\t\t\thandleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\treturn false;\n\t\t}\n\t\tif (_scanner.getToken() === SyntaxKind.ColonToken) {\n\t\t\tonSeparator(':');\n\t\t\tscanNext(); // consume colon\n\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t} else {\n\t\t\thandleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseObject() : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {\n\t\t\treturn false;\n\t\t}\n\t\tonObjectBegin();\n\t\tscanNext(); // consume open brace\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [] );\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], [] );\n\t\t\t}\n\t\t\tif (!parseProperty()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonObjectEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {\n\t\t\thandleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close brace\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseArray() : boolean {\n\t\tif (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {\n\t\t\treturn false;\n\t\t}\n\t\tonArrayBegin();\n\t\tscanNext(); // consume open bracket\n\n\t\tlet needsComma = false;\n\t\twhile (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {\n\t\t\tif (_scanner.getToken() === SyntaxKind.CommaToken) {\n\t\t\t\tif (!needsComma) {\n\t\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [] );\n\t\t\t\t}\n\t\t\t\tonSeparator(',');\n\t\t\t\tscanNext(); // consume comma\n\t\t\t} else if (needsComma) {\n\t\t\t\thandleError(ParseErrorCode.CommaExpected, [], [] );\n\t\t\t}\n\t\t\tif (!parseValue()) {\n\t\t\t\thandleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken] );\n\t\t\t}\n\t\t\tneedsComma = true;\n\t\t}\n\t\tonArrayEnd();\n\t\tif (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {\n\t\t\thandleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);\n\t\t} else {\n\t\t\tscanNext(); // consume close bracket\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction parseValue() : boolean {\n\t\treturn parseArray() || parseObject() || parseString(true) || parseLiteral();\n\t}\n\n\tscanNext();\n\tif (_scanner.getToken() === SyntaxKind.EOF) {\n\t\treturn true;\n\t}\n\tif (!parseValue()) {\n\t\thandleError(ParseErrorCode.ValueExpected, [], []);\n\t\treturn false;\n\t}\n\tif (_scanner.getToken() !== SyntaxKind.EOF) {\n\t\thandleError(ParseErrorCode.EndOfFileExpected, [], []);\n\t}\n\treturn true;\n}\n\nexport interface JSONVisitor {\n\t/**\n\t * Invoked when an open brace is encountered and an object is started. The offset and length represent the location of the open brace.\n\t */\n\tonObjectBegin?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a property is encountered. The offset and length represent the location of the property name.\n\t */\n\tonObjectProperty?: (property: string, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a closing brace is encountered and an object is completed. The offset and length represent the location of the closing brace.\n\t */\n\tonObjectEnd?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when an open bracket is encountered. The offset and length represent the location of the open bracket.\n\t */\n\tonArrayBegin?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a closing bracket is encountered. The offset and length represent the location of the closing bracket.\n\t */\n\tonArrayEnd?: (offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a literal value is encountered. The offset and length represent the location of the literal value.\n\t */\n\tonLiteralValue?: (value: any, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked when a comma or colon separator is encountered. The offset and length represent the location of the separator.\n\t */\n\tonSeparator?: (charcter: string, offset:number, length:number) => void;\n\n\t/**\n\t * Invoked on an error.\n\t */\n\tonError?: (error: ParseErrorCode, offset:number, length:number) => void;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport json = require('vs/base/common/json');\nimport Modes = require('vs/editor/common/modes');\nimport jsonTokenTypes = require('vs/languages/json/common/features/jsonTokenTypes');\n\nexport function createTokenizationSupport(mode:Modes.IMode, supportComments:boolean):Modes.ITokenizationSupport {\n\treturn {\n\t\tshouldGenerateEmbeddedModels: false,\n\t\tgetInitialState: () => new JSONState(mode, null, null, false),\n\t\ttokenize: (line, state, offsetDelta?, stopAtOffset?) => tokenize(mode, supportComments, line, <JSONState> state, offsetDelta, stopAtOffset)\n\t};\n}\n\nclass JSONState implements Modes.IState {\n\n\tprivate _mode: Modes.IMode;\n\tprivate _state: Modes.IState;\n\n\tpublic scanError: json.ScanError;\n\tpublic lastWasColon: boolean;\n\n\tconstructor(mode: Modes.IMode, state: Modes.IState, scanError: json.ScanError, lastWasColon:boolean) {\n\t\tthis._mode = mode;\n\t\tthis._state = state;\n\t\tthis.scanError = scanError;\n\t\tthis.lastWasColon = lastWasColon;\n\t}\n\n\tpublic clone():JSONState {\n\t\treturn new JSONState(this._mode, this._state, this.scanError, this.lastWasColon);\n\t}\n\n\tpublic equals(other:Modes.IState):boolean {\n\t\tif(other === this) {\n\t\t\treturn true;\n\t\t}\n\t\tif(!other || !(other instanceof JSONState)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.scanError === (<JSONState> other).scanError &&\n\t\t\tthis.lastWasColon === (<JSONState> other).lastWasColon;\n\t}\n\n\tpublic getMode():Modes.IMode {\n\t\treturn this._mode;\n\t}\n\n\tpublic tokenize(stream:any):Modes.ITokenizationResult {\n\t\tthrow new Error();\n\t}\n\n\tpublic getStateData():Modes.IState {\n\t\treturn this._state;\n\t}\n\n\tpublic setStateData(state:Modes.IState):void {\n\t\tthis._state = state;\n\t}\n}\n\nfunction tokenize(mode:Modes.IMode, comments:boolean, line:string, state:JSONState, offsetDelta:number = 0, stopAtOffset?:number):Modes.ILineTokens {\n\n\t// handle multiline strings and block comments\n\tvar numberOfInsertedCharacters = 0,\n\t\tadjustOffset = false;\n\n\tswitch(state.scanError) {\n\t\tcase json.ScanError.UnexpectedEndOfString:\n\t\t\tline = '\"' + line;\n\t\t\tnumberOfInsertedCharacters = 1;\n\t\t\tbreak;\n\t\tcase json.ScanError.UnexpectedEndOfComment:\n\t\t\tline = '/*' + line;\n\t\t\tnumberOfInsertedCharacters = 2;\n\t\t\tbreak;\n\t}\n\n\tvar scanner = json.createScanner(line),\n\t\tkind: json.SyntaxKind,\n\t\tret:Modes.ILineTokens,\n\t\tlastWasColon = state.lastWasColon;\n\n\tret = {\n\t\ttokens: <Modes.IToken[]>[],\n\t\tactualStopOffset: line.length,\n\t\tendState: state.clone(),\n\t\tmodeTransitions: [{ startIndex: 0, mode: mode }],\n\t};\n\n\twhile(true) {\n\n\t\tvar offset = offsetDelta + scanner.getPosition(),\n\t\t\ttype = '';\n\n\t\tkind = scanner.scan();\n\t\tif(kind === json.SyntaxKind.EOF) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// Check that the scanner has advanced\n\t\tif (offset === offsetDelta + scanner.getPosition()) {\n\t\t\tthrow new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n\t\t}\n\n\t\t// In case we inserted /* or \" character, we need to\n\t\t// adjust the offset of all tokens (except the first)\n\t\tif(adjustOffset) {\n\t\t\toffset -= numberOfInsertedCharacters;\n\t\t}\n\t\tadjustOffset = numberOfInsertedCharacters > 0;\n\n\n\t\t// brackets and type\n\t\tswitch(kind) {\n\t\t\tcase json.SyntaxKind.OpenBraceToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CloseBraceToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_OBJECT;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.OpenBracketToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CloseBracketToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_ARRAY;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.ColonToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_COLON;\n\t\t\t\tlastWasColon = true;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.CommaToken:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_DELIM_COMMA;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.TrueKeyword:\n\t\t\tcase json.SyntaxKind.FalseKeyword:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_BOOLEAN;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.NullKeyword:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_NULL;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.StringLiteral:\n\t\t\t\ttype = lastWasColon ? jsonTokenTypes.TOKEN_VALUE_STRING : jsonTokenTypes.TOKEN_PROPERTY_NAME;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t\tcase json.SyntaxKind.NumericLiteral:\n\t\t\t\ttype = jsonTokenTypes.TOKEN_VALUE_NUMBER;\n\t\t\t\tlastWasColon = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// comments, iff enabled\n\t\tif(comments) {\n\t\t\tswitch (kind) {\n\t\t\t\tcase json.SyntaxKind.LineCommentTrivia:\n\t\t\t\t\ttype = jsonTokenTypes.TOKEN_COMMENT_LINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase json.SyntaxKind.BlockCommentTrivia:\n\t\t\t\t\ttype = jsonTokenTypes.TOKEN_COMMENT_BLOCK;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tret.endState = new JSONState(state.getMode(), state.getStateData(), scanner.getTokenError(), lastWasColon);\n\t\tret.tokens.push({\n\t\t\tstartIndex: offset,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\treturn ret;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport editorCommon = require('vs/editor/common/editorCommon');\nimport modes = require('vs/editor/common/modes');\nimport URI from 'vs/base/common/uri';\nimport WinJS = require('vs/base/common/winjs.base');\nimport Platform = require('vs/platform/platform');\nimport jsonWorker = require('vs/languages/json/common/jsonWorker');\nimport tokenization = require('vs/languages/json/common/features/tokenization');\nimport {AbstractMode, createWordRegExp, ModeWorkerManager} from 'vs/editor/common/modes/abstractMode';\nimport {OneWorkerAttr, AllWorkersAttr} from 'vs/platform/thread/common/threadService';\nimport {IThreadService, ThreadAffinity} from 'vs/platform/thread/common/thread';\nimport {IJSONContributionRegistry, Extensions, ISchemaContributions} from 'vs/platform/jsonschemas/common/jsonContributionRegistry';\nimport {IInstantiationService} from 'vs/platform/instantiation/common/instantiation';\nimport {RichEditSupport} from 'vs/editor/common/modes/supports/richEditSupport';\nimport {wireCancellationToken} from 'vs/base/common/async';\n\nexport class JSONMode extends AbstractMode {\n\n\tpublic tokenizationSupport: modes.ITokenizationSupport;\n\tpublic richEditSupport: modes.IRichEditSupport;\n\tpublic configSupport:modes.IConfigurationSupport;\n\tpublic inplaceReplaceSupport:modes.IInplaceReplaceSupport;\n\n\tprivate _modeWorkerManager: ModeWorkerManager<jsonWorker.JSONWorker>;\n\tprivate _threadService:IThreadService;\n\n\tconstructor(\n\t\tdescriptor:modes.IModeDescriptor,\n\t\t@IInstantiationService instantiationService: IInstantiationService,\n\t\t@IThreadService threadService: IThreadService\n\t) {\n\t\tsuper(descriptor.id);\n\t\tthis._modeWorkerManager = new ModeWorkerManager<jsonWorker.JSONWorker>(descriptor, 'vs/languages/json/common/jsonWorker', 'JSONWorker', null, instantiationService);\n\t\tthis._threadService = threadService;\n\n\t\tthis.tokenizationSupport = tokenization.createTokenizationSupport(this, true);\n\n\t\tthis.richEditSupport = new RichEditSupport(this.getId(), null, {\n\n\t\t\twordPattern: createWordRegExp('.-'),\n\n\t\t\tcomments: {\n\t\t\t\tlineComment: '//',\n\t\t\t\tblockComment: ['/*', '*/']\n\t\t\t},\n\n\t\t\tbrackets: [\n\t\t\t\t['{', '}'],\n\t\t\t\t['[', ']']\n\t\t\t],\n\n\t\t\tautoClosingPairs: [\n\t\t\t\t{ open: '{', close: '}', notIn: ['string'] },\n\t\t\t\t{ open: '[', close: ']', notIn: ['string'] },\n\t\t\t\t{ open: '\"', close: '\"', notIn: ['string'] }\n\t\t\t]\n\t\t});\n\n\t\tmodes.HoverProviderRegistry.register(this.getId(), {\n\t\t\tprovideHover: (model, position, token): Thenable<modes.Hover> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideHover(model.uri, position));\n\t\t\t}\n\t\t}, true);\n\n\t\tthis.inplaceReplaceSupport = this;\n\n\t\tthis.configSupport = this;\n\n\t\t// Initialize Outline support\n\t\tmodes.DocumentSymbolProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentSymbols: (model, token): Thenable<modes.SymbolInformation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentSymbols(model.uri));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.DocumentFormattingEditProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentFormattingEdits: (model, options, token): Thenable<editorCommon.ISingleEditOperation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentFormattingEdits(model.uri, options));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.DocumentRangeFormattingEditProviderRegistry.register(this.getId(), {\n\t\t\tprovideDocumentRangeFormattingEdits: (model, range, options, token): Thenable<editorCommon.ISingleEditOperation[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideDocumentRangeFormattingEdits(model.uri, range, options));\n\t\t\t}\n\t\t}, true);\n\n\t\tmodes.SuggestRegistry.register(this.getId(), {\n\t\t\ttriggerCharacters: [],\n\t\t\tshouldAutotriggerSuggest: true,\n\t\t\tprovideCompletionItems: (model, position, token): Thenable<modes.ISuggestResult[]> => {\n\t\t\t\treturn wireCancellationToken(token, this._provideCompletionItems(model.uri, position));\n\t\t\t}\n\t\t}, true);\n\t}\n\n\tpublic creationDone(): void {\n\t\tif (this._threadService.isInMainThread) {\n\t\t\t// Pick a worker to do validation\n\t\t\tthis._pickAWorkerToValidate();\n\n\t\t\t// Configure all workers\n\t\t\tthis._configureWorkerSchemas(this.getSchemaConfiguration());\n\t\t\tvar contributionRegistry = <IJSONContributionRegistry> Platform.Registry.as(Extensions.JSONContribution);\n\t\t\tcontributionRegistry.addRegistryChangedListener(e => {\n\t\t\t\tthis._configureWorkerSchemas(this.getSchemaConfiguration());\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate _worker<T>(runner:(worker:jsonWorker.JSONWorker)=>WinJS.TPromise<T>): WinJS.TPromise<T> {\n\t\treturn this._modeWorkerManager.worker(runner);\n\t}\n\n\tprivate getSchemaConfiguration() : ISchemaContributions {\n\t\tvar contributionRegistry = <IJSONContributionRegistry> Platform.Registry.as(Extensions.JSONContribution);\n\t\treturn contributionRegistry.getSchemaContributions();\n\t}\n\n\tpublic configure(options:any): WinJS.TPromise<void> {\n\t\tif (this._threadService.isInMainThread) {\n\t\t\treturn this._configureWorkers(options);\n\t\t} else {\n\t\t\treturn this._worker((w) => w._doConfigure(options));\n\t\t}\n\t}\n\n\tstatic $_configureWorkers = AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkers);\n\tprivate _configureWorkers(options:any): WinJS.TPromise<void> {\n\t\treturn this._worker((w) => w._doConfigure(options));\n\t}\n\n\tstatic $_configureWorkerSchemas = AllWorkersAttr(JSONMode, JSONMode.prototype._configureWorkerSchemas);\n\tprivate _configureWorkerSchemas(data:ISchemaContributions): WinJS.TPromise<boolean> {\n\t\treturn this._worker((w) => w.setSchemaContributions(data));\n\t}\n\n\tstatic $_pickAWorkerToValidate = OneWorkerAttr(JSONMode, JSONMode.prototype._pickAWorkerToValidate, ThreadAffinity.Group1);\n\tprivate _pickAWorkerToValidate(): WinJS.TPromise<void> {\n\t\treturn this._worker((w) => w.enableValidator());\n\t}\n\n\tstatic $navigateValueSet = OneWorkerAttr(JSONMode, JSONMode.prototype.navigateValueSet);\n\tpublic navigateValueSet(resource:URI, position:editorCommon.IRange, up:boolean):WinJS.TPromise<modes.IInplaceReplaceSupportResult> {\n\t\treturn this._worker((w) => w.navigateValueSet(resource, position, up));\n\t}\n\n\tstatic $_provideCompletionItems = OneWorkerAttr(JSONMode, JSONMode.prototype._provideCompletionItems);\n\tprivate _provideCompletionItems(resource:URI, position:editorCommon.IPosition):WinJS.TPromise<modes.ISuggestResult[]> {\n\t\treturn this._worker((w) => w.provideCompletionItems(resource, position));\n\t}\n\n\tstatic $_provideHover = OneWorkerAttr(JSONMode, JSONMode.prototype._provideHover);\n\tprivate _provideHover(resource:URI, position:editorCommon.IPosition): WinJS.TPromise<modes.Hover> {\n\t\treturn this._worker((w) => w.provideHover(resource, position));\n\t}\n\n\tstatic $_provideDocumentSymbols = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentSymbols);\n\tprivate _provideDocumentSymbols(resource:URI):WinJS.TPromise<modes.SymbolInformation[]> {\n\t\treturn this._worker((w) => w.provideDocumentSymbols(resource));\n\t}\n\n\tstatic $_provideDocumentFormattingEdits = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentFormattingEdits);\n\tpublic _provideDocumentFormattingEdits(resource:URI, options:modes.IFormattingOptions):WinJS.TPromise<editorCommon.ISingleEditOperation[]> {\n\t\treturn this._worker((w) => w.format(resource, null, options));\n\t}\n\n\tstatic $_provideDocumentRangeFormattingEdits = OneWorkerAttr(JSONMode, JSONMode.prototype._provideDocumentRangeFormattingEdits);\n\tpublic _provideDocumentRangeFormattingEdits(resource:URI, range:editorCommon.IRange, options:modes.IFormattingOptions):WinJS.TPromise<editorCommon.ISingleEditOperation[]> {\n\t\treturn this._worker((w) => w.format(resource, range, options));\n\t}\n}"]}